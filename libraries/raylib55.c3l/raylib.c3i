// This file requires 0.7.7 or later.
module raylib5::rl;

const float PI = 3.14159265358979323846f;
const float DEG2RAD = PI / 180.0f;
const float RAD2DEG = 180.0f / PI;

// Some Basic Colors
// NOTE: Custom raylib color palette for amazing visuals on WHITE background
const Color LIGHTGRAY   = { 200, 200, 200, 255 };   // Light Gray
const Color GRAY        = { 130, 130, 130, 255 };   // Gray
const Color DARKGRAY    = { 80, 80, 80, 255 };      // Dark Gray
const Color YELLOW      = { 253, 249, 0, 255 };     // Yellow
const Color GOLD        = { 255, 203, 0, 255 };     // Gold
const Color ORANGE      = { 255, 161, 0, 255 };     // Orange
const Color PINK        = { 255, 109, 194, 255 };   // Pink
const Color RED         = { 230, 41, 55, 255 };     // Red
const Color MAROON      = { 190, 33, 55, 255 };     // Maroon
const Color GREEN       = { 0, 228, 48, 255 };      // Green
const Color LIME        = { 0, 158, 47, 255 };      // Lime
const Color DARKGREEN   = { 0, 117, 44, 255 };      // Dark Green
const Color SKYBLUE     = { 102, 191, 255, 255 };   // Sky Blue
const Color BLUE        = { 0, 121, 241, 255 };     // Blue
const Color DARKBLUE    = { 0, 82, 172, 255 };      // Dark Blue
const Color PURPLE      = { 200, 122, 255, 255 };   // Purple
const Color VIOLET      = { 135, 60, 190, 255 };    // Violet
const Color DARKPURPLE  = { 112, 31, 126, 255 };    // Dark Purple
const Color BEIGE       = { 211, 176, 131, 255 };   // Beige
const Color BROWN       = { 127, 106, 79, 255 };    // Brown
const Color DARKBROWN   = { 76, 63, 47, 255 };      // Dark Brown

const Color WHITE       = { 255, 255, 255, 255 };   // White
const Color BLACK       = { 0, 0, 0, 255 };         // Black
const Color BLANK       = { 0, 0, 0, 0 };           // Blank (Transparent)
const Color MAGENTA     = { 255, 0, 255, 255 };     // Magenta
const Color RAYWHITE    = { 245, 245, 245, 255 };   // My own White (raylib logo)

alias Vector2 = float[<2>];
alias Vector3 = float[<3>];
alias Vector4 = float[<4>];

// Quaternion, 4 components (Vector4 alias)
alias Quaternion = Vector4;

// Matrix, 4x4 components, column major, OpenGL style, right handed
struct Matrix
{
	float m0, m4, m8, m12;  // Matrix first row (4 components)
	float m1, m5, m9, m13;  // Matrix second row (4 components)
	float m2, m6, m10, m14; // Matrix third row (4 components)
	float m3, m7, m11, m15; // Matrix fourth row (4 components)
}

// Color, 4 components, R8G8B8A8 (32bit)
alias Color = char[<4>];

// Rectangle, 4 components
union Rectangle
{
	struct
	{
		float x;                // Rectangle top-left corner position x
		float y;                // Rectangle top-left corner position y
		float width;            // Rectangle width
		float height;           // Rectangle height
	}
	struct
	{
		Vector2 pos;
		Vector2 size;
	}
}

// Image, pixel data stored in CPU memory (RAM)
struct Image
{
	void* data;             // Image raw data
	CInt width;             // Image base width
	CInt height;            // Image base height
	CInt mipmaps;           // Mipmap levels, 1 by default
	PixelFormat format;     // Data format (PixelFormat type)
}

// Texture, tex data stored in GPU memory (VRAM)
struct Texture
{
	CUInt id;               // OpenGL texture id
	CInt width;             // Texture base width
	CInt height;            // Texture base height
	CInt mipmaps;           // Mipmap levels, 1 by default
	PixelFormat format;     // Data format (PixelFormat type)
}

// Texture2D, same as Texture
alias Texture2D = Texture;

// TextureCubemap, same as Texture
alias TextureCubemap = Texture;

// RenderTexture, fbo for texture rendering
struct RenderTexture
{
	CUInt id;               // OpenGL framebuffer object id
	Texture texture;        // Color buffer attachment texture
	Texture depth;          // Depth buffer attachment texture
}

// RenderTexture2D, same as RenderTexture
alias RenderTexture2D = RenderTexture;

// NPatchInfo, n-patch layout info
struct NPatchInfo
{
	Rectangle source;       // Texture source rectangle
	CInt left;              // Left border offset
	CInt top;               // Top border offset
	CInt right;             // Right border offset
	CInt bottom;            // Bottom border offset
	NPatchLayout layout;    // Layout of the n-patch: 3x3, 1x3 or 3x1
}

// GlyphInfo, font characters glyphs info
struct GlyphInfo
{
	CInt value;             // Character value (Unicode)
	CInt[<2>] offsetX;      // Character offset when drawing
	CInt advanceX;          // Character advance position X
	Image image;            // Character image data
}

// Font, font texture and GlyphInfo array data
struct Font
{
	CInt baseSize;          // Base size (default chars height)
	CInt glyphCount;        // Number of glyph characters
	CInt glyphPadding;      // Padding around the glyph characters
	Texture2D texture;      // Texture atlas containing the glyphs
	Rectangle* recs;        // Rectangles in texture for the glyphs
	GlyphInfo* glyphs;      // Glyphs info data
}

// Camera, defines position/orientation in 3d space
struct Camera3D
{
	Vector3 position;               // Camera position
	Vector3 target;                 // Camera target it looks-at
	Vector3 up;                     // Camera up vector (rotation over its axis)
	float fovy;                     // Camera field-of-view apperture in Y (degrees) in perspective, used as near plane width in orthographic
	CameraProjection projection;    // Camera projection: CAMERA_PERSPECTIVE or CAMERA_ORTHOGRAPHIC
}

alias Camera = Camera3D;    // Camera type fallback, defaults to Camera3D

// Camera2D, defines position/orientation in 2d space
struct Camera2D
{
	Vector2 offset;         // Camera offset (displacement from target)
	Vector2 target;         // Camera target (rotation and zoom origin)
	float rotation;         // Camera rotation in degrees
	float zoom;             // Camera zoom (scaling), should be 1.0f by default
}

// Mesh, vertex data and vao/vbo
struct Mesh
{
	CInt vertexCount;       // Number of vertices stored in arrays
	CInt triangleCount;     // Number of triangles stored (indexed or not)

	// Vertex attributes data
	float* vertices;        // Vertex position (XYZ - 3 components per vertex) (shader-location = 0)
	float* texcoords;       // Vertex texture coordinates (UV - 2 components per vertex) (shader-location = 1)
	float* texcoords2;      // Vertex second texture coordinates (useful for lightmaps) (shader-location = 5)
	float* normals;         // Vertex normals (XYZ - 3 components per vertex) (shader-location = 2)
	float* tangents;        // Vertex tangents (XYZW - 4 components per vertex) (shader-location = 4)
	CChar* colors;          // Vertex colors (RGBA - 4 components per vertex) (shader-location = 3)
	CUShort *indices;       // Vertex indices (in case vertex data comes indexed)

	// Animation vertex data
	float* animVertices;    // Animated vertex positions (after bones transformations)
	float* animNormals;     // Animated normals (after bones transformations)
	CChar* boneIds;         // Vertex bone ids, max 255 bone ids, up to 4 bones influence by vertex (skinning)
	float* boneWeights;     // Vertex bone weight, up to 4 bones influence by vertex (skinning)
	Matrix *boneMatrices;   // Bones animated transformation matrices
	CInt boneCount;         // Number of bones

	// OpenGL identifiers
	CUInt vaoId;            // OpenGL Vertex Array Object id
	CUInt* vboId;           // OpenGL Vertex Buffer Objects id (default vertex data)
}

// Shader
struct Shader
{
	CUInt id;               // Shader program id
	CInt* locs;             // Shader locations array (RL_MAX_SHADER_LOCATIONS)
}

// MaterialMap
struct MaterialMap
{
	Texture2D texture;      // Material map texture
	Color color;            // Material map color
	float value;            // Material map value
}

// Material, includes shader and maps
struct Material
{
	Shader shader;          // Material shader
	MaterialMap* maps;      // Material maps array (MAX_MATERIAL_MAPS)
	float[4] params;        // Material generic parameters (if required)
}

// Transform, vectex transformation data
struct Transform
{
	Vector3 translation;    // Translation
	Quaternion rotation;    // Rotation
	Vector3 scale;          // Scale
}

// Bone, skeletal animation bone
struct BoneInfo
{
	CChar[32] name;         // Bone name
	CInt parent;            // Bone parent
}

// Model, meshes, materials and animation data
struct Model
{
	Matrix transform;       // Local transform matrix
	CInt meshCount;         // Number of meshes
	CInt materialCount;     // Number of materials
	Mesh* meshes;           // Meshes array
	Material* materials;    // Materials array
	CInt* meshMaterial;     // Mesh material number

	// Animation data
	CInt boneCount;         // Number of bones
	BoneInfo* bones;        // Bones information (skeleton)
	Transform* bindPose;    // Bones base transformation (pose)
}

// ModelAnimation
struct ModelAnimation
{
	CInt boneCount;         // Number of bones
	CInt frameCount;        // Number of animation frames
	BoneInfo* bones;        // Bones information (skeleton)
	Transform** framePoses; // Poses array by frame
	CChar[32] name;         // Animation name
}

// Ray, ray for raycasting
struct Ray
{
	Vector3 position;       // Ray position (origin)
	Vector3 direction;      // Ray direction (normalized)
}

// RayCollision, ray hit information
struct RayCollision
{
	bool hit;               // Did the ray hit something?
	float distance;         // Distance to nearest hit
	Vector3 point;          // Point of nearest hit
	Vector3 normal;         // Surface normal of hit
}

// BoundingBox
struct BoundingBox @compact
{
	Vector3 min;            // Minimum vertex box-corner
	Vector3 max;            // Maximum vertex box-corner
}

// Wave, audio wave data
struct Wave
{
	CUInt frameCount;           // Total number of frames (considering channels)
	CUInt sampleRate;           // Frequency (samples per second)
	CUInt sampleSize;           // Bit depth (bits per sample): 8, 16, 32 (24 not supported)
	CUInt channels;             // Number of channels (1-mono, 2-stereo, ...)
	void* data;                 // Buffer data pointer
}

alias AudioBufferRef = void*;
alias AudioProcessorRef = void*;

// AudioStream, custom audio stream
struct AudioStream
{
	AudioBufferRef buffer;       // Pointer to internal data used by the audio system
	AudioProcessorRef processor; // Pointer to internal data processor, useful for audio effects

	CUInt sampleRate;            // Frequency (samples per second)
	CUInt sampleSize;            // Bit depth (bits per sample): 8, 16, 32 (24 not supported)
	CUInt channels;              // Number of channels (1-mono, 2-stereo, ...)
}


// Sound
struct Sound
{
	AudioStream stream;         // Audio stream
	CUInt frameCount;           // Total number of frames (considering channels)
}

// Music, audio stream, anything longer than ~10 seconds should be streamed
struct Music
{
	AudioStream stream;         // Audio stream
	CUInt frameCount;           // Total number of frames (considering channels)
	bool looping;               // Music looping enable

	CInt ctxType;               // Type of music context (audio filetype)
	void* ctxData;              // Audio context data, depends on type
}

// VrDeviceInfo, Head-Mounted-Display device parameters
struct VrDeviceInfo
{
	CInt hResolution;               // Horizontal resolution in pixels
	CInt vResolution;               // Vertical resolution in pixels
	float hScreenSize;              // Horizontal size in meters
	float vScreenSize;              // Vertical size in meters
	float vScreenCenter;            // Screen center in meters
	float eyeToScreenDistance;      // Distance between eye and display in meters
	float lensSeparationDistance;   // Lens separation distance in meters
	float interpupillaryDistance;   // IPD (distance between pupils) in meters
	float[4] lensDistortionValues;  // Lens distortion constant parameters
	float[4] chromaAbCorrection;    // Chromatic aberration correction parameters
}

// VrStereoConfig, VR stereo rendering configuration for simulator
struct VrStereoConfig
{
	Matrix[2] projection;           // VR projection matrices (per eye)
	Matrix[2] viewOffset;           // VR view offset matrices (per eye)
	float[2] leftLensCenter;        // VR left lens center
	float[2] rightLensCenter;       // VR right lens center
	float[2] leftScreenCenter;      // VR left screen center
	float[2] rightScreenCenter;     // VR right screen center
	float[2] scale;                 // VR distortion scale
	float[2] scaleIn;               // VR distortion scale in
}

struct FilePathList
{
	CUInt capacity;                 // Filepaths max entries
	CUInt count;                    // Filepaths entries count
	ZString* paths;                 // Filepaths entries
}

// Automation event
struct AutomationEvent
{
	CUInt frame;                     // Event frame
	CUInt type;                      // Event type (AutomationEventType)
	CInt[4] params;                  // Event parameters (if required)
}

// Automation event list
struct AutomationEventList
{
	CUInt capacity;                 // Events max entries (MAX_AUTOMATION_EVENTS)
	CUInt count;                    // Events entries count
	AutomationEvent* events;        // Events entries
}

// Trace log level
// NOTE: Organized by priority level
constdef TraceLogLevel : CInt
{
	ALL = 0,        // Display all logs
	TRACE,          // Trace logging, intended for internal use only
	DEBUG,          // Debug logging, used for internal debugging, it should be disabled on release builds
	INFO,           // Info logging, used for program execution info
	WARNING,        // Warning logging, used on recoverable failures
	ERROR,          // Error logging, used on unrecoverable failures
	FATAL,          // Fatal logging, used to abort program: exit(EXIT_FAILURE)
	NONE            // Disable logging
}

// Mouse buttons
enum MouseButton : CInt
{
	LEFT,           // Mouse button left
	RIGHT,          // Mouse button right
	MIDDLE,         // Mouse button middle (pressed wheel)
	SIDE,           // Mouse button side (advanced mouse device)
	EXTRA,          // Mouse button extra (advanced mouse device)
	FORWARD,        // Mouse button forward (advanced mouse device)
	BACK,           // Mouse button back (advanced mouse device)
}

// Mouse cursor
enum MouseCursor : CInt
{
	DEFAULT,            // Default pointer shape
	ARROW,              // Arrow shape
	IBEAM,              // Text writing cursor shape
	CROSSHAIR,          // Cross shape
	POINTING_HAND,      // Pointing hand cursor
	RESIZE_EW,          // Horizontal resize/move arrow shape
	RESIZE_NS,          // Vertical resize/move arrow shape
	RESIZE_NWSE,        // Top-left to bottom-right diagonal resize/move arrow shape
	RESIZE_NESW,        // The top-right to bottom-left diagonal resize/move arrow shape
	RESIZE_ALL,         // The omnidirectional resize/move cursor shape
	NOT_ALLOWED,        // The operation-not-allowed shape
}

// Gamepad buttons
enum GamepadButton : CInt
{
	UNKNOWN,             // Unknown button, just for error checking
	LEFT_FACE_UP,        // Gamepad left DPAD up button
	LEFT_FACE_RIGHT,     // Gamepad left DPAD right button
	LEFT_FACE_DOWN,      // Gamepad left DPAD down button
	LEFT_FACE_LEFT,      // Gamepad left DPAD left button
	RIGHT_FACE_UP,       // Gamepad right button up (i.e. PS3: Triangle, Xbox: Y)
	RIGHT_FACE_RIGHT,    // Gamepad right button right (i.e. PS3: Circle, Xbox: B)
	RIGHT_FACE_DOWN,     // Gamepad right button down (i.e. PS3: Cross, Xbox: A)
	RIGHT_FACE_LEFT,     // Gamepad right button left (i.e. PS3: Square, Xbox: X)
	LEFT_TRIGGER_1,      // Gamepad top/back trigger left (first), it could be a trailing button
	LEFT_TRIGGER_2,      // Gamepad top/back trigger left (second), it could be a trailing button
	RIGHT_TRIGGER_1,     // Gamepad top/back trigger right (first), it could be a trailing button
	RIGHT_TRIGGER_2,     // Gamepad top/back trigger right (second), it could be a trailing button
	MIDDLE_LEFT,         // Gamepad center buttons, left one (i.e. PS3: Select)
	MIDDLE,              // Gamepad center buttons, middle one (i.e. PS3: PS, Xbox: XBOX)
	MIDDLE_RIGHT,        // Gamepad center buttons, right one (i.e. PS3: Start)
	LEFT_THUMB,          // Gamepad joystick pressed button left
	RIGHT_THUMB          // Gamepad joystick pressed button right
}

enum GamepadAxis : CInt
{
	LEFT_X,             // Gamepad left stick X axis
	LEFT_Y,             // Gamepad left stick Y axis
	RIGHT_X,            // Gamepad right stick X axis
	RIGHT_Y,            // Gamepad right stick Y axis
	LEFT_TRIGGER,       // Gamepad back trigger left, pressure level: [1..-1]
	RIGHT_TRIGGER,      // Gamepad back trigger right, pressure level: [1..-1]
}

// Material map index
constdef MaterialMapIndex : CInt
{
	ALBEDO = 0,        // Albedo material (same as: MATERIAL_MAP_DIFFUSE)
	METALNESS,         // Metalness material (same as: MATERIAL_MAP_SPECULAR)
	NORMAL,            // Normal material
	ROUGHNESS,         // Roughness material
	OCCLUSION,         // Ambient occlusion material
	EMISSION,          // Emission material
	HEIGHT,            // Heightmap material
	CUBEMAP,           // Cubemap material (NOTE: Uses GL_TEXTURE_CUBE_MAP)
	IRRADIANCE,        // Irradiance material (NOTE: Uses GL_TEXTURE_CUBE_MAP)
	PREFILTER,         // Prefilter material (NOTE: Uses GL_TEXTURE_CUBE_MAP)
	BRDF,              // Brdf material

	DIFFUSE = ALBEDO,  // #define MATERIAL_MAP_DIFFUSE      MATERIAL_MAP_ALBEDO
	SPECULAR = METALNESS, // #define MATERIAL_MAP_SPECULAR     MATERIAL_MAP_METALNESS
}

// Shader location index
constdef ShaderLocationIndex : CInt
{
	VERTEX_POSITION = 0, // Shader location: vertex attribute: position
	VERTEX_TEXCOORD01,   // Shader location: vertex attribute: texcoord01
	VERTEX_TEXCOORD02,   // Shader location: vertex attribute: texcoord02
	VERTEX_NORMAL,       // Shader location: vertex attribute: normal
	VERTEX_TANGENT,      // Shader location: vertex attribute: tangent
	VERTEX_COLOR,        // Shader location: vertex attribute: color
	MATRIX_MVP,          // Shader location: matrix uniform: model-view-projection
	MATRIX_VIEW,         // Shader location: matrix uniform: view (camera transform)
	MATRIX_PROJECTION,   // Shader location: matrix uniform: projection
	MATRIX_MODEL,        // Shader location: matrix uniform: model (transform)
	MATRIX_NORMAL,       // Shader location: matrix uniform: normal
	VECTOR_VIEW,         // Shader location: vector uniform: view
	COLOR_DIFFUSE,       // Shader location: vector uniform: diffuse color
	COLOR_SPECULAR,      // Shader location: vector uniform: specular color
	COLOR_AMBIENT,       // Shader location: vector uniform: ambient color
	MAP_ALBEDO,          // Shader location: sampler2d texture: albedo (same as: SHADER_LOC_MAP_DIFFUSE)
	MAP_METALNESS,       // Shader location: sampler2d texture: metalness (same as: SHADER_LOC_MAP_SPECULAR)
	MAP_NORMAL,          // Shader location: sampler2d texture: normal
	MAP_ROUGHNESS,       // Shader location: sampler2d texture: roughness
	MAP_OCCLUSION,       // Shader location: sampler2d texture: occlusion
	MAP_EMISSION,        // Shader location: sampler2d texture: emission
	MAP_HEIGHT,          // Shader location: sampler2d texture: height
	MAP_CUBEMAP,         // Shader location: samplerCube texture: cubemap
	MAP_IRRADIANCE,      // Shader location: samplerCube texture: irradiance
	MAP_PREFILTER,       // Shader location: samplerCube texture: prefilter
	MAP_BRDF,            // Shader location: sampler2d texture: brdf
	VERTEX_BONEIDS,      // Shader location: vertex attribute: boneIds
	VERTEX_BONEWEIGHTS,  // Shader location: vertex attribute: boneWeights
	BONE_MATRICES,       // Shader location: array of matrices uniform: boneMatrices

	MAP_DIFFUSE = MAP_ALBEDO, // #define SHADER_LOC_MAP_DIFFUSE      SHADER_LOC_MAP_ALBEDO
	MAP_SPECULAR = MAP_METALNESS, // #define SHADER_LOC_MAP_SPECULAR     SHADER_LOC_MAP_METALNESS
}

// Shader uniform data type
enum ShaderUniformDataType : CInt
{
	FLOAT,           // Shader uniform type: float
	VEC2,            // Shader uniform type: vec2 (2 float)
	VEC3,            // Shader uniform type: vec3 (3 float)
	VEC4,            // Shader uniform type: vec4 (4 float)
	INT,             // Shader uniform type: int
	IVEC2,           // Shader uniform type: ivec2 (2 int)
	IVEC3,           // Shader uniform type: ivec3 (3 int)
	IVEC4,           // Shader uniform type: ivec4 (4 int)
	SAMPLER2D        // Shader uniform type: sampler2d
}

// Shader attribute data types
enum ShaderAttributeDataType : CInt
{
	FLOAT,            // Shader attribute type: float
	VEC2,             // Shader attribute type: vec2 (2 float)
	VEC3,             // Shader attribute type: vec3 (3 float)
	VEC4              // Shader attribute type: vec4 (4 float)
}

// Pixel formats
// NOTE: Support depends on OpenGL version and platform
constdef PixelFormat : CInt
{
	UNCOMPRESSED_GRAYSCALE = 1, // 8 bit per pixel (no alpha)
	UNCOMPRESSED_GRAY_ALPHA,    // 8*2 bpp (2 channels)
	UNCOMPRESSED_R5G6B5,        // 16 bpp
	UNCOMPRESSED_R8G8B8,        // 24 bpp
	UNCOMPRESSED_R5G5B5A1,      // 16 bpp (1 bit alpha)
	UNCOMPRESSED_R4G4B4A4,      // 16 bpp (4 bit alpha)
	UNCOMPRESSED_R8G8B8A8,      // 32 bpp
	UNCOMPRESSED_R32,           // 32 bpp (1 channel - float)
	UNCOMPRESSED_R32G32B32,     // 32*3 bpp (3 channels - float)
	UNCOMPRESSED_R32G32B32A32,  // 32*4 bpp (4 channels - float)
	UNCOMPRESSED_R16,           // 16 bpp (1 channel - half float)
	UNCOMPRESSED_R16G16B16,     // 16*3 bpp (3 channels - half float)
	UNCOMPRESSED_R16G16B16A16,  // 16*4 bpp (4 channels - half float)
	COMPRESSED_DXT1_RGB,        // 4 bpp (no alpha)
	COMPRESSED_DXT1_RGBA,       // 4 bpp (1 bit alpha)
	COMPRESSED_DXT3_RGBA,       // 8 bpp
	COMPRESSED_DXT5_RGBA,       // 8 bpp
	COMPRESSED_ETC1_RGB,        // 4 bpp
	COMPRESSED_ETC2_RGB,        // 4 bpp
	COMPRESSED_ETC2_EAC_RGBA,   // 8 bpp
	COMPRESSED_PVRT_RGB,        // 4 bpp
	COMPRESSED_PVRT_RGBA,       // 4 bpp
	COMPRESSED_ASTC_4X4_RGBA,   // 8 bpp
	COMPRESSED_ASTC_8X8_RGBA    // 2 bpp
}

// Texture parameters: filter mode
// NOTE 1: Filtering considers mipmaps if available in the texture
// NOTE 2: Filter is accordingly set for minification and magnification
enum TextureFilter : CInt
{
	POINT,               // No filter, just pixel approximation
	BILINEAR,                // Linear filtering
	TRILINEAR,               // Trilinear filtering (linear with mipmaps)
	ANISOTROPIC_4X,          // Anisotropic filtering 4x
	ANISOTROPIC_8X,          // Anisotropic filtering 8x
	ANISOTROPIC_16X,         // Anisotropic filtering 16x
}

// Texture parameters: wrap mode
enum TextureWrap : CInt
{
	REPEAT,                    // Repeats texture in tiled mode
	CLAMP,                     // Clamps texture to edge pixel in tiled mode
	MIRROR_REPEAT,             // Mirrors and repeats the texture in tiled mode
	MIRROR_CLAMP               // Mirrors and clamps to border the texture in tiled mode
}

// Cubemap layouts
enum CubemapLayout : CInt
{
	AUTO_DETECT,             // Automatically detect layout type
	LINE_VERTICAL,           // Layout is defined by a vertical line with faces
	LINE_HORIZONTAL,         // Layout is defined by a horizontal line with faces
	CROSS_THREE_BY_FOUR,     // Layout is defined by a 3x4 cross with cubemap faces
	CROSS_FOUR_BY_THREE,     // Layout is defined by a 4x3 cross with cubemap faces
}

// Font type, defines generation method
enum FontType : CInt
{
	DEFAULT,                   // Default font generation, anti-aliased
	BITMAP,                    // Bitmap font generation, no anti-aliasing
	SDF,                       // SDF font generation, requires external shader
}

// Color blending modes (pre-defined)
enum BlendMode : CInt
{
	ALPHA,                    // Blend textures considering alpha (default)
	ADDITIVE,                 // Blend textures adding colors
	MULTIPLIED,               // Blend textures multiplying colors
	ADD_COLORS,               // Blend textures adding colors (alternative)
	SUBTRACT_COLORS,          // Blend textures subtracting colors (alternative)
	ALPHA_PREMULTIPLY,        // Blend premultiplied textures considering alpha
	CUSTOM,                   // Blend textures using custom src/dst factors (use setBlendFactors())
	CUSTOM_SEPARATE,          // Blend textures using custom rgb/alpha separate src/dst factors (use setBlendFactorsSeparate())
}

$assert(BlendMode.ALPHA.ordinal == 0);


// Camera system modes
enum CameraMode : CInt
{
	CUSTOM,                  // Camera custom, controlled by user (UpdateCamera() does nothing)
	FREE,                    // Camera free mode
	ORBITAL,                 // Camera orbital, around target, zoom supported
	FIRST_PERSON,            // Camera first person
	THIRD_PERSON,            // Camera third person
}

// Camera projection
enum CameraProjection : CInt
{
	PERSPECTIVE,             // Perspective projection
	ORTHOGRAPHIC,            // Orthographic projection
}

// N-patch layout
enum NPatchLayout : CInt
{
	NINE_PATCH,              // Npatch layout: 3x3 tiles
	THREE_PATCH_VERTICAL,    // Npatch layout: 1x3 tiles
	THREE_PATCH_HORIZONTAL   // Npatch layout: 3x1 tiles
}

// Callbacks to hook some internal functions
// WARNING: This callbacks are intended for advance users
alias TraceLogCallback @if($defined(CVaList)) = fn void(TraceLogLevel logLevel, ZString text, CVaList args);  // Logging: Redirect trace log messages
alias LoadFileDataCallback = fn char*(ZString file_name, CInt* data_size);             // FileIO: Load binary data
alias SaveFileDataCallback = fn bool(ZString file_name, void *data, CInt data_size);   // FileIO: Save binary data
alias LoadFileTextCallback = fn char*(ZString file_name);              // FileIO: Load text data
alias SaveFileTextCallback = fn bool(ZString file_name, ZString text); // FileIO: Save text data

// Window-related functions
fn void initWindow(CInt width, CInt height, ZString title) @cname("InitWindow");        // Initialize window and OpenGL context
fn void closeWindow() @cname("CloseWindow");                                            // Close window and unload OpenGL context
fn bool windowShouldClose() @cname("WindowShouldClose");                                // Check if application should close (KEY_ESCAPE pressed or windows close icon clicked)
fn bool isWindowReady() @cname("IsWindowReady");                                        // Check if window has been initialized successfully
fn bool isWindowFullscreen() @cname("IsWindowFullscreen");                              // Check if window is currently fullscreen
fn bool isWindowHidden() @cname("IsWindowHidden");                                      // Check if window is currently hidden
fn bool isWindowMinimized() @cname("IsWindowMinimized");                                // Check if window is currently minimized
fn bool isWindowMaximized() @cname("IsWindowMaximized");                                // Check if window is currently maximized
fn bool isWindowFocused() @cname("IsWindowFocused");                                    // Check if window is currently focused
fn bool isWindowResized() @cname("IsWindowResized");                                    // Check if window has been resized last frame
fn bool isWindowState(ConfigFlag flag) @cname("IsWindowState");                        // Check if one specific window flag is enabled
fn void setWindowState(ConfigFlag flags) @cname("SetWindowState");                     // Set window configuration state using flags
fn void clearWindowState(ConfigFlag flags) @cname("ClearWindowState");                 // Clear window configuration state flags
fn void toggleFullscreen() @cname("ToggleFullscreen");                                  // Toggle window state: fullscreen/windowed, resizes monitor to match window resolution
fn void toggleBorderlessWindowed() @cname("ToggleBorderlessWindowed");                  // Toggle window state: borderless windowed, resizes window to match monitor resolution
fn void maximizeWindow() @cname("MaximizeWindow");                                      // Set window state: maximized, if resizable
fn void minimizeWindow() @cname("MinimizeWindow");                                      // Set window state: minimized, if resizable
fn void restoreWindow() @cname("RestoreWindow");                                        // Set window state: not minimized/maximized
fn void setWindowIcon(Image image) @cname("SetWindowIcon");                             // Set icon for window (single image, RGBA 32bit)
fn void setWindowIcons(Image *images, CInt count) @cname("SetWindowIcons");             // Set icon for window (multiple images, RGBA 32bit)
fn void setWindowTitle(ZString title) @cname("SetWindowTitle");                         // Set title for window
fn void setWindowPosition(CInt x, CInt y) @cname("SetWindowPosition");                  // Set window position on screen
fn void setWindowMonitor(CInt monitor) @cname("SetWindowMonitor");                      // Set monitor for the current window
fn void setWindowMinSize(CInt width, CInt height) @cname("SetWindowMinSize");           // Set window minimum dimensions (for FLAG_WINDOW_RESIZABLE)
fn void setWindowMaxSize(CInt width, CInt height) @cname("SetWindowMaxSize");           // Set window maximum dimensions (for FLAG_WINDOW_RESIZABLE)
fn void setWindowSize(CInt width, CInt height) @cname("SetWindowSize");                 // Set window dimensions
fn void setWindowOpacity(float opacity) @cname("SetWindowOpacity");                     // Set window opacity [0.0f..1.0f]
fn void setWindowFocused() @cname("SetWindowFocused");                                  // Set window focused
fn void *getWindowHandle() @cname("GetWindowHandle");                                   // Get native window handle
fn int getScreenWidth() @cname("GetScreenWidth");                                       // Get current screen width
fn CInt getScreenHeight() @cname("GetScreenHeight");                                    // Get current screen height
fn CInt getRenderWidth() @cname("GetRenderWidth");                                      // Get current render width (it considers HiDPI)
fn CInt getRenderHeight() @cname("GetRenderHeight");                                    // Get current render height (it considers HiDPI)
fn CInt getMonitorCount() @cname("GetMonitorCount");                                    // Get number of connected monitors
fn CInt getCurrentMonitor() @cname("GetCurrentMonitor");                                // Get current monitor where window is placed
fn Vector2 getMonitorPosition(CInt monitor) @cname("GetMonitorPosition");               // Get specified monitor position
fn CInt getMonitorWidth(CInt monitor) @cname("GetMonitorWidth");                        // Get specified monitor width (current video mode used by monitor)
fn CInt getMonitorHeight(CInt monitor) @cname("GetMonitorHeight");                      // Get specified monitor height (current video mode used by monitor)
fn CInt getMonitorPhysicalWidth(CInt monitor) @cname("GetMonitorPhysicalWidth");        // Get specified monitor physical width in millimetres
fn CInt getMonitorPhysicalHeight(CInt monitor) @cname("GetMonitorPhysicalHeight");      // Get specified monitor physical height in millimetres
fn CInt getMonitorRefreshRate(CInt monitor) @cname("GetMonitorRefreshRate");            // Get specified monitor refresh rate
fn Vector2 getWindowPosition() @cname("GetWindowPosition");                             // Get window position XY on monitor
fn Vector2 getWindowScaleDPI() @cname("GetWindowScaleDPI");                             // Get window scale DPI factor
fn ZString getMonitorName(CInt monitor) @cname("GetMonitorName");                       // Get the human-readable, UTF-8 encoded name of the specified monitor
fn void setClipboardText(ZString text) @cname("SetClipboardText");                      // Set clipboard text content
fn ZString getClipboardText() @cname("GetClipboardText");                               // Get clipboard text content
fn Image getClipboardImage() @cname("GetClipboardImage");                               // Get clipboard image content
fn void enableEventWaiting() @cname("EnableEventWaiting");                              // Enable waiting for events on EndDrawing(), no automatic event polling
fn void disableEventWaiting() @cname("DisableEventWaiting");                            // Disable waiting for events on EndDrawing(), automatic events polling

                                                       // Cursor-related functions
fn void showCursor() @cname("ShowCursor");             // Shows cursor
fn void hideCursor() @cname("HideCursor");             // Hides cursor
fn bool isCursorHidden() @cname("IsCursorHidden");     // Check if cursor is not visible
fn void enableCursor() @cname("EnableCursor");         // Enables cursor (unlock cursor)
fn void disableCursor() @cname("DisableCursor");       // Disables cursor (lock cursor)
fn bool isCursorOnScreen() @cname("IsCursorOnScreen"); // Check if cursor is on the screen

// Drawing-related functions
fn void clearBackground(Color color) @cname("ClearBackground");                               // Set background color (framebuffer clear color)
fn void beginDrawing() @cname("BeginDrawing");                                                // Setup canvas (framebuffer) to start drawing
fn void endDrawing() @cname("EndDrawing");                                                    // End canvas drawing and swap buffers (double buffering)
fn void beginMode2D(Camera2D camera) @cname("BeginMode2D");                                   // Begin 2D mode with custom camera (2D)
fn void endMode2D() @cname("EndMode2D");                                                      // Ends 2D mode with custom camera
fn void beginMode3D(Camera3D camera) @cname("BeginMode3D");                                   // Begin 3D mode with custom camera (3D)
fn void endMode3D() @cname("EndMode3D");                                                      // Ends 3D mode and returns to default 2D orthographic mode
fn void beginTextureMode(RenderTexture2D target) @cname("BeginTextureMode");                  // Begin drawing to render texture
fn void endTextureMode() @cname("EndTextureMode");                                            // Ends drawing to render texture
fn void beginShaderMode(Shader shader) @cname("BeginShaderMode");                             // Begin custom shader drawing
fn void endShaderMode() @cname("EndShaderMode");                                              // End custom shader drawing (use default shader)
fn void beginBlendMode(BlendMode mode) @cname("BeginBlendMode");                              // Begin blending mode (alpha, additive, multiplied, subtract, custom)
fn void endBlendMode() @cname("EndBlendMode");                                                // End blending mode (reset to default: alpha blending)
fn void beginScissorMode(CInt x, CInt y, CInt width, CInt height) @cname("BeginScissorMode"); // Begin scissor mode (define screen area for following drawing)
fn void endScissorMode() @cname("EndScissorMode");                                            // End scissor mode
fn void beginVrStereoMode(VrStereoConfig config) @cname("BeginVrStereoMode");                 // Begin stereo rendering (requires VR simulator)
fn void endVrStereoMode() @cname("EndVrStereoMode");                                          // End stereo rendering (requires VR simulator)

// VR stereo config functions for VR simulator
fn VrStereoConfig loadVrStereoConfig(VrDeviceInfo device) @cname("LoadVrStereoConfig"); // Load VR stereo config for VR simulator device parameters
fn void unloadVrStereoConfig(VrStereoConfig config) @cname("UnloadVrStereoConfig");     // Unload VR stereo config

// Shader management functions
// NOTE: Shader functionality is not available on OpenGL 1.1
fn Shader loadShader(ZString vsFileName, ZString fsFileName) @cname("LoadShader");                                                                            // Load shader from files and bind default locations
fn Shader loadShaderFromMemory(ZString vsCode, ZString fsCode) @cname("LoadShaderFromMemory");                                                                // Load shader from code strings and bind default locations
fn bool isShaderValid(Shader shader) @cname("IsShaderValid");                                                                                                 // Check if a shader is valid (loaded on GPU)
fn CInt getShaderLocation(Shader shader, ZString uniformName) @cname("GetShaderLocation");                                                                    // Get shader uniform location
fn CInt getShaderLocationAttrib(Shader shader, ZString attribName) @cname("GetShaderLocationAttrib");                                                         // Get shader attribute location
fn void setShaderValue(Shader shader, CInt locIndex, void* value, ShaderUniformDataType uniformType) @cname("SetShaderValue");               // Set shader uniform value
fn void setShaderValueV(Shader shader, CInt locIndex, void* value, ShaderUniformDataType uniformType, CInt count) @cname("SetShaderValueV"); // Set shader uniform value vector
fn void setShaderValueMatrix(Shader shader, CInt locIndex, Matrix mat) @cname("SetShaderValueMatrix");                                         // Set shader uniform value (matrix 4x4)
fn void setShaderValueTexture(Shader shader, CInt locIndex, Texture2D texture) @cname("SetShaderValueTexture");                                // Set shader uniform value for texture (sampler2d)
fn void unloadShader(Shader shader) @cname("UnloadShader");                                                                                                   // Unload shader from GPU memory (VRAM)

// Screen-space-related functions
fn Ray getScreenToWorldRay(Vector2 position, Camera camera) @cname("GetScreenToWorldRay");                              // Get a ray trace from screen position (i.e mouse)
fn Ray getScreenToWorldRayEx(Vector2 position, Camera camera, CInt width, CInt height) @cname("GetScreenToWorldRayEx"); // Get a ray trace from screen position (i.e mouse) in a viewport
fn Vector2 getWorldToScreen(Vector3 position, Camera camera) @cname("GetWorldToScreen");                                // Get the screen space position for a 3d world space position
fn Vector2 getWorldToScreenEx(Vector3 position, Camera camera, CInt width, CInt height) @cname("GetWorldToScreenEx");   // Get size position for a 3d world space position
fn Vector2 getWorldToScreen2D(Vector2 position, Camera2D camera) @cname("GetWorldToScreen2D");                          // Get the screen space position for a 2d camera world space position
fn Vector2 getScreenToWorld2D(Vector2 position, Camera2D camera) @cname("GetScreenToWorld2D");                          // Get the world space position for a 2d camera screen space position
fn Matrix getCameraMatrix(Camera camera) @cname("GetCameraMatrix");                                                     // Get camera transform matrix (view matrix)
fn Matrix getCameraMatrix2D(Camera2D camera) @cname("GetCameraMatrix2D");                                               // Get camera 2d transform matrix

// Timing-related functions
fn void setTargetFPS(CInt fps) @cname("SetTargetFPS"); // Set target FPS (maximum)
fn float getFrameTime() @cname("GetFrameTime");        // Get time in seconds for last frame drawn (delta time)
fn double getTime() @cname("GetTime");                 // Get elapsed time in seconds since InitWindow()
fn CInt getFPS() @cname("GetFPS");                     // Get current FPS

// Custom frame control functions
// NOTE: Those functions are intended for advanced users that want full control over the frame processing
// By default EndDrawing() does this job: draws everything + SwapScreenBuffer() + manage frame timing + PollInputEvents()
// To avoid that behaviour and control frame processes manually, enable in config.h: SUPPORT_CUSTOM_FRAME_CONTROL
fn void swapScreenBuffer() @cname("SwapScreenBuffer"); // Swap back buffer with front buffer (screen drawing)
fn void pollInputEvents() @cname("PollInputEvents");   // Register all input events
fn void waitTime(double seconds) @cname("WaitTime");   // Wait for some time (halt program execution)

// Random values generation functions
fn void setRandomSeed(CUInt seed) @cname("SetRandomSeed");                                 // Set the seed for the random number generator
fn CInt getRandomValue(CInt min, CInt max) @cname("GetRandomValue");                       // Get a random value between min and max (both included)
fn CInt *loadRandomSequence(CUInt count, CInt min, CInt max) @cname("LoadRandomSequence"); // Load random values sequence, no values repeated
fn void unloadRandomSequence(CInt *sequence) @cname("UnloadRandomSequence");               // Unload random values sequence

// Misc. functions
fn void takeScreenshot(ZString fileName) @cname("TakeScreenshot");  // Takes a screenshot of current screen (filename extension defines format)
fn void setConfigFlags(ConfigFlag flags) @cname("SetConfigFlags"); // Setup init configuration flags (view FLAGS)
fn void openURL(ZString url) @cname("OpenURL");                     // Open URL with default system browser (if available)

// NOTE: Following functions implemented in module [utils]
//------------------------------------------------------------------
fn void traceLog(TraceLogLevel logLevel, ZString text, ...) @cname("TraceLog"); // Show trace log messages (LOG_DEBUG, LOG_INFO, LOG_WARNING, LOG_ERROR...)
fn void setTraceLogLevel(TraceLogLevel logLevel) @cname("SetTraceLogLevel");    // Set the current threshold (minimum) log level
fn void *memAlloc(CUInt size) @cname("MemAlloc");                               // Internal memory allocator
fn void *memRealloc(void *ptr, CUInt size) @cname("MemRealloc");                // Internal memory reallocator
fn void memFree(void *ptr) @cname("MemFree");                                   // Internal memory free

// Set custom callbacks
// WARNING: Callbacks setup is intended for advanced users
fn void setTraceLogCallback(TraceLogCallback callback) @cname("SetTraceLogCallback");             // Set custom trace log
fn void setLoadFileDataCallback(LoadFileDataCallback callback) @cname("SetLoadFileDataCallback"); // Set custom file binary data loader
fn void setSaveFileDataCallback(SaveFileDataCallback callback) @cname("SetSaveFileDataCallback"); // Set custom file binary data saver
fn void setLoadFileTextCallback(LoadFileTextCallback callback) @cname("SetLoadFileTextCallback"); // Set custom file text data loader
fn void setSaveFileTextCallback(SaveFileTextCallback callback) @cname("SetSaveFileTextCallback"); // Set custom file text data saver

// Files management functions
fn char* loadFileData(ZString fileName, CInt *dataSize) @cname("LoadFileData");                   // Load file data as byte array (read)
fn void unloadFileData(char* data) @cname("UnloadFileData");                                      // Unload file data allocated by LoadFileData()
fn bool saveFileData(ZString fileName, void *data, CInt dataSize) @cname("SaveFileData");         // Save data to file from byte array (write), returns true on success
fn bool exportDataAsCode(char* data, CInt dataSize, ZString fileName) @cname("ExportDataAsCode"); // Export data to code (.h), returns true on success
fn ZString loadFileText(ZString fileName) @cname("LoadFileText");                                 // Load text data from file (read), returns a '\0' terminated string
fn void unloadFileText(ZString ) @cname("UnloadFileText");                                        // Unload file text data allocated by LoadFileText()
fn bool saveFileText(ZString fileName, ZString text) @cname("SaveFileText");                      // Save text data to file (write), string must be '\0' terminated, returns true on success
//------------------------------------------------------------------

// File system functions
fn bool fileExists(ZString fileName) @cname("FileExists");                                                               // Check if file exists
fn bool directoryExists(ZString dirPath) @cname("DirectoryExists");                                                      // Check if a directory path exists
fn bool isFileExtension(ZString fileName, ZString ext) @cname("IsFileExtension");                                        // Check file extension (including point: .png, .wav)
fn CInt getFileLength(ZString fileName) @cname("GetFileLength");                                                         // Get file length in bytes (NOTE: GetFileSize() conflicts with windows.h)
fn ZString getFileExtension(ZString fileName) @cname("GetFileExtension");                                                // Get pointer to extension for a filename string (includes dot: '.png')
fn ZString getFileName(ZString filePath) @cname("GetFileName");                                                          // Get pointer to filename for a path string
fn ZString getFileNameWithoutExt(ZString filePath) @cname("GetFileNameWithoutExt");                                      // Get filename string without extension (uses static string)
fn ZString getDirectoryPath(ZString filePath) @cname("GetDirectoryPath");                                                // Get full path for a given fileName with path (uses static string)
fn ZString getPrevDirectoryPath(ZString dirPath) @cname("GetPrevDirectoryPath");                                         // Get previous directory path for a given path (uses static string)
fn ZString getWorkingDirectory() @cname("GetWorkingDirectory");                                                          // Get current working directory (uses static string)
fn ZString getApplicationDirectory() @cname("GetApplicationDirectory");                                                  // Get the directory of the running application (uses static string)
fn CInt makeDirectory(ZString dirPath) @cname("MakeDirectory");                                                          // Create directories (including full path requested), returns 0 on success
fn bool changeDirectory(ZString dir) @cname("ChangeDirectory");                                                          // Change working directory, return true on success
fn bool isPathFile(ZString path) @cname("IsPathFile");                                                                   // Check if a given path is a file or a directory
fn bool isFileNameValid(ZString fileName) @cname("IsFileNameValid");                                                     // Check if fileName is valid for the platform/OS
fn FilePathList loadDirectoryFiles(ZString dirPath) @cname("LoadDirectoryFiles");                                        // Load directory filepaths
fn FilePathList loadDirectoryFilesEx(ZString basePath, ZString filter, bool scanSubdirs) @cname("LoadDirectoryFilesEx"); // Load directory filepaths with extension filtering and recursive directory scan. Use 'DIR' in the filter string to include directories in the result
fn void unloadDirectoryFiles(FilePathList files) @cname("UnloadDirectoryFiles");                                         // Unload filepaths
fn bool isFileDropped() @cname("IsFileDropped");                                                                         // Check if a file has been dropped into window
fn FilePathList loadDroppedFiles() @cname("LoadDroppedFiles");                                                           // Load dropped filepaths
fn void unloadDroppedFiles(FilePathList files) @cname("UnloadDroppedFiles");                                             // Unload dropped filepaths
fn long getFileModTime(ZString fileName) @cname("GetFileModTime");                                                       // Get file modification time (last write time)

// Compression/Encoding functionality
fn char* compressData(char* data, CInt dataSize, CInt *compDataSize) @cname("CompressData");         // Compress data (DEFLATE algorithm), memory must be MemFree()
fn char* decompressData(char* compData, CInt compDataSize, CInt *dataSize) @cname("DecompressData"); // Decompress data (DEFLATE algorithm), memory must be MemFree()
fn char* encodeDataBase64(char* data, CInt dataSize, CInt *outputSize) @cname("EncodeDataBase64");   // Encode data to Base64 string, memory must be MemFree()
fn char* decodeDataBase64(char* data, CInt *outputSize) @cname("DecodeDataBase64");                  // Decode Base64 string data, memory must be MemFree()
fn CUInt computeCRC32(char *data, CInt dataSize) @cname("ComputeCRC32");                             // Compute CRC32 hash code
fn CUInt[4]* computeMD5(char *data, CInt dataSize) @cname("ComputeMD5");                             // Compute MD5 hash code, returns static CUInt[4] (16 bytes)
fn CUInt[5]* computeSHA1(char *data, CInt dataSize) @cname("ComputeSHA1");                           // Compute SHA1 hash code, returns static CUInt[5] (20 bytes)


// Automation events functionality
fn AutomationEventList loadAutomationEventList(ZString fileName) @cname("LoadAutomationEventList");                // Load automation events list from file, NULL for empty list, capacity = MAX_AUTOMATION_EVENTS
fn void unloadAutomationEventList(AutomationEventList list) @cname("UnloadAutomationEventList");                   // Unload automation events list from file
fn bool exportAutomationEventList(AutomationEventList list, ZString fileName) @cname("ExportAutomationEventList"); // Export automation events list as text file
fn void setAutomationEventList(AutomationEventList *list) @cname("SetAutomationEventList");                        // Set automation event list to record to
fn void setAutomationEventBaseFrame(CInt frame) @cname("SetAutomationEventBaseFrame");                             // Set automation event internal base frame to start recording
fn void startAutomationEventRecording() @cname("StartAutomationEventRecording");                                   // Start recording automation events (AutomationEventList must be set)
fn void stopAutomationEventRecording() @cname("StopAutomationEventRecording");                                     // Stop recording automation events
fn void playAutomationEvent(AutomationEvent event) @cname("PlayAutomationEvent");                                  // Play a recorded automation event

//------------------------------------------------------------------------------------
// Input Handling Functions (Module: core)
//------------------------------------------------------------------------------------

// Input-related functions: keyboard
fn bool isKeyPressed(KeyboardKey key) @cname("IsKeyPressed");             // Check if a key has been pressed once
fn bool isKeyPressedRepeat(KeyboardKey key) @cname("IsKeyPressedRepeat"); // Check if a key has been pressed again
fn bool isKeyDown(KeyboardKey key) @cname("IsKeyDown");                   // Check if a key is being pressed
fn bool isKeyReleased(KeyboardKey key) @cname("IsKeyReleased");           // Check if a key has been released once
fn bool isKeyUp(KeyboardKey key) @cname("IsKeyUp");                       // Check if a key is NOT being pressed
fn KeyboardKey getKeyPressed() @cname("GetKeyPressed");                   // Get key pressed (keycode), call it multiple times for keys queued, returns 0 when the queue is empty
fn CInt getCharPressed() @cname("GetCharPressed");                        // Get char pressed (unicode), call it multiple times for chars queued, returns 0 when the queue is empty
fn void setExitKey(KeyboardKey key) @cname("SetExitKey");                 // Set a custom key to exit program (default is ESC)

// Input-related functions: gamepads
fn bool isGamepadAvailable(CInt gamepad) @cname("IsGamepadAvailable");                                                      // Check if a gamepad is available
fn ZString getGamepadName(CInt gamepad) @cname("GetGamepadName");                                                           // Get gamepad internal name id
fn bool isGamepadButtonPressed(CInt gamepad, GamepadButton button) @cname("IsGamepadButtonPressed");                        // Check if a gamepad button has been pressed once
fn bool isGamepadButtonDown(CInt gamepad, GamepadButton button) @cname("IsGamepadButtonDown");                              // Check if a gamepad button is being pressed
fn bool isGamepadButtonReleased(CInt gamepad, GamepadButton button) @cname("IsGamepadButtonReleased");                      // Check if a gamepad button has been released once
fn bool isGamepadButtonUp(CInt gamepad, GamepadButton button) @cname("IsGamepadButtonUp");                                  // Check if a gamepad button is NOT being pressed
fn GamepadButton getGamepadButtonPressed() @cname("GetGamepadButtonPressed");                                               // Get the last gamepad button pressed
fn CInt getGamepadAxisCount(CInt gamepad) @cname("GetGamepadAxisCount");                                                    // Get gamepad axis count for a gamepad
fn float getGamepadAxisMovement(CInt gamepad, GamepadAxis axis) @cname("GetGamepadAxisMovement");                           // Get axis movement value for a gamepad axis
fn CInt setGamepadMappings(ZString mappings) @cname("SetGamepadMappings");                                                  // Set internal gamepad mappings (SDL_GameControllerDB)
fn void setGamepadVibration(CInt gamepad, float leftMotor, float rightMotor, float duration) @cname("SetGamepadVibration"); // Set gamepad vibration for both motors (duration in seconds)

// Input-related functions: mouse
fn bool isMouseButtonPressed(MouseButton button) @cname("IsMouseButtonPressed");   // Check if a mouse button has been pressed once
fn bool isMouseButtonDown(MouseButton button) @cname("IsMouseButtonDown");         // Check if a mouse button is being pressed
fn bool isMouseButtonReleased(MouseButton button) @cname("IsMouseButtonReleased"); // Check if a mouse button has been released once
fn bool isMouseButtonUp(MouseButton button) @cname("IsMouseButtonUp");             // Check if a mouse button is NOT being pressed
fn CInt getMouseX() @cname("GetMouseX");                                           // Get mouse position X
fn CInt getMouseY() @cname("GetMouseY");                                           // Get mouse position Y
fn Vector2 getMousePosition() @cname("GetMousePosition");                          // Get mouse position XY
fn Vector2 getMouseDelta() @cname("GetMouseDelta");                                // Get mouse delta between frames
fn void setMousePosition(CInt x, CInt y) @cname("SetMousePosition");               // Set mouse position XY
fn void setMouseOffset(CInt offsetX, CInt offsetY) @cname("SetMouseOffset");       // Set mouse offset
fn void setMouseScale(float scaleX, float scaleY) @cname("SetMouseScale");         // Set mouse scaling
fn float getMouseWheelMove() @cname("GetMouseWheelMove");                          // Get mouse wheel movement for X or Y, whichever is larger
fn Vector2 getMouseWheelMoveV() @cname("GetMouseWheelMoveV");                      // Get mouse wheel movement for both X and Y
fn void setMouseCursor(MouseCursor cursor) @cname("SetMouseCursor");               // Set mouse cursor

// Input-related functions: touch
fn CInt getTouchX() @cname("GetTouchX");                            // Get touch position X for touch point 0 (relative to screen size)
fn CInt getTouchY() @cname("GetTouchY");                            // Get touch position Y for touch point 0 (relative to screen size)
fn Vector2 getTouchPosition(CInt index) @cname("GetTouchPosition"); // Get touch position XY for a touch point index (relative to screen size)
fn CInt getTouchPointId(CInt index) @cname("GetTouchPointId");      // Get touch point identifier for given index
fn CInt getTouchPointCount() @cname("GetTouchPointCount");          // Get number of touch points

//------------------------------------------------------------------------------------
// Gestures and Touch Handling Functions (Module: rgestures)
//------------------------------------------------------------------------------------
fn void setGesturesEnabled(Gesture flags) @cname("SetGesturesEnabled"); // Enable a set of gestures using flags
fn bool isGestureDetected(Gesture gesture) @cname("IsGestureDetected"); // Check if a gesture have been detected
fn Gesture getGestureDetected() @cname("GetGestureDetected");           // Get latest detected gesture
fn float getGestureHoldDuration() @cname("GetGestureHoldDuration");     // Get gesture hold time in seconds
fn Vector2 getGestureDragVector() @cname("GetGestureDragVector");       // Get gesture drag vector
fn float getGestureDragAngle() @cname("GetGestureDragAngle");           // Get gesture drag angle
fn Vector2 getGesturePinchVector() @cname("GetGesturePinchVector");     // Get gesture pinch delta
fn float getGesturePinchAngle() @cname("GetGesturePinchAngle");         // Get gesture pinch angle

//------------------------------------------------------------------------------------
// Camera System Functions (Module: rcamera)
//------------------------------------------------------------------------------------
fn void updateCamera(Camera *camera, CameraMode mode) @cname("UpdateCamera");                                      // Update camera position for selected mode
fn void updateCameraPro(Camera *camera, Vector3 movement, Vector3 rotation, float zoom) @cname("UpdateCameraPro"); // Update camera movement/rotation

//------------------------------------------------------------------------------------
// Basic Shapes Drawing Functions (Module: shapes)
//------------------------------------------------------------------------------------
// Set texture and rectangle to be used on shapes drawing
// NOTE: It can be useful when using basic shapes and one single font,
// defining a font char white rectangle would allow drawing everything in a single draw call
fn void setShapesTexture(Texture2D texture, Rectangle source) @cname("SetShapesTexture"); // Set texture and rectangle to be used on shapes drawing
fn Texture2D getShapesTexture() @cname("GetShapesTexture");                               // Get texture that is used for shapes drawing
fn Rectangle getShapesTextureRectangle() @cname("GetShapesTextureRectangle");             // Get texture source rectangle that is used for shapes drawing

// Basic shapes drawing functions
fn void drawPixel(CInt posX, CInt posY, Color color) @cname("DrawPixel");                                                                                          // Draw a pixel using geometry [Can be slow, use with care]
fn void drawPixelV(Vector2 position, Color color) @cname("DrawPixelV");                                                                                            // Draw a pixel using geometry (Vector version) [Can be slow, use with care]
fn void drawLine(CInt startPosX, CInt startPosY, CInt endPosX, CInt endPosY, Color color) @cname("DrawLine");                                                      // Draw a line
fn void drawLineV(Vector2 startPos, Vector2 endPos, Color color) @cname("DrawLineV");                                                                              // Draw a line (using gl lines)
fn void drawLineEx(Vector2 startPos, Vector2 endPos, float thick, Color color) @cname("DrawLineEx");                                                               // Draw a line (using triangles/quads)
fn void drawLineStrip(Vector2 *points, CInt pointCount, Color color) @cname("DrawLineStrip");                                                                      // Draw lines sequence (using gl lines)
fn void drawLineBezier(Vector2 startPos, Vector2 endPos, float thick, Color color) @cname("DrawLineBezier");                                                       // Draw line segment cubic-bezier in-out interpolation
fn void drawCircle(CInt centerX, CInt centerY, float radius, Color color) @cname("DrawCircle");                                                                    // Draw a color-filled circle
fn void drawCircleSector(Vector2 center, float radius, float startAngle, float endAngle, CInt segments, Color color) @cname("DrawCircleSector");                   // Draw a piece of a circle
fn void drawCircleSectorLines(Vector2 center, float radius, float startAngle, float endAngle, CInt segments, Color color) @cname("DrawCircleSectorLines");         // Draw circle sector outline
fn void drawCircleGradient(CInt centerX, CInt centerY, float radius, Color inner, Color outer) @cname("DrawCircleGradient");                                       // Draw a gradient-filled circle
fn void drawCircleV(Vector2 center, float radius, Color color) @cname("DrawCircleV");                                                                              // Draw a color-filled circle (Vector version)
fn void drawCircleLines(CInt centerX, CInt centerY, float radius, Color color) @cname("DrawCircleLines");                                                          // Draw circle outline
fn void drawCircleLinesV(Vector2 center, float radius, Color color) @cname("DrawCircleLinesV");                                                                    // Draw circle outline (Vector version)
fn void drawEllipse(CInt centerX, CInt centerY, float radiusH, float radiusV, Color color) @cname("DrawEllipse");                                                  // Draw ellipse
fn void drawEllipseLines(CInt centerX, CInt centerY, float radiusH, float radiusV, Color color) @cname("DrawEllipseLines");                                        // Draw ellipse outline
fn void drawRing(Vector2 center, float innerRadius, float outerRadius, float startAngle, float endAngle, CInt segments, Color color) @cname("DrawRing");           // Draw ring
fn void drawRingLines(Vector2 center, float innerRadius, float outerRadius, float startAngle, float endAngle, CInt segments, Color color) @cname("DrawRingLines"); // Draw ring outline
fn void drawRectangle(CInt posX, CInt posY, CInt width, CInt height, Color color) @cname("DrawRectangle");                                                         // Draw a color-filled rectangle
fn void drawRectangleV(Vector2 position, Vector2 size, Color color) @cname("DrawRectangleV");                                                                      // Draw a color-filled rectangle (Vector version)
fn void drawRectangleRec(Rectangle rec, Color color) @cname("DrawRectangleRec");                                                                                   // Draw a color-filled rectangle
fn void drawRectanglePro(Rectangle rec, Vector2 origin, float rotation, Color color) @cname("DrawRectanglePro");                                                   // Draw a color-filled rectangle with pro parameters
fn void drawRectangleGradientV(CInt posX, CInt posY, CInt width, CInt height, Color top, Color bottom) @cname("DrawRectangleGradientV");                           // Draw a vertical-gradient-filled rectangle
fn void drawRectangleGradientH(CInt posX, CInt posY, CInt width, CInt height, Color left, Color right) @cname("DrawRectangleGradientH");                           // Draw a horizontal-gradient-filled rectangle
fn void drawRectangleGradientEx(Rectangle rec, Color topLeft, Color bottomLeft, Color topRight, Color bottomRight) @cname("DrawRectangleGradientEx");              // Draw a gradient-filled rectangle with custom vertex colors
fn void drawRectangleLines(CInt posX, CInt posY, CInt width, CInt height, Color color) @cname("DrawRectangleLines");                                               // Draw rectangle outline
fn void drawRectangleLinesEx(Rectangle rec, float lineThick, Color color) @cname("DrawRectangleLinesEx");                                                          // Draw rectangle outline with extended parameters
fn void drawRectangleRounded(Rectangle rec, float roundness, CInt segments, Color color) @cname("DrawRectangleRounded");                                           // Draw rectangle with rounded edges
fn void drawRectangleRoundedLines(Rectangle rec, float roundness, CInt segments, Color color) @cname("DrawRectangleRoundedLines");                                 // Draw rectangle lines with rounded edges
fn void drawRectangleRoundedLinesEx(Rectangle rec, float roundness, CInt segments, float lineThick, Color color) @cname("DrawRectangleRoundedLinesEx");            // Draw rectangle with rounded edges outline
fn void drawTriangle(Vector2 v1, Vector2 v2, Vector2 v3, Color color) @cname("DrawTriangle");                                                                      // Draw a color-filled triangle (vertex in counter-clockwise order!)
fn void drawTriangleLines(Vector2 v1, Vector2 v2, Vector2 v3, Color color) @cname("DrawTriangleLines");                                                            // Draw triangle outline (vertex in counter-clockwise order!)
fn void drawTriangleFan(Vector2 *points, int pointCount, Color color) @cname("DrawTriangleFan");                                                                   // Draw a triangle fan defined by points (first vertex is the center)
fn void drawTriangleStrip(Vector2 *points, int pointCount, Color color) @cname("DrawTriangleStrip");                                                               // Draw a triangle strip defined by points
fn void drawPoly(Vector2 center, CInt sides, float radius, float rotation, Color color) @cname("DrawPoly");                                                        // Draw a regular polygon (Vector version)
fn void drawPolyLines(Vector2 center, CInt sides, float radius, float rotation, Color color) @cname("DrawPolyLines");                                              // Draw a polygon outline of n sides
fn void drawPolyLinesEx(Vector2 center, CInt sides, float radius, float rotation, float lineThick, Color color) @cname("DrawPolyLinesEx");                         // Draw a polygon outline of n sides with extended parameters

// Splines drawing functions
fn void drawSplineLinear(Vector2 *points, CInt pointCount, float thick, Color color) @cname("DrawSplineLinear");                                       // Draw spline: Linear, minimum 2 points
fn void drawSplineBasis(Vector2 *points, CInt pointCount, float thick, Color color) @cname("DrawSplineBasis");                                         // Draw spline: B-Spline, minimum 4 points
fn void drawSplineCatmullRom(Vector2 *points, CInt pointCount, float thick, Color color) @cname("DrawSplineCatmullRom");                               // Draw spline: Catmull-Rom, minimum 4 points
fn void drawSplineBezierQuadratic(Vector2 *points, CInt pointCount, float thick, Color color) @cname("DrawSplineBezierQuadratic");                     // Draw spline: Quadratic Bezier, minimum 3 points (1 control point): [p1, c2, p3, c4...]
fn void drawSplineBezierCubic(Vector2 *points, CInt pointCount, float thick, Color color) @cname("DrawSplineBezierCubic");                             // Draw spline: Cubic Bezier, minimum 4 points (2 control points): [p1, c2, c3, p4, c5, c6...]
fn void drawSplineSegmentLinear(Vector2 p1, Vector2 p2, float thick, Color color) @cname("DrawSplineSegmentLinear");                                   // Draw spline segment: Linear, 2 points
fn void drawSplineSegmentBasis(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, float thick, Color color) @cname("DrawSplineSegmentBasis");             // Draw spline segment: B-Spline, 4 points
fn void drawSplineSegmentCatmullRom(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, float thick, Color color) @cname("DrawSplineSegmentCatmullRom");   // Draw spline segment: Catmull-Rom, 4 points
fn void drawSplineSegmentBezierQuadratic(Vector2 p1, Vector2 c2, Vector2 p3, float thick, Color color) @cname("DrawSplineSegmentBezierQuadratic");     // Draw spline segment: Quadratic Bezier, 2 points, 1 control point
fn void drawSplineSegmentBezierCubic(Vector2 p1, Vector2 c2, Vector2 c3, Vector2 p4, float thick, Color color) @cname("DrawSplineSegmentBezierCubic"); // Draw spline segment: Cubic Bezier, 2 points, 2 control points

// Spline segment point evaluation functions, for a given t [0.0f .. 1.0f]
fn Vector2 getSplinePointLinear(Vector2 startPos, Vector2 endPos, float t) @cname("GetSplinePointLinear");                         // Get (evaluate) spline point: Linear
fn Vector2 getSplinePointBasis(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, float t) @cname("GetSplinePointBasis");             // Get (evaluate) spline point: B-Spline
fn Vector2 getSplinePointCatmullRom(Vector2 p1, Vector2 p2, Vector2 p3, Vector2 p4, float t) @cname("GetSplinePointCatmullRom");   // Get (evaluate) spline point: Catmull-Rom
fn Vector2 getSplinePointBezierQuad(Vector2 p1, Vector2 c2, Vector2 p3, float t) @cname("GetSplinePointBezierQuad");               // Get (evaluate) spline point: Quadratic Bezier
fn Vector2 getSplinePointBezierCubic(Vector2 p1, Vector2 c2, Vector2 c3, Vector2 p4, float t) @cname("GetSplinePointBezierCubic"); // Get (evaluate) spline point: Cubic Bezier

// Basic shapes collision detection functions
fn bool checkCollisionRecs(Rectangle rec1, Rectangle rec2) @cname("CheckCollisionRecs");                                                                    // Check collision between two rectangles
fn bool checkCollisionCircles(Vector2 center1, float radius1, Vector2 center2, float radius2) @cname("CheckCollisionCircles");                              // Check collision between two circles
fn bool checkCollisionCircleRec(Vector2 center, float radius, Rectangle rec) @cname("CheckCollisionCircleRec");                                             // Check collision between circle and rectangle
fn bool checkCollisionCircleLine(Vector2 center, float radius, Vector2 p1, Vector2 p2) @cname("CheckCollisionCircleLine");                                  // Check if circle collides with a line created betweeen two points [p1] and [p2]
fn bool checkCollisionPointRec(Vector2 point, Rectangle rec) @cname("CheckCollisionPointRec");                                                              // Check if point is inside rectangle
fn bool checkCollisionPointCircle(Vector2 point, Vector2 center, float radius) @cname("CheckCollisionPointCircle");                                         // Check if point is inside circle
fn bool checkCollisionPointTriangle(Vector2 point, Vector2 p1, Vector2 p2, Vector2 p3) @cname("CheckCollisionPointTriangle");                               // Check if point is inside a triangle
fn bool checkCollisionPointLine(Vector2 point, Vector2 p1, Vector2 p2, CInt threshold) @cname("CheckCollisionPointLine");                                   // Check if point belongs to line created between two points [p1] and [p2] with defined margin in pixels [threshold]
fn bool checkCollisionPointPoly(Vector2 point, Vector2 *points, CInt pointCount) @cname("CheckCollisionPointPoly");                                         // Check if point is within a polygon described by array of vertices
fn bool checkCollisionLines(Vector2 startPos1, Vector2 endPos1, Vector2 startPos2, Vector2 endPos2, Vector2 *collisionPoint) @cname("CheckCollisionLines"); // Check the collision between two lines defined by two points each, returns collision point by reference
fn Rectangle getCollisionRec(Rectangle rec1, Rectangle rec2) @cname("GetCollisionRec");                                                                     // Get collision rectangle for two rectangles collision

//------------------------------------------------------------------------------------
// Texture Loading and Drawing Functions (Module: textures)
//------------------------------------------------------------------------------------

// Image loading functions
// NOTE: These functions do not require GPU access
fn Image loadImage(ZString fileName) @cname("LoadImage");                                                                          // Load image from file into CPU memory (RAM)
fn Image loadImageRaw(ZString fileName, CInt width, CInt height, CInt format, CInt headerSize) @cname("LoadImageRaw");             // Load image from RAW file data
fn Image loadImageAnim(ZString fileName, CInt *frames) @cname("LoadImageAnim");                                                    // Load image sequence from file (frames appended to image.data)
fn Image loadImageAnimFromMemory(ZString fileType, char* fileData, CInt dataSize, CInt *frames) @cname("LoadImageAnimFromMemory"); // Load image sequence from memory buffer
fn Image loadImageFromMemory(ZString fileType, char* fileData, CInt dataSize) @cname("LoadImageFromMemory");                       // Load image from memory buffer, fileType refers to extension: i.e. '.png'
fn Image loadImageFromTexture(Texture2D texture) @cname("LoadImageFromTexture");                                                   // Load image from GPU texture data
fn Image loadImageFromScreen() @cname("LoadImageFromScreen");                                                                      // Load image from screen buffer and (screenshot)
fn bool isImageValid(Image image) @cname("IsImageValid");                                                                          // Check if an image is valid (data and parameters)
fn void unloadImage(Image image) @cname("UnloadImage");                                                                            // Unload image from CPU memory (RAM)
fn bool exportImage(Image image, ZString fileName) @cname("ExportImage");                                                          // Export image data to file, returns true on success
fn char* exportImageToMemory(Image image, ZString fileType, CInt *fileSize) @cname("ExportImageToMemory");                         // Export image to memory buffer
fn bool exportImageAsCode(Image image, ZString fileName) @cname("ExportImageAsCode");                                              // Export image as code file defining an array of bytes, returns true on success

// Image generation functions
fn Image genImageColor(CInt width, CInt height, Color color) @cname("GenImageColor");                                               // Generate image: plain color
fn Image genImageGradientLinear(CInt width, CInt height, CInt direction, Color start, Color end) @cname("GenImageGradientLinear");  // Generate image: linear gradient, direction in degrees [0..360], 0=Vertical gradient
fn Image genImageGradientRadial(CInt width, CInt height, float density, Color inner, Color outer) @cname("GenImageGradientRadial"); // Generate image: radial gradient
fn Image genImageGradientSquare(CInt width, CInt height, float density, Color inner, Color outer) @cname("GenImageGradientSquare"); // Generate image: square gradient
fn Image genImageChecked(CInt width, CInt height, CInt checksX, CInt checksY, Color col1, Color col2) @cname("GenImageChecked");    // Generate image: checked
fn Image genImageWhiteNoise(CInt width, CInt height, float factor) @cname("GenImageWhiteNoise");                                    // Generate image: white noise
fn Image genImagePerlinNoise(CInt width, CInt height, CInt offsetX, CInt offsetY, float scale) @cname("GenImagePerlinNoise");       // Generate image: perlin noise
fn Image genImageCellular(CInt width, CInt height, CInt tileSize) @cname("GenImageCellular");                                       // Generate image: cellular algorithm, bigger tileSize means bigger cells
fn Image genImageText(CInt width, CInt height, ZString text) @cname("GenImageText");                                                // Generate image: grayscale image from text data

// Image manipulation functions
fn Image imageCopy(Image image) @cname("ImageCopy");                                                                                        // Create an image duplicate (useful for transformations)
fn Image imageFromImage(Image image, Rectangle rec) @cname("ImageFromImage");                                                               // Create an image from another image piece
fn Image imageFromChannel(Image image, CInt selectedChannel) @cname("ImageFromChannel");                                                    // Create an image from a selected channel of another image (GRAYSCALE)
fn Image imageText(ZString text, CInt fontSize, Color color) @cname("ImageText");                                                           // Create an image from text (default font)
fn Image imageTextEx(Font font, ZString text, float fontSize, float spacing, Color tint) @cname("ImageTextEx");                             // Create an image from text (custom sprite font)
fn void imageFormat(Image *image, PixelFormat newFormat) @cname("ImageFormat");                                                             // Convert image data to desired format
fn void imageToPOT(Image *image, Color fill) @cname("ImageToPOT");                                                                          // Convert image to POT (power-of-two)
fn void imageCrop(Image *image, Rectangle crop) @cname("ImageCrop");                                                                        // Crop an image to a defined rectangle
fn void imageAlphaCrop(Image *image, float threshold) @cname("ImageAlphaCrop");                                                             // Crop image depending on alpha value
fn void imageAlphaClear(Image *image, Color color, float threshold) @cname("ImageAlphaClear");                                              // Clear alpha channel to desired color
fn void imageAlphaMask(Image *image, Image alphaMask) @cname("ImageAlphaMask");                                                             // Apply alpha mask to image
fn void imageAlphaPremultiply(Image *image) @cname("ImageAlphaPremultiply");                                                                // Premultiply alpha channel
fn void imageBlurGaussian(Image *image, CInt blurSize) @cname("ImageBlurGaussian");                                                         // Apply Gaussian blur using a box blur approximation
fn void imageKernelConvolution(Image *image, float *kernel, CInt kernelSize) @cname("ImageKernelConvolution");                              // Apply custom square convolution kernel to image
fn void imageResize(Image *image, CInt newWidth, CInt newHeight) @cname("ImageResize");                                                     // Resize image (Bicubic scaling algorithm)
fn void imageResizeNN(Image *image, CInt newWidth,CInt newHeight) @cname("ImageResizeNN");                                                  // Resize image (Nearest-Neighbor scaling algorithm)
fn void imageResizeCanvas(Image *image, CInt newWidth, CInt newHeight, CInt offsetX, CInt offsetY, Color fill) @cname("ImageResizeCanvas"); // Resize canvas and fill with color
fn void imageMipmaps(Image *image) @cname("ImageMipmaps");                                                                                  // Compute all mipmap levels for a provided image
fn void imageDither(Image *image, CInt rBpp, CInt gBpp, CInt bBpp, CInt aBpp) @cname("ImageDither");                                        // Dither image data to 16bpp or lower (Floyd-Steinberg dithering)
fn void imageFlipVertical(Image *image) @cname("ImageFlipVertical");                                                                        // Flip image vertically
fn void imageFlipHorizontal(Image *image) @cname("ImageFlipHorizontal");                                                                    // Flip image horizontally
fn void imageRotate(Image *image, CInt degrees) @cname("ImageRotate");                                                                      // Rotate image by input angle in degrees (-359 to 359)
fn void imageRotateCW(Image *image) @cname("ImageRotateCW");                                                                                // Rotate image clockwise 90deg
fn void imageRotateCCW(Image *image) @cname("ImageRotateCCW");                                                                              // Rotate image counter-clockwise 90deg
fn void imageColorTint(Image *image, Color color) @cname("ImageColorTint");                                                                 // Modify image color: tint
fn void imageColorInvert(Image *image) @cname("ImageColorInvert");                                                                          // Modify image color: invert
fn void imageColorGrayscale(Image *image) @cname("ImageColorGrayscale");                                                                    // Modify image color: grayscale
fn void imageColorContrast(Image *image, float contrast) @cname("ImageColorContrast");                                                      // Modify image color: contrast (-100 to 100)
fn void imageColorBrightness(Image *image, CInt brightness) @cname("ImageColorBrightness");                                                 // Modify image color: brightness (-255 to 255)
fn void imageColorReplace(Image *image, Color color, Color replace) @cname("ImageColorReplace");                                            // Modify image color: replace color
fn Color *loadImageColors(Image image) @cname("LoadImageColors");                                                                           // Load color data from image as a Color array (RGBA - 32bit)
fn Color *loadImagePalette(Image image, CInt maxPaletteSize, CInt *colorCount) @cname("LoadImagePalette");                                  // Load colors palette from image as a Color array (RGBA - 32bit)
fn void unloadImageColors(Color *colors) @cname("UnloadImageColors");                                                                       // Unload color data loaded with LoadImageColors()
fn void unloadImagePalette(Color *colors) @cname("UnloadImagePalette");                                                                     // Unload colors palette loaded with LoadImagePalette()
fn Rectangle getImageAlphaBorder(Image image, float threshold) @cname("GetImageAlphaBorder");                                               // Get image alpha border rectangle
fn Color getImageColor(Image image, CInt x, CInt y) @cname("GetImageColor");                                                                // Get image pixel color at (x, y) position

// Image drawing functions
// NOTE: Image software-rendering functions (CPU)
fn void imageClearBackground(Image *dst, Color color) @cname("ImageClearBackground");                                                                // Clear image background with given color
fn void imageDrawPixel(Image *dst, CInt posX, CInt posY, Color color) @cname("ImageDrawPixel");                                                      // Draw pixel within an image
fn void imageDrawPixelV(Image *dst, Vector2 position, Color color) @cname("ImageDrawPixelV");                                                        // Draw pixel within an image (Vector version)
fn void imageDrawLine(Image *dst, CInt startPosX, CInt startPosY, CInt endPosX, CInt endPosY, Color color) @cname("ImageDrawLine");                  // Draw line within an image
fn void imageDrawLineV(Image *dst, Vector2 start, Vector2 end, Color color) @cname("ImageDrawLineV");                                                // Draw line within an image (Vector version)
fn void imageDrawLineEx(Image *dst, Vector2 start, Vector2 end, CInt thick, Color color) @cname("ImageDrawLineEx");                                  // Draw a line defining thickness within an image
fn void imageDrawCircle(Image *dst, CInt centerX, CInt centerY, CInt radius, Color color) @cname("ImageDrawCircle");                                 // Draw a filled circle within an image
fn void imageDrawCircleV(Image *dst, Vector2 center, CInt radius, Color color) @cname("ImageDrawCircleV");                                           // Draw a filled circle within an image (Vector version)
fn void imageDrawCircleLines(Image *dst, CInt centerX, CInt centerY, CInt radius, Color color) @cname("ImageDrawCircleLines");                       // Draw circle outline within an image
fn void imageDrawCircleLinesV(Image *dst, Vector2 center, CInt radius, Color color) @cname("ImageDrawCircleLinesV");                                 // Draw circle outline within an image (Vector version)
fn void imageDrawRectangle(Image *dst, CInt posX, CInt posY, CInt width, CInt height, Color color) @cname("ImageDrawRectangle");                     // Draw rectangle within an image
fn void imageDrawRectangleV(Image *dst, Vector2 position, Vector2 size, Color color) @cname("ImageDrawRectangleV");                                  // Draw rectangle within an image (Vector version)
fn void imageDrawRectangleRec(Image *dst, Rectangle rec, Color color) @cname("ImageDrawRectangleRec");                                               // Draw rectangle within an image
fn void imageDrawRectangleLines(Image *dst, Rectangle rec, CInt thick, Color color) @cname("ImageDrawRectangleLines");                               // Draw rectangle lines within an image
fn void imageDrawTriangle(Image *dst, Vector2 v1, Vector2 v2, Vector2 v3, Color color) @cname("ImageDrawTriangle");                                  // Draw triangle within an image
fn void imageDrawTriangleEx(Image *dst, Vector2 v1, Vector2 v2, Vector2 v3, Color c1, Color c2, Color c3) @cname("ImageDrawTriangleEx");             // Draw triangle with interpolated colors within an image
fn void imageDrawTriangleLines(Image *dst, Vector2 v1, Vector2 v2, Vector2 v3, Color color) @cname("ImageDrawTriangleLines");                        // Draw triangle outline within an image
fn void imageDrawTriangleFan(Image *dst, Vector2 *points, CInt pointCount, Color color) @cname("ImageDrawTriangleFan");                              // Draw a triangle fan defined by points within an image (first vertex is the center)
fn void imageDrawTriangleStrip(Image *dst, Vector2 *points, CInt pointCount, Color color) @cname("ImageDrawTriangleStrip");                          // Draw a triangle strip defined by points within an image
fn void imageDraw(Image *dst, Image src, Rectangle srcRec, Rectangle dstRec, Color tint) @cname("ImageDraw");                                        // Draw a source image within a destination image (tint applied to source)
fn void imageDrawText(Image *dst, ZString text, CInt posX, CInt posY, CInt fontSize, Color color) @cname("ImageDrawText");                           // Draw text (using default font) within an image (destination)
fn void imageDrawTextEx(Image *dst, Font font, ZString text, Vector2 position, float fontSize, float spacing, Color tint) @cname("ImageDrawTextEx"); // Draw text (custom sprite font) within an image (destination)

// Texture loading functions
// NOTE: These functions require GPU access
fn Texture2D loadTexture(ZString fileName) @cname("LoadTexture");                                     // Load texture from file into GPU memory (VRAM)
fn Texture2D loadTextureFromImage(Image image) @cname("LoadTextureFromImage");                        // Load texture from image data
fn TextureCubemap loadTextureCubemap(Image image, CubemapLayout layout) @cname("LoadTextureCubemap"); // Load cubemap from image, multiple image cubemap layouts supported
fn RenderTexture2D loadRenderTexture(CInt width, CInt height) @cname("LoadRenderTexture");            // Load texture for rendering (framebuffer)
fn bool isTextureValid(Texture2D texture) @cname("IsTextureValid");                                   // Check if a texture is valid (loaded in GPU)
fn void unloadTexture(Texture2D texture) @cname("UnloadTexture");                                     // Unload texture from GPU memory (VRAM)
fn bool isRenderTextureValid(RenderTexture2D target) @cname("IsRenderTextureValid");                  // Check if a render texture is valid (loaded in GPU)
fn void unloadRenderTexture(RenderTexture2D target) @cname("UnloadRenderTexture");                    // Unload render texture from GPU memory (VRAM)
fn void updateTexture(Texture2D texture, void *pixels) @cname("UpdateTexture");                       // Update GPU texture with new data
fn void updateTextureRec(Texture2D texture, Rectangle rec, void *pixels) @cname("UpdateTextureRec");  // Update GPU texture rectangle with new data

// Texture configuration functions
fn void genTextureMipmaps(Texture2D *texture) @cname("GenTextureMipmaps");                    // Generate GPU mipmaps for a texture
fn void setTextureFilter(Texture2D texture, TextureFilter filter) @cname("SetTextureFilter"); // Set texture scaling filter mode
fn void setTextureWrap(Texture2D texture, TextureWrap wrap) @cname("SetTextureWrap");         // Set texture wrapping mode

// Texture drawing functions
fn void drawTexture(Texture2D texture, CInt posX, CInt posY, Color tint) @cname("DrawTexture");                                                              // Draw a Texture2D
fn void drawTextureV(Texture2D texture, Vector2 position, Color tint) @cname("DrawTextureV");                                                                // Draw a Texture2D with position defined as Vector2
fn void drawTextureEx(Texture2D texture, Vector2 position, float rotation, float scale, Color tint) @cname("DrawTextureEx");                                 // Draw a Texture2D with extended parameters
fn void drawTextureRec(Texture2D texture, Rectangle source, Vector2 position, Color tint) @cname("DrawTextureRec");                                          // Draw a part of a texture defined by a rectangle
fn void drawTexturePro(Texture2D texture, Rectangle source, Rectangle dest, Vector2 origin, float rotation, Color tint) @cname("DrawTexturePro");            // Draw a part of a texture defined by a rectangle with 'pro' parameters
fn void drawTextureNPatch(Texture2D texture, NPatchInfo nPatchInfo, Rectangle dest, Vector2 origin, float rotation, Color tint) @cname("DrawTextureNPatch"); // Draws a texture (or part of it) that stretches or shrinks nicely

// Color/pixel related functions
fn bool colorIsEqual(Color col1, Color col2) @cname("ColorIsEqual");                              // Check if two colors are equal
fn Color fade(Color color, float alpha) @cname("Fade");                                           // Get color with alpha applied, alpha goes from 0.0f to 1.0f
fn CInt colorToInt(Color color) @cname("ColorToInt");                                             // Get hexadecimal value for a Color (0xRRGGBBAA)
fn Vector4 colorNormalize(Color color) @cname("ColorNormalize");                                  // Get Color normalized as float [0..1]
fn Color colorFromNormalized(Vector4 normalized) @cname("ColorFromNormalized");                   // Get Color from normalized values [0..1]
fn Vector3 colorToHSV(Color color) @cname("ColorToHSV");                                          // Get HSV values for a Color, hue [0..360], saturation/value [0..1]
fn Color colorFromHSV(float hue, float saturation, float value) @cname("ColorFromHSV");           // Get a Color from HSV values, hue [0..360], saturation/value [0..1]
fn Color colorTint(Color color, Color tint) @cname("ColorTint");                                  // Get color multiplied with another color
fn Color colorBrightness(Color color, float factor) @cname("ColorBrightness");                    // Get color with brightness correction, brightness factor goes from -1.0f to 1.0f
fn Color colorContrast(Color color, float contrast) @cname("ColorContrast");                      // Get color with contrast correction, contrast values between -1.0f and 1.0f
fn Color colorAlpha(Color color, float alpha) @cname("ColorAlpha");                               // Get color with alpha applied, alpha goes from 0.0f to 1.0f
fn Color colorAlphaBlend(Color dst, Color src, Color tint) @cname("ColorAlphaBlend");             // Get src alpha-blended into dst color with tint
fn Color colorLerp(Color color1, Color color2, float factor) @cname("ColorLerp");                 // Get color lerp interpolation between two colors, factor [0.0f..1.0f]
fn Color getColor(CUInt hexValue) @cname("GetColor");                                             // Get Color structure from hexadecimal value
fn Color getPixelColor(void *srcPtr, PixelFormat format) @cname("GetPixelColor");                 // Get Color from a source pixel pointer of certain format
fn void setPixelColor(void *dstPtr, Color color, PixelFormat format) @cname("SetPixelColor");     // Set color formatted into destination pixel pointer
fn CInt getPixelDataSize(CInt width, CInt height, PixelFormat format) @cname("GetPixelDataSize"); // Get pixel data size in bytes for certain format

//------------------------------------------------------------------------------------
// Font Loading and Text Drawing Functions (Module: text)
//------------------------------------------------------------------------------------

// Font loading/unloading functions
fn Font getFontDefault() @cname("GetFontDefault");                                                                                                               // Get the default Font
fn Font loadFont(ZString fileName) @cname("LoadFont");                                                                                                           // Load font from file into GPU memory (VRAM)
fn Font loadFontEx(ZString fileName, CInt fontSize, CInt *codepoints, CInt codepointCount) @cname("LoadFontEx");                                                 // Load font from file with extended parameters, use NULL for codepoints and 0 for codepointCount to load the default character set, font size is provided in pixels height
fn Font loadFontFromImage(Image image, Color key, CInt firstChar) @cname("LoadFontFromImage");                                                                   // Load font from Image (XNA style)
fn Font loadFontFromMemory(ZString fileType, char* fileData, CInt dataSize, CInt fontSize, CInt *codepoints, CInt codepointCount) @cname("LoadFontFromMemory");  // Load font from memory buffer, fileType refers to extension: i.e. '.ttf'
fn bool isFontValid(Font font) @cname("IsFontValid");                                                                                                            // Check if a font is valid (font data loaded, WARNING: GPU texture not checked)
fn GlyphInfo *loadFontData(char* fileData, CInt dataSize, CInt fontSize, CInt *codepoints, CInt codepointCount, FontType type) @cname("LoadFontData");           // Load font data for further use
fn Image genImageFontAtlas(GlyphInfo *glyphs, Rectangle **glyphRecs, CInt glyphCount, CInt fontSize, CInt padding, CInt packMethod) @cname("GenImageFontAtlas"); // Generate image font atlas using chars info
fn void unloadFontData(GlyphInfo *glyphs, CInt glyphCount) @cname("UnloadFontData");                                                                             // Unload font chars info data (RAM)
fn void unloadFont(Font font) @cname("UnloadFont");                                                                                                              // Unload font from GPU memory (VRAM)
fn bool exportFontAsCode(Font font, ZString fileName) @cname("ExportFontAsCode");                                                                                // Export font as code file, returns true on success

// Text drawing functions
fn void drawFPS(CInt posX, CInt posY) @cname("DrawFPS");                                                                                                                // Draw current FPS
fn void drawText(ZString text, CInt posX, CInt posY, CInt fontSize, Color color) @cname("DrawText");                                                                    // Draw text (using default font)
fn void drawTextEx(Font font, ZString text, Vector2 position, float fontSize, float spacing, Color tint) @cname("DrawTextEx");                                          // Draw text using font and additional parameters
fn void drawTextPro(Font font, ZString text, Vector2 position, Vector2 origin, float rotation, float fontSize, float spacing, Color tint) @cname("DrawTextPro");        // Draw text using Font and pro parameters (rotation)
fn void drawTextCodepoint(Font font, CInt codepoint, Vector2 position, float fontSize, Color tint) @cname("DrawTextCodepoint");                                         // Draw one character (codepoint)
fn void drawTextCodepoints(Font font, CInt *codepoints, CInt codepointCount, Vector2 position, float fontSize, float spacing, Color tint) @cname("DrawTextCodepoints"); // Draw multiple character (codepoint)

// Text font info functions
fn void setTextLineSpacing(CInt spacing) @cname("SetTextLineSpacing");                                    // Set vertical line spacing when drawing with line-breaks
fn CInt measureText(ZString text, CInt fontSize) @cname("MeasureText");                                   // Measure string width for default font
fn Vector2 measureTextEx(Font font, ZString text, float fontSize, float spacing) @cname("MeasureTextEx"); // Measure string size for Font
fn CInt getGlyphIndex(Font font, CInt codepoint) @cname("GetGlyphIndex");                                 // Get glyph index position in font for a codepoint (unicode character), fallback to '?' if not found
fn GlyphInfo getGlyphInfo(Font font, CInt codepoint) @cname("GetGlyphInfo");                              // Get glyph font info data for a codepoint (unicode character), fallback to '?' if not found
fn Rectangle getGlyphAtlasRec(Font font, CInt codepoint) @cname("GetGlyphAtlasRec");                      // Get glyph rectangle in font atlas for a codepoint (unicode character), fallback to '?' if not found

// Text codepoints management functions (unicode characters)
fn char *loadUTF8(CInt *codepoints, CInt length) @cname("LoadUTF8");                            // Load UTF-8 text encoded from codepoints array
fn void unloadUTF8(char *text) @cname("UnloadUTF8");                                            // Unload UTF-8 text encoded from codepoints array
fn CInt *loadCodepoints(ZString text, CInt *count) @cname("LoadCodepoints");                    // Load all codepoints from a UTF-8 text string, codepoints count returned by parameter
fn void unloadCodepoints(CInt *codepoints) @cname("UnloadCodepoints");                          // Unload codepoints data from memory
fn CInt getCodepointCount(ZString text) @cname("GetCodepointCount");                            // Get total number of codepoints in a UTF-8 encoded string
fn CInt getCodepoint(ZString text, CInt *codepointSize) @cname("GetCodepoint");                 // Get next codepoint in a UTF-8 encoded string, 0x3f('?') is returned on failure
fn CInt getCodepointNext(ZString text, CInt *codepointSize) @cname("GetCodepointNext");         // Get next codepoint in a UTF-8 encoded string, 0x3f('?') is returned on failure
fn CInt getCodepointPrevious(ZString text, CInt *codepointSize) @cname("GetCodepointPrevious"); // Get previous codepoint in a UTF-8 encoded string, 0x3f('?') is returned on failure
fn ZString codepointToUTF8(CInt codepoint, CInt *utf8Size) @cname("CodepointToUTF8");           // Encode one codepoint into UTF-8 byte array (array length returned as parameter)

// Text strings management functions (no UTF-8 strings, only byte chars)
// NOTE: Some strings allocate memory internally for returned strings, just be careful!
fn CInt textCopy(ZString dst, ZString src) @cname("TextCopy");                            // Copy one string to another, returns bytes copied
fn bool textIsEqual(ZString text1, ZString text2) @cname("TextIsEqual");                  // Check if two text string are equal
fn CUInt textLength(ZString text) @cname("TextLength");                                   // Get text length, checks for '\0' ending
fn ZString textFormat(ZString text, ...) @cname("TextFormat");                            // Text formatting with variables (sprCIntf() style)
fn ZString textSubtext(ZString text, CInt position, CInt length) @cname("TextSubtext");   // Get a piece of a text string
fn char *textReplace(ZString text, ZString replace, ZString by) @cname("TextReplace");    // Replace text string (WARNING: memory must be freed!)
fn char *textInsert(ZString text, ZString insert, CInt position) @cname("TextInsert");    // Insert text in a position (WARNING: memory must be freed!)
fn ZString textJoin(ZString *textList, CInt count, ZString delimiter) @cname("TextJoin"); // Join text strings with delimiter
fn ZString *textSplit(ZString text, char delimiter, CInt *count) @cname("TextSplit");     // Split text CInto multiple strings
fn void textAppend(char *text, ZString append, CInt *position) @cname("TextAppend");      // Append text at specific position and move cursor!
fn CInt textFindIndex(ZString text, ZString find) @cname("TextFindIndex");                // Find first text occurrence within a string
fn ZString textToUpper(ZString text) @cname("TextToUpper");                               // Get upper case version of provided string
fn ZString textToLower(ZString text) @cname("TextToLower");                               // Get lower case version of provided string
fn ZString textToPascal(ZString text) @cname("TextToPascal");                             // Get Pascal case notation version of provided string
fn ZString textToSnake(ZString text) @cname("TextToSnake");                               // Get Snake case notation version of provided string
fn ZString textToCamel(ZString text) @cname("TextToCamel");                               // Get Camel case notation version of provided string

fn CInt textToInteger(ZString text) @cname("TextToInteger");                              // Get integer value from text (negative values not supported)
fn float textToFloat(ZString text) @cname("TextToFloat");                                 // Get float value from text (negative values not supported)

//------------------------------------------------------------------------------------
// Basic 3d Shapes Drawing Functions (Module: models)
//------------------------------------------------------------------------------------

// Basic geometric 3D shapes drawing functions
fn void drawLine3D(Vector3 startPos, Vector3 endPos, Color color) @cname("DrawLine3D");                                                                   // Draw a line in 3D world space
fn void drawPoint3D(Vector3 position, Color color) @cname("DrawPoint3D");                                                                                 // Draw a point in 3D space, actually a small line
fn void drawCircle3D(Vector3 center, float radius, Vector3 rotationAxis, float rotationAngle, Color color) @cname("DrawCircle3D");                        // Draw a circle in 3D world space
fn void drawTriangle3D(Vector3 v1, Vector3 v2, Vector3 v3, Color color) @cname("DrawTriangle3D");                                                         // Draw a color-filled triangle (vertex in counter-clockwise order!)
fn void drawTriangleStrip3D(Vector3 *points, CInt pointCount, Color color) @cname("DrawTriangleStrip3D");                                                 // Draw a triangle strip defined by points
fn void drawCube(Vector3 position, float width, float height, float length, Color color) @cname("DrawCube");                                              // Draw cube
fn void drawCubeV(Vector3 position, Vector3 size, Color color) @cname("DrawCubeV");                                                                       // Draw cube (Vector version)
fn void drawCubeWires(Vector3 position, float width, float height, float length, Color color) @cname("DrawCubeWires");                                    // Draw cube wires
fn void drawCubeWiresV(Vector3 position, Vector3 size, Color color) @cname("DrawCubeWiresV");                                                             // Draw cube wires (Vector version)
fn void drawSphere(Vector3 centerPos, float radius, Color color) @cname("DrawSphere");                                                                    // Draw sphere
fn void drawSphereEx(Vector3 centerPos, float radius, CInt rings, CInt slices, Color color) @cname("DrawSphereEx");                                       // Draw sphere with extended parameters
fn void drawSphereWires(Vector3 centerPos, float radius, CInt rings, CInt slices, Color color) @cname("DrawSphereWires");                                 // Draw sphere wires
fn void drawCylinder(Vector3 position, float radiusTop, float radiusBottom, float height, CInt slices, Color color) @cname("DrawCylinder");               // Draw a cylinder/cone
fn void drawCylinderEx(Vector3 startPos, Vector3 endPos, float startRadius, float endRadius, CInt sides, Color color) @cname("DrawCylinderEx");           // Draw a cylinder with base at startPos and top at endPos
fn void drawCylinderWires(Vector3 position, float radiusTop, float radiusBottom, float height, CInt slices, Color color) @cname("DrawCylinderWires");     // Draw a cylinder/cone wires
fn void drawCylinderWiresEx(Vector3 startPos, Vector3 endPos, float startRadius, float endRadius, CInt sides, Color color) @cname("DrawCylinderWiresEx"); // Draw a cylinder wires with base at startPos and top at endPos
fn void drawCapsule(Vector3 startPos, Vector3 endPos, float radius, CInt slices, CInt rings, Color color) @cname("DrawCapsule");                          // Draw a capsule with the center of its sphere caps at startPos and endPos
fn void drawCapsuleWires(Vector3 startPos, Vector3 endPos, float radius, CInt slices, CInt rings, Color color) @cname("DrawCapsuleWires");                // Draw capsule wireframe with the center of its sphere caps at startPos and endPos
fn void drawPlane(Vector3 centerPos, Vector2 size, Color color) @cname("DrawPlane");                                                                      // Draw a plane XZ
fn void drawRay(Ray ray, Color color) @cname("DrawRay");                                                                                                  // Draw a ray line
fn void drawGrid(CInt slices, float spacing) @cname("DrawGrid");                                                                                          // Draw a grid (centered at (0, 0, 0))

//------------------------------------------------------------------------------------
// Model 3d Loading and Drawing Functions (Module: models)
//------------------------------------------------------------------------------------

// Model management functions
fn Model loadModel(ZString fileName) @cname("LoadModel");                      // Load model from files (meshes and materials)
fn Model loadModelFromMesh(Mesh mesh) @cname("LoadModelFromMesh");             // Load model from generated mesh (default material)
fn bool isModelValid(Model model) @cname("IsModelValid");                      // Check if a model is valid (loaded in GPU, VAO/VBOs)
fn void unloadModel(Model model) @cname("UnloadModel");                        // Unload model (including meshes) from memory (RAM and/or VRAM)
fn BoundingBox getModelBoundingBox(Model model) @cname("GetModelBoundingBox"); // Compute model bounding box limits (considers all meshes)

// Model drawing functions
fn void drawModel(Model model, Vector3 position, float scale, Color tint) @cname("DrawModel");                                                                                                   // Draw a model (with texture if set)
fn void drawModelEx(Model model, Vector3 position, Vector3 rotationAxis, float rotationAngle, Vector3 scale, Color tint) @cname("DrawModelEx");                                                  // Draw a model with extended parameters
fn void drawModelWires(Model model, Vector3 position, float scale, Color tint) @cname("DrawModelWires");                                                                                         // Draw a model wires (with texture if set)
fn void drawModelWiresEx(Model model, Vector3 position, Vector3 rotationAxis, float rotationAngle, Vector3 scale, Color tint) @cname("DrawModelWiresEx");                                        // Draw a model wires (with texture if set) with extended parameters
fn void drawModelPoints(Model model, Vector3 position, float scale, Color tint) @cname("DrawModelPoints");                                                                                       // Draw a model as points
fn void drawModelPointsEx(Model model, Vector3 position, Vector3 rotationAxis, float rotationAngle, Vector3 scale, Color tint) @cname("DrawModelPointsEx");                                      // Draw a model as points with extended parameters
fn void drawBoundingBox(BoundingBox box, Color color) @cname("DrawBoundingBox");                                                                                                                 // Draw bounding box (wires)
fn void drawBillboard(Camera camera, Texture2D texture, Vector3 position, float scale, Color tint) @cname("DrawBillboard");                                                                      // Draw a billboard texture
fn void drawBillboardRec(Camera camera, Texture2D texture, Rectangle source, Vector3 position, Vector2 size, Color tint) @cname("DrawBillboardRec");                                             // Draw a billboard texture defined by source
fn void drawBillboardPro(Camera camera, Texture2D texture, Rectangle source, Vector3 position, Vector3 up, Vector2 size, Vector2 origin, float rotation, Color tint) @cname("DrawBillboardPro"); // Draw a billboard texture defined by source and rotation

// Mesh management functions
fn void uploadMesh(Mesh *mesh, bool dynamic) @cname("UploadMesh");                                                       // Upload mesh vertex data in GPU and provide VAO/VBO ids
fn void updateMeshBuffer(Mesh mesh, CInt index, void *data, CInt dataSize, CInt offset) @cname("UpdateMeshBuffer");      // Update mesh vertex data in GPU for a specific buffer index
fn void unloadMesh(Mesh mesh) @cname("UnloadMesh");                                                                      // Unload mesh data from CPU and GPU
fn void drawMesh(Mesh mesh, Material material, Matrix transform) @cname("DrawMesh");                                     // Draw a 3d mesh with material and transform
fn void drawMeshInstanced(Mesh mesh, Material material, Matrix *transforms, CInt instances) @cname("DrawMeshInstanced"); // Draw multiple mesh instances with material and different transforms
fn BoundingBox getMeshBoundingBox(Mesh mesh) @cname("GetMeshBoundingBox");                                               // Compute mesh bounding box limits
fn void genMeshTangents(Mesh *mesh) @cname("GenMeshTangents");                                                           // Compute mesh tangents
fn bool exportMesh(Mesh mesh, ZString fileName) @cname("ExportMesh");                                                    // Export mesh data to file, returns true on success
fn bool exportMeshAsCode(Mesh mesh, ZString fileName) @cname("ExportMeshAsCode");                                        // Export mesh as code file (.h) defining multiple arrays of vertex attributes

// Mesh generation functions
fn Mesh genMeshPoly(CInt sides, float radius) @cname("GenMeshPoly");                            // Generate polygonal mesh
fn Mesh genMeshPlane(float width, float length, CInt resX, CInt resZ) @cname("GenMeshPlane");   // Generate plane mesh (with subdivisions)
fn Mesh genMeshCube(float width, float height, float length) @cname("GenMeshCube");             // Generate cuboid mesh
fn Mesh genMeshSphere(float radius, CInt rings, CInt slices) @cname("GenMeshSphere");           // Generate sphere mesh (standard sphere)
fn Mesh genMeshHemiSphere(float radius, CInt rings, CInt slices) @cname("GenMeshHemiSphere");   // Generate half-sphere mesh (no bottom cap)
fn Mesh genMeshCylinder(float radius, float height, CInt slices) @cname("GenMeshCylinder");     // Generate cylinder mesh
fn Mesh genMeshCone(float radius, float height, CInt slices) @cname("GenMeshCone");             // Generate cone/pyramid mesh
fn Mesh genMeshTorus(float radius, float size, CInt radSeg, CInt sides) @cname("GenMeshTorus"); // Generate torus mesh
fn Mesh genMeshKnot(float radius, float size, CInt radSeg, CInt sides) @cname("GenMeshKnot");   // Generate trefoil knot mesh
fn Mesh genMeshHeightmap(Image heightmap, Vector3 size) @cname("GenMeshHeightmap");             // Generate heightmap mesh from image data
fn Mesh genMeshCubicmap(Image cubicmap, Vector3 cubeSize) @cname("GenMeshCubicmap");            // Generate cubes-based map mesh from image data

// Material loading/unloading functions
fn Material *loadMaterials(ZString fileName, CInt *materialCount) @cname("LoadMaterials");                                // Load materials from model file
fn Material loadMaterialDefault() @cname("LoadMaterialDefault");                                                          // Load default material (Supports: DIFFUSE, SPECULAR, NORMAL maps)
fn bool isMaterialValid(Material material) @cname("IsMaterialValid");                                                     // Check if a material is valid (shader assigned, map textures loaded in GPU)
fn void unloadMaterial(Material material) @cname("UnloadMaterial");                                                       // Unload material from GPU memory (VRAM)
fn void setMaterialTexture(Material *material, MaterialMapIndex mapType, Texture2D texture) @cname("SetMaterialTexture"); // Set texture for a material map type (MATERIAL_MAP_DIFFUSE, MATERIAL_MAP_SPECULAR...)
fn void setModelMeshMaterial(Model *model, CInt meshId, CInt materialId) @cname("SetModelMeshMaterial");                  // Set material for a mesh

// Model animations loading/unloading functions
fn ModelAnimation *loadModelAnimations(ZString fileName, CInt *animCount) @cname("LoadModelAnimations");             // Load model animations from file
fn void updateModelAnimation(Model model, ModelAnimation anim, CInt frame) @cname("UpdateModelAnimation");           // Update model animation pose (CPU)
fn void updateModelAnimationBones(Model model, ModelAnimation anim, CInt frame) @cname("UpdateModelAnimationBones"); // Update model animation mesh bone matrices (GPU skinning)
fn void unloadModelAnimation(ModelAnimation anim) @cname("UnloadModelAnimation");                                    // Unload animation data
fn void unloadModelAnimations(ModelAnimation *animations, CInt animCount) @cname("UnloadModelAnimations");           // Unload animation array data
fn bool isModelAnimationValid(Model model, ModelAnimation anim) @cname("IsModelAnimationValid");                     // Check model animation skeleton match

// Collision detection functions
fn bool checkCollisionSpheres(Vector3 center1, float radius1, Vector3 center2, float radius2) @cname("CheckCollisionSpheres"); // Check collision between two spheres
fn bool checkCollisionBoxes(BoundingBox box1, BoundingBox box2) @cname("CheckCollisionBoxes");                                 // Check collision between two bounding boxes
fn bool checkCollisionBoxSphere(BoundingBox box, Vector3 center, float radius) @cname("CheckCollisionBoxSphere");              // Check collision between box and sphere
fn RayCollision getRayCollisionSphere(Ray ray, Vector3 center, float radius) @cname("GetRayCollisionSphere");                  // Get collision info between ray and sphere
fn RayCollision getRayCollisionBox(Ray ray, BoundingBox box) @cname("GetRayCollisionBox");                                     // Get collision info between ray and box
fn RayCollision getRayCollisionMesh(Ray ray, Mesh mesh, Matrix transform) @cname("GetRayCollisionMesh");                       // Get collision info between ray and mesh
fn RayCollision getRayCollisionTriangle(Ray ray, Vector3 p1, Vector3 p2, Vector3 p3) @cname("GetRayCollisionTriangle");        // Get collision info between ray and triangle
fn RayCollision getRayCollisionQuad(Ray ray, Vector3 p1, Vector3 p2, Vector3 p3, Vector3 p4) @cname("GetRayCollisionQuad");    // Get collision info between ray and quad

//------------------------------------------------------------------------------------
// Audio Loading and Playing Functions (Module: audio)
//------------------------------------------------------------------------------------
alias AudioCallback = fn void(void *bufferData, CUInt frames);

// Audio device management functions
fn void initAudioDevice() @cname("InitAudioDevice");             // Initialize audio device and context
fn void closeAudioDevice() @cname("CloseAudioDevice");           // Close the audio device and context
fn bool isAudioDeviceReady() @cname("IsAudioDeviceReady");       // Check if audio device has been initialized successfully
fn void setMasterVolume(float volume) @cname("SetMasterVolume"); // Set master volume (listener)
fn float getMasterVolume() @cname("GetMasterVolume");            // Get master volume (listener)

// Wave/Sound loading/unloading functions
fn Wave loadWave(ZString fileName) @cname("LoadWave");                                                    // Load wave data from file
fn Wave loadWaveFromMemory(ZString fileType, char* fileData, CInt dataSize) @cname("LoadWaveFromMemory"); // Load wave from memory buffer, fileType refers to extension: i.e. '.wav'
fn bool isWaveValid(Wave wave) @cname("IsWaveValid");                                                     // Checks if wave data is valid (data loaded and parameters)
fn Sound loadSound(ZString fileName) @cname("LoadSound");                                                 // Load sound from file
fn Sound loadSoundFromWave(Wave wave) @cname("LoadSoundFromWave");                                        // Load sound from wave data
fn Sound loadSoundAlias(Sound source) @cname("LoadSoundAlias");                                           // Create a new sound that shares the same sample data as the source sound, does not own the sound data
fn bool isSoundValid(Sound sound) @cname("IsSoundValid");                                                 // Checks if a sound is valid (data loaded and buffers initialized)
fn void updateSound(Sound sound, void *data, CInt sampleCount) @cname("UpdateSound");                     // Update sound buffer with new data
fn void unloadWave(Wave wave) @cname("UnloadWave");                                                       // Unload wave data
fn void unloadSound(Sound sound) @cname("UnloadSound");                                                   // Unload sound
fn void unloadSoundAlias(Sound alias_) @cname("UnloadSoundAlias");                                        // Unload a sound alias (does not deallocate sample data)
fn bool exportWave(Wave wave, ZString fileName) @cname("ExportWave");                                     // Export wave data to file, returns true on success
fn bool exportWaveAsCode(Wave wave, ZString fileName) @cname("ExportWaveAsCode");                         // Export wave sample data to code (.h), returns true on success

// Wave/Sound management functions
fn void playSound(Sound sound) @cname("PlaySound");                                                   // Play a sound
fn void stopSound(Sound sound) @cname("StopSound");                                                   // Stop playing a sound
fn void pauseSound(Sound sound) @cname("PauseSound");                                                 // Pause a sound
fn void resumeSound(Sound sound) @cname("ResumeSound");                                               // Resume a paused sound
fn bool isSoundPlaying(Sound sound) @cname("IsSoundPlaying");                                         // Check if a sound is currently playing
fn void setSoundVolume(Sound sound, float volume) @cname("SetSoundVolume");                           // Set volume for a sound (1.0 is max level)
fn void setSoundPitch(Sound sound, float pitch) @cname("SetSoundPitch");                              // Set pitch for a sound (1.0 is base level)
fn void setSoundPan(Sound sound, float pan) @cname("SetSoundPan");                                    // Set pan for a sound (0.5 is center)
fn Wave waveCopy(Wave wave) @cname("WaveCopy");                                                       // Copy a wave to a new wave
fn void waveCrop(Wave *wave, CInt initFrame, CInt finalFrame) @cname("WaveCrop");                     // Crop a wave to defined frames range
fn void waveFormat(Wave *wave, CInt sampleRate, CInt sampleSize, CInt channels) @cname("WaveFormat"); // Convert wave data to desired format
fn float *loadWaveSamples(Wave wave) @cname("LoadWaveSamples");                                       // Load samples data from wave as a 32bit float data array
fn void unloadWaveSamples(float *samples) @cname("UnloadWaveSamples");                                // Unload samples data loaded with LoadWaveSamples()

// Music management functions
fn Music loadMusicStream(ZString fileName) @cname("LoadMusicStream");                                                // Load music stream from file
fn Music loadMusicStreamFromMemory(ZString fileType, char* data, CInt dataSize) @cname("LoadMusicStreamFromMemory"); // Load music stream from data
fn bool isMusicValid(Music music) @cname("IsMusicValid");                                                            // Checks if a music stream is valid (context and buffers initialized)
fn void unloadMusicStream(Music music) @cname("UnloadMusicStream");                                                  // Unload music stream
fn void playMusicStream(Music music) @cname("PlayMusicStream");                                                      // Start music playing
fn bool isMusicStreamPlaying(Music music) @cname("IsMusicStreamPlaying");                                            // Check if music is playing
fn void updateMusicStream(Music music) @cname("UpdateMusicStream");                                                  // Updates buffers for music streaming
fn void stopMusicStream(Music music) @cname("StopMusicStream");                                                      // Stop music playing
fn void pauseMusicStream(Music music) @cname("PauseMusicStream");                                                    // Pause music playing
fn void resumeMusicStream(Music music) @cname("ResumeMusicStream");                                                  // Resume playing paused music
fn void seekMusicStream(Music music, float position) @cname("SeekMusicStream");                                      // Seek music to a position (in seconds)
fn void setMusicVolume(Music music, float volume) @cname("SetMusicVolume");                                          // Set volume for music (1.0 is max level)
fn void setMusicPitch(Music music, float pitch) @cname("SetMusicPitch");                                             // Set pitch for a music (1.0 is base level)
fn void setMusicPan(Music music, float pan) @cname("SetMusicPan");                                                   // Set pan for a music (0.5 is center)
fn float getMusicTimeLength(Music music) @cname("GetMusicTimeLength");                                               // Get music time length (in seconds)
fn float getMusicTimePlayed(Music music) @cname("GetMusicTimePlayed");                                               // Get current music time played (in seconds)

// AudioStream management functions
fn AudioStream loadAudioStream(CUInt sampleRate, CUInt sampleSize, CUInt channels) @cname("LoadAudioStream"); // Load audio stream (to stream raw audio pcm data)
fn bool isAudioStreamValid(AudioStream stream) @cname("IsAudioStreamValid");                                  // Checks if an audio stream is valid (buffers initialized)
fn void unloadAudioStream(AudioStream stream) @cname("UnloadAudioStream");                                    // Unload audio stream and free memory
fn void updateAudioStream(AudioStream stream, void *data, CInt frameCount) @cname("UpdateAudioStream");       // Update audio stream buffers with data
fn bool isAudioStreamProcessed(AudioStream stream) @cname("IsAudioStreamProcessed");                          // Check if any audio stream buffers requires refill
fn void playAudioStream(AudioStream stream) @cname("PlayAudioStream");                                        // Play audio stream
fn void pauseAudioStream(AudioStream stream) @cname("PauseAudioStream");                                      // Pause audio stream
fn void resumeAudioStream(AudioStream stream) @cname("ResumeAudioStream");                                    // Resume audio stream
fn bool isAudioStreamPlaying(AudioStream stream) @cname("IsAudioStreamPlaying");                              // Check if audio stream is playing
fn void stopAudioStream(AudioStream stream) @cname("StopAudioStream");                                        // Stop audio stream
fn void setAudioStreamVolume(AudioStream stream, float volume) @cname("SetAudioStreamVolume");                // Set volume for audio stream (1.0 is max level)
fn void setAudioStreamPitch(AudioStream stream, float pitch) @cname("SetAudioStreamPitch");                   // Set pitch for audio stream (1.0 is base level)
fn void setAudioStreamPan(AudioStream stream, float pan) @cname("SetAudioStreamPan");                         // Set pan for audio stream (0.5 is centered)
fn void setAudioStreamBufferSizeDefault(CInt size) @cname("SetAudioStreamBufferSizeDefault");                 // Default size for new audio streams
fn void setAudioStreamCallback(AudioStream stream, AudioCallback callback) @cname("SetAudioStreamCallback");  // Audio thread callback to request new data

fn void attachAudioStreamProcessor(AudioStream stream, AudioCallback processor) @cname("AttachAudioStreamProcessor"); // Attach audio stream processor to stream, receives the samples as 'float'
fn void detachAudioStreamProcessor(AudioStream stream, AudioCallback processor) @cname("DetachAudioStreamProcessor"); // Detach audio stream processor from stream

fn void attachAudioMixedProcessor(AudioCallback processor) @cname("AttachAudioMixedProcessor"); // Attach audio stream processor to the entire audio pipeline, receives the samples as 'float'
fn void detachAudioMixedProcessor(AudioCallback processor) @cname("DetachAudioMixedProcessor"); // Detach audio stream processor from the entire audio pipeline


//----------------------------------------------------------------------------------
// Additional Raylib.c3 Mode helper macros
//----------------------------------------------------------------------------------

<*
 Setup canvas (framebuffer) to start drawing, then calls [block].
 Drawing will end after [block] has finished.
*>
macro void @drawing(;@body)
{
	beginDrawing();
	defer endDrawing();
	@body();
}

<*
 Setup 2D mode with custom camera to start 2D Mode, then calls [block].
 Mode2D will end after [block] has finished.
*>
macro void @mode2D(Camera2D camera ;@body)
{
	beginMode2D(camera);
	defer endMode2D();
	@body();
}

<*
 Setup 3D mode with custom camera to start 2D Mode, then calls [block].
 Mode2D will end after [block] has finished.
*>
macro void @mode3D(Camera3D camera ;@body)
{
	beginMode3D(camera);
	defer endMode3D();
	@body();
}

<*
 Setup texture mode to draw to render texture, then calls [block].
 texture mode will end after [block] has finished.
*>
macro void @textureMode(RenderTexture2D texture ;@body)
{
	beginTextureMode(texture);
	defer endTextureMode();
	@body();
}


<*
 Setup custom shqder mode then calls [block].
 shader mode will end after [block] has finished.
*>
macro void @shaderMode(Shader shader ;@body)
{
	beginShaderMode(shader);
	defer endShaderMode();
	@body();
}

<*
 Setup blending mode, then calls [block].
 blend mode will end after [block] has finished.
*>
macro void @blendMode(BlendMode mode ;@body)
{
	beginBlendMode(mode);
	defer endBlendMode();
	@body();
}

<*
 Setup scissor mode then calls [block].
 scissor mode will end after [block] has finished.
*>
macro void @scissorMode(CInt x, CInt y, CInt width, CInt height ;@body)
{
	beginScissorMode(x, y, width, height);
	defer endScissorMode();
	@body();
}

<*
 Setup stereo rendering mode, then calls [block].
 stereo rendering mode will end after [block] has finished.
*>
macro void @vrMode(VrStereoConfig config ;@body)
{
	beginVrStereoMode(config);
	defer endVrStereoMode();
	@body();
}


<*
 Setup rl drawing mode, then calls [block].
 rlBegin will end after [block] has finished.
*>
macro void @rlMode(CInt mode ;@body)
{
	rlBegin(mode);
	defer rlEnd();
	@body();
}

//----------------------------------------------------------------------------------
// Enumerators Definition
//----------------------------------------------------------------------------------
// System/Window config flags
// NOTE: Every bit registers one state (use it with bit masks)
// By default all flags are set to 0

constdef ConfigFlag : uint
{
	VSYNC_HINT         = 0x00000040,   // Set to try enabling V-Sync on GPU
	FULLSCREEN_MODE    = 0x00000002,   // Set to run program in fullscreen
	WINDOW_RESIZABLE   = 0x00000004,   // Set to allow resizable window
	WINDOW_UNDECORATED = 0x00000008,   // Set to disable window decoration (frame and buttons)
	WINDOW_HIDDEN      = 0x00000080,   // Set to hide window
	WINDOW_MINIMIZED   = 0x00000200,   // Set to minimize window (iconify)
	WINDOW_MAXIMIZED   = 0x00000400,   // Set to maximize window (expanded to monitor)
	WINDOW_UNFOCUSED   = 0x00000800,   // Set to window non focused
	WINDOW_TOPMOST     = 0x00001000,   // Set to window always on top
	WINDOW_ALWAYS_RUN  = 0x00000100,   // Set to allow windows running while minimized
	WINDOW_TRANSPARENT = 0x00000010,   // Set to allow transparent framebuffer
	WINDOW_HIGHDPI     = 0x00002000,   // Set to support HighDPI
	MSAA_4X_HINT       = 0x00000020,   // Set to try enabling MSAA 4X
	INTERLACED_HINT    = 0x00010000,   // Set to try enabling interlaced video format (for V3D)
}

// Keyboard keys (US keyboard layout)
// NOTE: Use GetKeyPressed() to allow redefining
// required keys for alternative layouts

typedef KeyboardKey = int;

const KeyboardKey KEY_NULL            = 0;        // Key: NULL; used for no key pressed
				// Alphanumeric keys
const KeyboardKey KEY_APOSTROPHE      = 39;       // Key: '
const KeyboardKey KEY_COMMA           = 44;       // Key: ;
const KeyboardKey KEY_MINUS           = 45;       // Key: -
const KeyboardKey KEY_PERIOD          = 46;       // Key: .
const KeyboardKey KEY_SLASH           = 47;       // Key: /
const KeyboardKey KEY_ZERO            = 48;       // Key: 0
const KeyboardKey KEY_ONE             = 49;       // Key: 1
const KeyboardKey KEY_TWO             = 50;       // Key: 2
const KeyboardKey KEY_THREE           = 51;       // Key: 3
const KeyboardKey KEY_FOUR            = 52;       // Key: 4
const KeyboardKey KEY_FIVE            = 53;       // Key: 5
const KeyboardKey KEY_SIX             = 54;       // Key: 6
const KeyboardKey KEY_SEVEN           = 55;       // Key: 7
const KeyboardKey KEY_EIGHT           = 56;       // Key: 8
const KeyboardKey KEY_NINE            = 57;       // Key: 9
const KeyboardKey KEY_SEMICOLON       = 59;       // Key: ;
const KeyboardKey KEY_EQUAL           = 61;       // Key: =
const KeyboardKey KEY_A               = 65;       // Key: A | a
const KeyboardKey KEY_B               = 66;       // Key: B | b
const KeyboardKey KEY_C               = 67;       // Key: C | c
const KeyboardKey KEY_D               = 68;       // Key: D | d
const KeyboardKey KEY_E               = 69;       // Key: E | e
const KeyboardKey KEY_F               = 70;       // Key: F | f
const KeyboardKey KEY_G               = 71;       // Key: G | g
const KeyboardKey KEY_H               = 72;       // Key: H | h
const KeyboardKey KEY_I               = 73;       // Key: I | i
const KeyboardKey KEY_J               = 74;       // Key: J | j
const KeyboardKey KEY_K               = 75;       // Key: K | k
const KeyboardKey KEY_L               = 76;       // Key: L | l
const KeyboardKey KEY_M               = 77;       // Key: M | m
const KeyboardKey KEY_N               = 78;       // Key: N | n
const KeyboardKey KEY_O               = 79;       // Key: O | o
const KeyboardKey KEY_P               = 80;       // Key: P | p
const KeyboardKey KEY_Q               = 81;       // Key: Q | q
const KeyboardKey KEY_R               = 82;       // Key: R | r
const KeyboardKey KEY_S               = 83;       // Key: S | s
const KeyboardKey KEY_T               = 84;       // Key: T | t
const KeyboardKey KEY_U               = 85;       // Key: U | u
const KeyboardKey KEY_V               = 86;       // Key: V | v
const KeyboardKey KEY_W               = 87;       // Key: W | w
const KeyboardKey KEY_X               = 88;       // Key: X | x
const KeyboardKey KEY_Y               = 89;       // Key: Y | y
const KeyboardKey KEY_Z               = 90;       // Key: Z | z
const KeyboardKey KEY_LEFT_BRACKET    = 91;       // Key: [
const KeyboardKey KEY_BACKSLASH       = 92;       // Key: '\'
const KeyboardKey KEY_RIGHT_BRACKET   = 93;       // Key: ]
const KeyboardKey KEY_GRAVE           = 96;       // Key: `
// Function keys
const KeyboardKey KEY_SPACE           = 32;       // Key: Space
const KeyboardKey KEY_ESCAPE          = 256;      // Key: Esc
const KeyboardKey KEY_ENTER           = 257;      // Key: Enter
const KeyboardKey KEY_TAB             = 258;      // Key: Tab
const KeyboardKey KEY_BACKSPACE       = 259;      // Key: Backspace
const KeyboardKey KEY_INSERT          = 260;      // Key: Ins
const KeyboardKey KEY_DELETE          = 261;      // Key: Del
const KeyboardKey KEY_RIGHT           = 262;      // Key: Cursor right
const KeyboardKey KEY_LEFT            = 263;      // Key: Cursor left
const KeyboardKey KEY_DOWN            = 264;      // Key: Cursor down
const KeyboardKey KEY_UP              = 265;      // Key: Cursor up
const KeyboardKey KEY_PAGE_UP         = 266;      // Key: Page up
const KeyboardKey KEY_PAGE_DOWN       = 267;      // Key: Page down
const KeyboardKey KEY_HOME            = 268;      // Key: Home
const KeyboardKey KEY_END             = 269;      // Key: End
const KeyboardKey KEY_CAPS_LOCK       = 280;      // Key: Caps lock
const KeyboardKey KEY_SCROLL_LOCK     = 281;      // Key: Scroll down
const KeyboardKey KEY_NUM_LOCK        = 282;      // Key: Num lock
const KeyboardKey KEY_PRINT_SCREEN    = 283;      // Key: Print screen
const KeyboardKey KEY_PAUSE           = 284;      // Key: Pause
const KeyboardKey KEY_F1              = 290;      // Key: F1
const KeyboardKey KEY_F2              = 291;      // Key: F2
const KeyboardKey KEY_F3              = 292;      // Key: F3
const KeyboardKey KEY_F4              = 293;      // Key: F4
const KeyboardKey KEY_F5              = 294;      // Key: F5
const KeyboardKey KEY_F6              = 295;      // Key: F6
const KeyboardKey KEY_F7              = 296;      // Key: F7
const KeyboardKey KEY_F8              = 297;      // Key: F8
const KeyboardKey KEY_F9              = 298;      // Key: F9
const KeyboardKey KEY_F10             = 299;      // Key: F10
const KeyboardKey KEY_F11             = 300;      // Key: F11
const KeyboardKey KEY_F12             = 301;      // Key: F12
const KeyboardKey KEY_LEFT_SHIFT      = 340;      // Key: Shift left
const KeyboardKey KEY_LEFT_CONTROL    = 341;      // Key: Control left
const KeyboardKey KEY_LEFT_ALT        = 342;      // Key: Alt left
const KeyboardKey KEY_LEFT_SUPER      = 343;      // Key: Super left
const KeyboardKey KEY_RIGHT_SHIFT     = 344;      // Key: Shift right
const KeyboardKey KEY_RIGHT_CONTROL   = 345;      // Key: Control right
const KeyboardKey KEY_RIGHT_ALT       = 346;      // Key: Alt right
const KeyboardKey KEY_RIGHT_SUPER     = 347;      // Key: Super right
const KeyboardKey KEY_KB_MENU         = 348;      // Key: KB menu
// Keypad keys
const KeyboardKey KEY_KP_0            = 320;      // Key: Keypad 0
const KeyboardKey KEY_KP_1            = 321;      // Key: Keypad 1
const KeyboardKey KEY_KP_2            = 322;      // Key: Keypad 2
const KeyboardKey KEY_KP_3            = 323;      // Key: Keypad 3
const KeyboardKey KEY_KP_4            = 324;      // Key: Keypad 4
const KeyboardKey KEY_KP_5            = 325;      // Key: Keypad 5
const KeyboardKey KEY_KP_6            = 326;      // Key: Keypad 6
const KeyboardKey KEY_KP_7            = 327;      // Key: Keypad 7
const KeyboardKey KEY_KP_8            = 328;      // Key: Keypad 8
const KeyboardKey KEY_KP_9            = 329;      // Key: Keypad 9
const KeyboardKey KEY_KP_DECIMAL      = 330;      // Key: Keypad .
const KeyboardKey KEY_KP_DIVIDE       = 331;      // Key: Keypad /
const KeyboardKey KEY_KP_MULTIPLY     = 332;      // Key: Keypad *
const KeyboardKey KEY_KP_SUBTRACT     = 333;      // Key: Keypad -
const KeyboardKey KEY_KP_ADD          = 334;      // Key: Keypad +
const KeyboardKey KEY_KP_ENTER        = 335;      // Key: Keypad Enter
const KeyboardKey KEY_KP_EQUAL        = 336;      // Key: Keypad =
// Android key buttons
const KeyboardKey KEY_BACK            = 4;        // Key: Android back button
const KeyboardKey KEY_MENU            = 82;       // Key: Android menu button
const KeyboardKey KEY_VOLUME_UP       = 24;       // Key: Android volume up button
const KeyboardKey KEY_VOLUME_DOWN     = 25;       // Key: Android volume down button

// Gesture
// NOTE: It could be used as flags to enable only some gestures
constdef Gesture : int
{
	NONE        = 0,      // No gesture
	TAP         = 1,        // Tap gesture
	DOUBLETAP   = 2,        // Double tap gesture
	HOLD        = 4,        // Hold gesture
	DRAG        = 8,        // Drag gesture
	SWIPE_RIGHT = 16,       // Swipe right gesture
	SWIPE_LEFT  = 32,       // Swipe left gesture
	SWIPE_UP    = 64,       // Swipe up gesture
	SWIPE_DOWN  = 128,      // Swipe down gesture
	PINCH_IN    = 256,      // Pinch in gesture
	PINCH_OUT   = 512,      // Pinch out gesture
}

// rlgl.h
typedef FramebufferAttachType = int;

const FramebufferAttachType RL_ATTACHMENT_COLOR_CHANNEL0 = 0;       // Framebuffer attachment type: color 0
const FramebufferAttachType RL_ATTACHMENT_COLOR_CHANNEL1 = 1;       // Framebuffer attachment type: color 1
const FramebufferAttachType RL_ATTACHMENT_COLOR_CHANNEL2 = 2;       // Framebuffer attachment type: color 2
const FramebufferAttachType RL_ATTACHMENT_COLOR_CHANNEL3 = 3;       // Framebuffer attachment type: color 3
const FramebufferAttachType RL_ATTACHMENT_COLOR_CHANNEL4 = 4;       // Framebuffer attachment type: color 4
const FramebufferAttachType RL_ATTACHMENT_COLOR_CHANNEL5 = 5;       // Framebuffer attachment type: color 5
const FramebufferAttachType RL_ATTACHMENT_COLOR_CHANNEL6 = 6;       // Framebuffer attachment type: color 6
const FramebufferAttachType RL_ATTACHMENT_COLOR_CHANNEL7 = 7;       // Framebuffer attachment type: color 7
const FramebufferAttachType RL_ATTACHMENT_DEPTH = 100;              // Framebuffer attachment type: depth
const FramebufferAttachType RL_ATTACHMENT_STENCIL = 200;            // Framebuffer attachment type: stencil

typedef FramebufferAttachTextureType = int;

const FramebufferAttachTextureType RL_ATTACHMENT_CUBEMAP_POSITIVE_X = 0;   // Framebuffer texture attachment type: cubemap, +X side
const FramebufferAttachTextureType RL_ATTACHMENT_CUBEMAP_NEGATIVE_X = 1;   // Framebuffer texture attachment type: cubemap, -X side
const FramebufferAttachTextureType RL_ATTACHMENT_CUBEMAP_POSITIVE_Y = 2;   // Framebuffer texture attachment type: cubemap, +Y side
const FramebufferAttachTextureType RL_ATTACHMENT_CUBEMAP_NEGATIVE_Y = 3;   // Framebuffer texture attachment type: cubemap, -Y side
const FramebufferAttachTextureType RL_ATTACHMENT_CUBEMAP_POSITIVE_Z = 4;   // Framebuffer texture attachment type: cubemap, +Z side
const FramebufferAttachTextureType RL_ATTACHMENT_CUBEMAP_NEGATIVE_Z = 5;   // Framebuffer texture attachment type: cubemap, -Z side
const FramebufferAttachTextureType RL_ATTACHMENT_TEXTURE2D = 100;          // Framebuffer texture attachment type: texture2d
const FramebufferAttachTextureType RL_ATTACHMENT_RENDERBUFFER = 200;       // Framebuffer texture attachment type: renderbuffer

const RL_LINES = 0x0001;        // GL_LINES
const RL_TRIANGLES = 0x0004;    // GL_TRIANGLES
const RL_QUADS = 0x0007;        // GL_QUADS


//------------------------------------------------------------------------------------
// Functions Declaration - Matrix operations
//------------------------------------------------------------------------------------
fn void rlMatrixMode(CInt mode);                      // Choose the current matrix to be transformed
fn void rlPushMatrix();                          // Push the current matrix to stack
fn void rlPopMatrix();                           // Pop latest inserted matrix from stack
fn void rlLoadIdentity();                        // Reset current matrix to identity matrix
fn void rlTranslatef(float x, float y, float z);     // Multiply the current matrix by a translation matrix
fn void rlRotatef(float angle, float x, float y, float z); // Multiply the current matrix by a rotation matrix
fn void rlScalef(float x, float y, float z);         // Multiply the current matrix by a scaling matrix
fn void rlMultMatrixf(float *matf);            // Multiply the current matrix by another matrix
fn void rlFrustum(double left, double right, double bottom, double top, double znear, double zfar);
fn void rlOrtho(double left, double right, double bottom, double top, double znear, double zfar);
fn void rlViewport(CInt x, CInt y, CInt width, CInt height); // Set the viewport area
fn void rlSetClipPlanes(double nearPlane, double farPlane);    // Set clip planes distances
fn double rlGetCullDistanceNear();               // Get cull plane distance near
fn double rlGetCullDistanceFar();                // Get cull plane distance far

//------------------------------------------------------------------------------------
// Functions Declaration - Vertex level operations
//------------------------------------------------------------------------------------
fn void rlBegin(CInt mode);                           // Initialize drawing mode (how to organize vertex)
fn void rlEnd();                                 // Finish vertex providing
fn void rlVertex2i(CInt x, CInt y);                    // Define one vertex (position) - 2 CInt
fn void rlVertex2f(float x, float y);                // Define one vertex (position) - 2 float
fn void rlVertex3f(float x, float y, float z);       // Define one vertex (position) - 3 float
fn void rlTexCoord2f(float x, float y);              // Define one vertex (texture coordinate) - 2 float
fn void rlNormal3f(float x, float y, float z);       // Define one vertex (normal) - 3 float
fn void rlColor4ub(char r, char g, char b, char a); // Define one vertex (color) - 4 byte
fn void rlColor3f(float x, float y, float z);        // Define one vertex (color) - 3 float
fn void rlColor4f(float x, float y, float z, float w); // Define one vertex (color) - 4 float

//------------------------------------------------------------------------------------
// Functions Declaration - OpenGL style functions (common to 1.1, 3.3+, ES2)
// NOTE: This functions are used to completely abstract raylib code from OpenGL layer,
// some of them are direct wrappers over OpenGL calls, some others are custom
//------------------------------------------------------------------------------------

// Vertex buffers state
fn bool rlEnableVertexArray(CUInt vaoId);     // Enable vertex array (VAO, if supported)
fn void rlDisableVertexArray();                  // Disable vertex array (VAO, if supported)
fn void rlEnableVertexBuffer(CUInt id);       // Enable vertex buffer (VBO)
fn void rlDisableVertexBuffer();                 // Disable vertex buffer (VBO)
fn void rlEnableVertexBufferElement(CUInt id); // Enable vertex buffer element (VBO element)
fn void rlDisableVertexBufferElement();          // Disable vertex buffer element (VBO element)
fn void rlEnableVertexAttribute(CUInt index); // Enable vertex attribute index
fn void rlDisableVertexAttribute(CUInt index); // Disable vertex attribute index
fn void rlEnableStatePointer(ShaderAttributeDataType vertexAttribType, void *buffer); // Enable attribute state pointer
fn void rlDisableStatePointer(ShaderAttributeDataType vertexAttribType); // Disable attribute state pointer

// Textures state
fn void rlActiveTextureSlot(CInt slot);               // Select and active a texture slot
fn void rlEnableTexture(CUInt id);            // Enable texture
fn void rlDisableTexture();                      // Disable texture
fn void rlEnableTextureCubemap(CUInt id);     // Enable texture cubemap
fn void rlDisableTextureCubemap();               // Disable texture cubemap
fn void rlTextureParameters(CUInt id, CInt param, CInt value); // Set texture parameters (filter, wrap)
fn void rlCubemapParameters(CUInt id, CInt param, CInt value); // Set cubemap parameters (filter, wrap)

// Shader state
fn void rlEnableShader(CUInt id);             // Enable shader program
fn void rlDisableShader();                       // Disable shader program

// Framebuffer state
fn void rlEnableFramebuffer(CUInt id);        // Enable render texture (fbo)
fn void rlDisableFramebuffer();                  // Disable render texture (fbo), return to default framebuffer
fn CUInt rlGetActiveFramebuffer();        // Get the currently active render texture (fbo), 0 for default framebuffer
fn void rlActiveDrawBuffers(CInt count);              // Activate multiple draw color buffers
fn void rlBlitFramebuffer(CInt srcX, CInt srcY, CInt srcWidth, CInt srcHeight, CInt dstX, CInt dstY, CInt dstWidth, CInt dstHeight, CInt bufferMask); // Blit active framebuffer to main framebuffer
fn void rlBindFramebuffer(CUInt target, CUInt framebuffer); // Bind framebuffer (FBO)

// General render state
fn void rlEnableColorBlend();                    // Enable color blending
fn void rlDisableColorBlend();                   // Disable color blending
fn void rlEnableDepthTest();                     // Enable depth test
fn void rlDisableDepthTest();                    // Disable depth test
fn void rlEnableDepthMask();                     // Enable depth write
fn void rlDisableDepthMask();                    // Disable depth write
fn void rlEnableBackfaceCulling();               // Enable backface culling
fn void rlDisableBackfaceCulling();              // Disable backface culling
fn void rlColorMask(bool r, bool g, bool b, bool a); // Color mask control
fn void rlSetCullFace(CInt mode);                     // Set face culling mode
fn void rlEnableScissorTest();                   // Enable scissor test
fn void rlDisableScissorTest();                  // Disable scissor test
fn void rlScissor(CInt x, CInt y, CInt width, CInt height); // Scissor test
fn void rlEnablePointMode();                     // Enable point mode
fn void rlDisablePointMode();                    // Disable point mode
fn void rlSetPointSize(float size);                  // Set the point drawing size
fn float rlGetPointSize();                       // Get the point drawing size
fn void rlEnableWireMode();                      // Enable wire mode
fn void rlDisableWireMode();                     // Disable wire mode
fn void rlSetLineWidth(float width);                 // Set the line drawing width
fn float rlGetLineWidth();                       // Get the line drawing width
fn void rlEnableSmoothLines();                   // Enable line aliasing
fn void rlDisableSmoothLines();                  // Disable line aliasing
fn void rlEnableStereoRender();                  // Enable stereo rendering
fn void rlDisableStereoRender();                 // Disable stereo rendering
fn bool rlIsStereoRenderEnabled();               // Check if stereo render is enabled

fn void rlClearColor(char r, char g, char b, char a); // Clear color buffer with color
fn void rlClearScreenBuffers();                  // Clear used screen buffers (color and depth)
fn void rlCheckErrors();                         // Check and log OpenGL error codes
fn void rlSetBlendMode(BlendMode mode);                    // Set blending mode
fn void rlSetBlendFactors(CInt glSrcFactor, CInt glDstFactor, CInt glEquation); // Set blending mode factor and equation (using OpenGL factors)
fn void rlSetBlendFactorsSeparate(CInt glSrcRGB, CInt glDstRGB, CInt glSrcAlpha, CInt glDstAlpha, CInt glEqRGB, CInt glEqAlpha); // Set blending mode factors and equations separately (using OpenGL factors)


//------------------------------------------------------------------------------------
// Functions Declaration - rlgl functionality
//------------------------------------------------------------------------------------
// rlgl initialization functions
fn void rlglInit(CInt width, CInt height);             // Initialize rlgl (buffers, shaders, textures, states)
fn void rlglClose();                             // De-initialize rlgl (buffers, shaders, textures)
fn void rlLoadExtensions(void *loader);              // Load OpenGL extensions (loader function required)
fn void *rlGetProcAddress(ZString procName);     // Get OpenGL procedure address
fn CInt rlGetVersion();                           // Get current OpenGL version
fn void rlSetFramebufferWidth(CInt width);            // Set current framebuffer width
fn CInt rlGetFramebufferWidth();                  // Get default framebuffer width
fn void rlSetFramebufferHeight(CInt height);          // Set current framebuffer height
fn CInt rlGetFramebufferHeight();                 // Get default framebuffer height

fn CUInt rlGetTextureIdDefault();         // Get default texture id
fn CUInt rlGetShaderIdDefault();          // Get default shader id
fn CInt *rlGetShaderLocsDefault();                // Get default shader locations

// Render batch management
// NOTE: rlgl provides a default render batch to behave like OpenGL 1.1 immediate mode
// but this render batch API is exposed in case of custom batches are required
fn void rlSetTexture(CUInt id);               // Set current texture for render batch and check buffers limits


// raymath.h
// Add two vectors (v1 + v2)
fn Vector2 vector2Add(Vector2 v1, Vector2 v2) @cname("Vector2Add");
// Add vector and float value
fn Vector2 vector2AddValue(Vector2 v, float add) @cname("Vector2AddValue");
// Calculate the signed angle from v1 to v2, relative to the origin (0, 0)
// NOTE: Coordinate system convention: positive X right, positive Y down,
// positive angles appear clockwise, and negative angles appear counterclockwise
fn float vector2Angle(Vector2 v1, Vector2 v2) @cname("Vector2Angle");
// Clamp the components of the vector between
// min and max values specified by the given vectors
fn Vector2 vector2Clamp(Vector2 v, Vector2 min, Vector2 max) @cname("Vector2Clamp");
// Clamp the magnitude of the vector between two min and max values
fn Vector2 vector2ClampValue(Vector2 v, float min, float max) @cname("Vector2ClampValue");
// Calculate two vectors cross product
fn float vector2CrossProduct(Vector2 v1, Vector2 v2) @cname("Vector2CrossProduct");
// Calculate distance between two vectors
fn float vector2Distance(Vector2 v1, Vector2 v2) @cname("Vector2Distance");
// Calculate square distance between two vectors
fn float vector2DistanceSqr(Vector2 v1, Vector2 v2) @cname("Vector2DistanceSqr");
// Divide vector by vector
fn Vector2 vector2Divide(Vector2 v1, Vector2 v2) @cname("Vector2Divide");
// Calculate two vectors dot product
fn float vector2DotProduct(Vector2 v1, Vector2 v2) @cname("Vector2DotProduct");
// Check whether two given vectors are almost equal
fn int vector2Equals(Vector2 p, Vector2 q) @cname("Vector2Equals");
// Invert the given vector
fn Vector2 vector2Invert(Vector2 v) @cname("Vector2Invert");
// Calculate vector length
fn float vector2Length(Vector2 v) @cname("Vector2Length");
// Calculate vector square length
fn float vector2LengthSqr(Vector2 v) @cname("Vector2LengthSqr");
// Calculate linear interpolation between two vectors
fn Vector2 vector2Lerp(Vector2 v1, Vector2 v2, float amount) @cname("Vector2Lerp");
// Calculate angle defined by a two vectors line
// NOTE: Parameters need to be normalized
// Current implementation should be aligned with glm::angle
fn float vector2LineAngle(Vector2 start, Vector2 end) @cname("Vector2LineAngle");
// Get max value for each pair of components
fn Vector2 vector2Max(Vector2 v1, Vector2 v2) @cname("Vector2Max");
// Get min value for each pair of components
fn Vector2 vector2Min(Vector2 v1, Vector2 v2) @cname("Vector2Min");
// Move Vector towards target
fn Vector2 vector2MoveTowards(Vector2 v, Vector2 target, float maxDistance) @cname("Vector2MoveTowards");
// Multiply vector by vector
fn Vector2 vector2Multiply(Vector2 v1, Vector2 v2) @cname("Vector2Multiply");
// Negate vector
fn Vector2 vector2Negate(Vector2 v) @cname("Vector2Negate");
// Normalize provided vector
fn Vector2 vector2Normalize(Vector2 v) @cname("Vector2Normalize");
// Vector with components value 1.0f
fn Vector2 vector2One() @cname("Vector2One");
// Calculate reflected vector to normal
fn Vector2 vector2Reflect(Vector2 v, Vector2 normal) @cname("Vector2Reflect");
// Compute the direction of a refracted ray
// v: normalized direction of the incoming ray
// n: normalized normal vector of the interface of two optical media
// r: ratio of the refractive index of the medium from where the ray comes
//    to the refractive index of the medium on the other side of the surface
fn Vector2 vector2Refract(Vector2 v, Vector2 n, float r) @cname("Vector2Refract");
// Rotate vector by angle
fn Vector2 vector2Rotate(Vector2 v, float angle) @cname("Vector2Rotate");
// Scale vector (multiply by value)
fn Vector2 vector2Scale(Vector2 v, float scale) @cname("Vector2Scale");
// Subtract two vectors (v1 - v2)
fn Vector2 vector2Subtract(Vector2 v1, Vector2 v2) @cname("Vector2Subtract");
// Subtract vector by float value
fn Vector2 vector2SubtractValue(Vector2 v, float sub) @cname("Vector2SubtractValue");
// Transforms a Vector2 by a given Matrix
fn Vector2 vector2Transform(Vector2 v, Matrix mat) @cname("Vector2Transform");
// Vector with components value 0.0f
fn Vector2 vector2Zero() @cname("Vector2Zero");

// Add two vectors
fn Vector3 vector3Add(Vector3 v1, Vector3 v2) @cname("Vector3Add");
// Add vector and float value
fn Vector3 vector3AddValue(Vector3 v, float add) @cname("Vector3AddValue");
// Calculate angle between two vectors
fn float vector3Angle(Vector3 v1, Vector3 v2) @cname("Vector3Angle");
// Compute barycenter coordinates (u, v, w) for point p with respect to triangle (a, b, c)
// NOTE: Assumes P is on the plane of the triangle
fn Vector3 vector3Barycenter(Vector3 p, Vector3 a, Vector3 b, Vector3 c) @cname("Vector3Barycenter");
// Clamp the components of the vector between
// min and max values specified by the given vectors
fn Vector3 vector3Clamp(Vector3 v, Vector3 min, Vector3 max) @cname("Vector3Clamp");
// Clamp the magnitude of the vector between two values
fn Vector3 vector3ClampValue(Vector3 v, float min, float max) @cname("Vector3ClampValue");
// Calculate two vectors cross product
fn Vector3 vector3CrossProduct(Vector3 v1, Vector3 v2) @cname("Vector3CrossProduct");
// Calculate cubic hermite interpolation between two vectors and their tangents
// as described in the GLTF 2.0 specification: https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#interpolation-cubic
fn Vector3 vector3CubicHermite(Vector3 v1, Vector3 tangent1, Vector3 v2, Vector3 tangent2, float amount) @cname("Vector3CubicHermite");
// Calculate square distance between two vectors
fn float vector3Distance(Vector3 v1, Vector3 v2) @cname("Vector3Distance");
// Calculate square distance between two vectors
fn float vector3DistanceSqr(Vector3 v1, Vector3 v2) @cname("Vector3DistanceSqr");
// Divide vector by vector
fn Vector3 vector3Divide(Vector3 v1, Vector3 v2) @cname("Vector3Divide");
// Calculate two vectors dot product
fn float vector3DotProduct(Vector3 v1, Vector3 v2) @cname("Vector3DotProduct");
// Check whether two given vectors are almost equal
fn int vector3Equals(Vector3 p, Vector3 q) @cname("Vector3Equals");
// Invert the given vector
fn Vector3 vector3Invert(Vector3 v) @cname("Vector3Invert");
// Calculate vector length
fn float vector3Length(Vector3 v) @cname("Vector3Length");
// Calculate vector square length
fn float vector3LengthSqr(Vector3 v) @cname("Vector3LengthSqr");
// Calculate linear interpolation between two vectors
fn Vector3 vector3Lerp(Vector3 v1, Vector3 v2, float amount) @cname("Vector3Lerp");
// Get max value for each pair of components
fn Vector3 vector3Max(Vector3 v1, Vector3 v2) @cname("Vector3Max");
// Get min value for each pair of components
fn Vector3 vector3Min(Vector3 v1, Vector3 v2) @cname("Vector3Min");
// Move Vector towards target
fn Vector3 vector3MoveTowards(Vector3 v, Vector3 target, float maxDistance) @cname("Vector3MoveTowards");
// Multiply vector by vector
fn Vector3 vector3Multiply(Vector3 v1, Vector3 v2) @cname("Vector3Multiply");
// Negate provided vector (invert direction)
fn Vector3 vector3Negate(Vector3 v) @cname("Vector3Negate");
// Normalize provided vector
fn Vector3 vector3Normalize(Vector3 v) @cname("Vector3Normalize");
// Vector with components value 1.0f
fn Vector3 vector3One() @cname("Vector3One");
// Orthonormalize provided vectors
// Makes vectors normalized and orthogonal to each other
// Gram-Schmidt function implementation
fn void vector3OrthoNormalize(Vector3 *v1, Vector3 *v2) @cname("Vector3OrthoNormalize");
// Calculate one vector perpendicular vector
fn Vector3 vector3Perpendicular(Vector3 v) @cname("Vector3Perpendicular");
//Calculate the projection of the vector v1 on to v2
fn Vector3 vector3Project(Vector3 v1, Vector3 v2) @cname("Vector3Project");
// Calculate reflected vector to normal
fn Vector3 vector3Reflect(Vector3 v, Vector3 normal) @cname("Vector3Reflect");
// Compute the direction of a refracted ray
// v: normalized direction of the incoming ray
// n: normalized normal vector of the interface of two optical media
// r: ratio of the refractive index of the medium from where the ray comes
//    to the refractive index of the medium on the other side of the surface
fn Vector3 vector3Refract(Vector3 v, Vector3 n, float r) @cname("Vector3Refract");
//Calculate the rejection of the vector v1 on to v2
fn Vector3 vector3Reject(Vector3 v1, Vector3 v2) @cname("Vector3Reject");
// Rotates a vector around an axis
fn Vector3 vector3RotateByAxisAngle(Vector3 v, Vector3 axis, float angle) @cname("Vector3RotateByAxisAngle");
// Transform a vector by quaternion rotation
fn Vector3 vector3RotateByQuaternion(Vector3 v, Quaternion q) @cname("Vector3RotateByQuaternion");
// Multiply vector by scalar
fn Vector3 vector3Scale(Vector3 v, float scalar) @cname("Vector3Scale");
// Subtract two vectors
fn Vector3 vector3Subtract(Vector3 v1, Vector3 v2) @cname("Vector3Subtract");
// Subtract vector by float value
fn Vector3 vector3SubtractValue(Vector3 v, float sub) @cname("Vector3SubtractValue");

// Get Vector3 as float array
// fn float3 vector3ToFloatV(Vector3 v) @cname("Vector3ToFloatV"); // ? float3 == float[<3>]

// Transforms a Vector3 by a given Matrix
fn Vector3 vector3Transform(Vector3 v, Matrix mat) @cname("Vector3Transform");
// Projects a Vector3 from screen space into object space
// NOTE: We are avoiding calling other raymath functions despite available
fn Vector3 vector3Unproject(Vector3 source, Matrix projection, Matrix view) @cname("Vector3Unproject");
// Vector with components value 0.0f
fn Vector3 vector3Zero() @cname("Vector3Zero");

fn Vector4 vector4Add(Vector4 v1, Vector4 v2) @cname("Vector4Add");
fn Vector4 vector4AddValue(Vector4 v, float add) @cname("Vector4AddValue");
// Calculate distance between two vectors
fn float vector4Distance(Vector4 v1, Vector4 v2) @cname("Vector4Distance");
// Calculate square distance between two vectors
fn float vector4DistanceSqr(Vector4 v1, Vector4 v2) @cname("Vector4DistanceSqr");
// Divide vector by vector
fn Vector4 vector4Divide(Vector4 v1, Vector4 v2) @cname("Vector4Divide");
fn float vector4DotProduct(Vector4 v1, Vector4 v2) @cname("Vector4DotProduct");
// Check whether two given vectors are almost equal
fn int vector4Equals(Vector4 p, Vector4 q) @cname("Vector4Equals");
// Invert the given vector
fn Vector4 vector4Invert(Vector4 v) @cname("Vector4Invert");
fn float vector4Length(Vector4 v) @cname("Vector4Length");
fn float vector4LengthSqr(Vector4 v) @cname("Vector4LengthSqr");
// Calculate linear interpolation between two vectors
fn Vector4 vector4Lerp(Vector4 v1, Vector4 v2, float amount) @cname("Vector4Lerp");
// Get max value for each pair of components
fn Vector4 vector4Max(Vector4 v1, Vector4 v2) @cname("Vector4Max");
// Get min value for each pair of components
fn Vector4 vector4Min(Vector4 v1, Vector4 v2) @cname("Vector4Min");
// Move Vector towards target
fn Vector4 vector4MoveTowards(Vector4 v, Vector4 target, float maxDistance) @cname("Vector4MoveTowards");
// Multiply vector by vector
fn Vector4 vector4Multiply(Vector4 v1, Vector4 v2) @cname("Vector4Multiply");
// Negate vector
fn Vector4 vector4Negate(Vector4 v) @cname("Vector4Negate");
// Normalize provided vector
fn Vector4 vector4Normalize(Vector4 v) @cname("Vector4Normalize");
fn Vector4 vector4One() @cname("Vector4One");
fn Vector4 vector4Scale(Vector4 v, float scale) @cname("Vector4Scale");
fn Vector4 vector4Subtract(Vector4 v1, Vector4 v2) @cname("Vector4Subtract");
fn Vector4 vector4SubtractValue(Vector4 v, float add) @cname("Vector4SubtractValue");
fn Vector4 vector4Zero() @cname("Vector4Zero");

// Add two matrices
fn Matrix matrixAdd(Matrix left, Matrix right) @cname("MatrixAdd");
// Decompose a transformation matrix into its rotational, translational and scaling components
fn void matrixDecompose(Matrix mat, Vector3 *translation, Quaternion *rotation, Vector3 *scale) @cname("MatrixDecompose");
// Compute matrix determinant
fn float matrixDeterminant(Matrix mat) @cname("MatrixDeterminant");
// Get perspective projection matrix
fn Matrix matrixFrustum(double left, double right, double bottom, double top, double nearPlane, double farPlane) @cname("MatrixFrustum");
// Get identity matrix
fn Matrix matrixIdentity() @cname("MatrixIdentity");
// Invert provided matrix
fn  Matrix matrixInvert(Matrix mat) @cname("MatrixInvert");
// Get camera look-at matrix (view matrix)
fn Matrix matrixLookAt(Vector3 eye, Vector3 target, Vector3 up) @cname("MatrixLookAt");
// Get two matrix multiplication
// NOTE: When multiplying matrices... the order matters!
fn Matrix matrixMultiply(Matrix left, Matrix right) @cname("MatrixMultiply");
// Get orthographic projection matrix
fn Matrix matrixOrtho(double left, double right, double bottom, double top, double nearPlane, double farPlane) @cname("MatrixOrtho");
// Get perspective projection matrix
// NOTE: Fovy angle must be provided in radians
fn Matrix matrixPerspective(double fovY, double aspect, double nearPlane, double farPlane) @cname("MatrixPerspective");
// Create rotation matrix from axis and angle
// NOTE: Angle should be provided in radians
fn Matrix matrixRotate(Vector3 axis, float angle) @cname("MatrixRotate");
// Get x-rotation matrix
// NOTE: Angle must be provided in radians
fn Matrix matrixRotateX(float angle) @cname("MatrixRotateX");
// Get zyx-rotation matrix
// NOTE: Angle must be provided in radians
fn Matrix matrixRotateXYZ(Vector3 angle) @cname("MatrixRotateXYZ");
// Get y-rotation matrix
// NOTE: Angle must be provided in radians
fn Matrix matrixRotateY(float angle) @cname("MatrixRotateY");
// Get z-rotation matrix
// NOTE: Angle must be provided in radians
fn Matrix matrixRotateZ(float angle) @cname("MatrixRotateZ");
// Get zyx-rotation matrix
// NOTE: Angle must be provided in radians
fn Matrix matrixRotateZYX(Vector3 angle) @cname("MatrixRotateZYX");
// Get scaling matrix
fn Matrix matrixScale(float x, float y, float z) @cname("MatrixScale");
// Subtract two matrices (left - right)
fn Matrix matrixSubtract(Matrix left, Matrix right) @cname("MatrixSubtract");

// Get float array of matrix data
// fn float16 matrixToFloatV(Matrix mat) @cname("MatrixToFloatV"); // float16 == float[<16>] ??

// Get the trace of the matrix (sum of the values along the diagonal)
fn float matrixTrace(Matrix mat) @cname("MatrixTrace");
// Get translation matrix
fn  Matrix matrixTranslate(float x, float y, float z) @cname("MatrixTranslate");
// Transposes provided matrix
fn Matrix matrixTranspose(Matrix mat) @cname("MatrixTranspose");

// Add two quaternions
fn Quaternion quaternionAdd(Quaternion q1, Quaternion q2) @cname("QuaternionAdd");
// Add quaternion and float value
fn Quaternion quaternionAddValue(Quaternion q, float add) @cname("QuaternionAddValue");
// Calculate quaternion cubic spline interpolation using Cubic Hermite Spline algorithm
// as described in the GLTF 2.0 specification: https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#interpolation-cubic
fn Quaternion quaternionCubicHermiteSpline(Quaternion q1, Quaternion outTangent1, Quaternion q2, Quaternion inTangent2, float t) @cname("QuaternionCubicHermiteSpline");
// Divide two quaternions
fn Quaternion quaternionDivide(Quaternion q1, Quaternion q2) @cname("QuaternionDivide");
// Check whether two given quaternions are almost equal
fn int quaternionEquals(Quaternion p, Quaternion q) @cname("QuaternionEquals");
// Get rotation quaternion for an angle and axis
// NOTE: Angle must be provided in radians
fn Quaternion quaternionFromAxisAngle(Vector3 axis, float angle) @cname("QuaternionFromAxisAngle");
// Get the quaternion equivalent to Euler angles
// NOTE: Rotation order is ZYX
fn Quaternion quaternionFromEuler(float pitch, float yaw, float roll) @cname("QuaternionFromEuler");
// Get a quaternion for a given rotation matrix
fn Quaternion quaternionFromMatrix(Matrix mat) @cname("QuaternionFromMatrix");
// Calculate quaternion based on the rotation from one vector to another
fn Quaternion quaternionFromVector3ToVector3(Vector3 from, Vector3 to) @cname("QuaternionFromVector3ToVector3");
// Get identity quaternion
fn Quaternion quaternionIdentity() @cname("QuaternionIdentity");
// Invert provided quaternion
fn Quaternion quaternionInvert(Quaternion q) @cname("QuaternionInvert");
// Computes the length of a quaternion
fn float quaternionLength(Quaternion q) @cname("QuaternionLength");
// Calculate linear interpolation between two quaternions
fn Quaternion quaternionLerp(Quaternion q1, Quaternion q2, float amount) @cname("QuaternionLerp");
// Calculate two quaternion multiplication
fn Quaternion quaternionMultiply(Quaternion q1, Quaternion q2) @cname("QuaternionMultiply");
// Calculate slerp-optimized interpolation between two quaternions
fn Quaternion quaternionNlerp(Quaternion q1, Quaternion q2, float amount) @cname("QuaternionNlerp");
// Normalize provided quaternion
fn Quaternion quaternionNormalize(Quaternion q) @cname("QuaternionNormalize");
// Scale quaternion by float value
fn Quaternion quaternionScale(Quaternion q, float mul) @cname("QuaternionScale");
// Calculates spherical linear interpolation between two quaternions
fn Quaternion quaternionSlerp(Quaternion q1, Quaternion q2, float amount) @cname("QuaternionSlerp");
// Subtract two quaternions
fn Quaternion quaternionSubtract(Quaternion q1, Quaternion q2) @cname("QuaternionSubtract");
// Subtract quaternion and float value
fn Quaternion quaternionSubtractValue(Quaternion q, float sub) @cname("QuaternionSubtractValue");
// Get the rotation angle and axis for a given quaternion
fn void quaternionToAxisAngle(Quaternion q, Vector3 *outAxis, float *outAngle) @cname("QuaternionToAxisAngle");
// Get the Euler angles equivalent to quaternion (roll, pitch, yaw)
// NOTE: Angles are returned in a Vector3 struct in radians
fn Vector3 quaternionToEuler(Quaternion q) @cname("QuaternionToEuler");
// Get a matrix for a given quaternion
fn Matrix quaternionToMatrix(Quaternion q) @cname("QuaternionToMatrix");
// Transform a quaternion given a transformation matrix
fn Quaternion quaternionTransform(Quaternion q, Matrix mat) @cname("QuaternionTransform");


// rcamera.h
// Moves the camera in its forward direction
fn void cameraMoveForward(Camera *camera, float distance, bool moveInWorldPlane) @cname("CameraMoveForward");
// Moves the camera target in its current right direction
fn void cameraMoveRight(Camera *camera, float distance, bool moveInWorldPlane) @cname("CameraMoveRight");
// Moves the camera position closer/farther to/from the camera target
fn void cameraMoveToTarget(Camera *camera, float delta) @cname("CameraMoveToTarget");
// Moves the camera in its up direction
fn void cameraMoveUp(Camera *camera, float distance) @cname("CameraMoveUp");
// Rotates the camera around its right vector, pitch is "looking up and down"
//  - lockView prevents camera overrotation (aka "somersaults")
//  - rotateAroundTarget defines if rotation is around target or around its position
//  - rotateUp rotates the up direction as well (typically only usefull in CAMERA_FREE)
// NOTE: angle must be provided in radians
fn void cameraPitch(Camera *camera, float angle, bool lockView, bool rotateAroundTarget, bool rotateUp) @cname("CameraPitch");
// Rotates the camera around its forward vector
// Roll is "turning your head sideways to the left or right"
// Note: angle must be provided in radians
fn void cameraRoll(Camera *camera, float angle) @cname("CameraRoll");
// Rotates the camera around its up vector
// Yaw is "looking left and right"
// If rotateAroundTarget is false, the camera rotates around its position
// Note: angle must be provided in radians
fn void cameraYaw(Camera *camera, float angle, bool rotateAroundTarget) @cname("CameraYaw");
