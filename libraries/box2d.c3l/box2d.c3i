// box2d.c3i
// Created 28/03/2025
// Originally by Hilário Martins @ https://github.com/HMart81

/*
	BASIC DOC:

	Based on box2d 3.0

==== Units ====
	Box2D works with floating point numbers and tolerances have to be used to make Box2D perform well.
	These tolerances have been tuned to work well with meters-kilogram-second (MKS) units.
	In particular, Box2D has been tuned to work well with moving shapes between 0.1 and 10 meters.
	So this means objects between soup cans and buses in size should work well.
	Static shapes may be up to 50 meters long without trouble. If you have a large world, you should split it up into multiple static bodies.

	Being a 2D physics engine, it is tempting to use pixels as your units.
	Unfortunately this will lead to a poor simulation and possibly weird behavior.
	An object of length 200 pixels would be seen by Box2D as the size of a 45 story building.

	******************************************************************************************
	* ‍Caution:                                                                            *
	* - Box2D is tuned for MKS units. Keep the size of moving objects larger than 10cm.      *
	*	You'll need to use some scaling system when you render your environment and actors.  *
	*	The Box2D samples application does this by using an OpenGL viewport transform.       *
	*	DO NOT USE PIXEL UNITS for box2D unless you understand the implications.             *
	* - Box2D uses radians, not degrees.                                                     *
	* - Box2D works best with world sizes less than 12 kilometers.                           *
	******************************************************************************************

	Hello World Example at @ https://box2d.org/documentation/hello.html#autotoc_md21
*/

module vendor::box2d::b2;


// region BASE

// if there's any desire to override the internal box2d memory allocator and assert function
alias B2AllocCallback  = fn void*(uint size, int alignment);
alias B2FreeCallback   = fn void(void* mem);
alias B2AssertCallback = fn int(ZString condition, ZString fileName, int lineNumber);

fn void setAllocator(B2AllocCallback* allocFcn, B2FreeCallback* freeFcn) @cname("b2SetAllocator");
fn int getByteCount()                                                    @cname("b2GetByteCount");
fn void setAssertFcn(B2AssertCallback* assertFcn)                        @cname("b2SetAssertFcn");

struct B2Version @compact
{
	int major;
	int minor;
	int revision;
}

fn B2Version getVersion() @cname("b2GetVersion");

// Timer for profiling. This has platform specific code and may not work on every platform.
struct B2Timer
{
	long  start      @if(env::WIN32);
	ulong start_sec  @if(env::LINUX || env::POSIX);
	ulong start_usec @if(env::LINUX || env::POSIX);
	int   dummy      @if(!env::WIN32 && !env::LINUX && !env::POSIX);
}

fn B2Timer createTimer() @cname("b2CreateTimer");
fn long getTicks(B2Timer* timer) @cname("b2GetTicks");
fn float getMilliseconds(B2Timer* timer) @cname("b2GetMilliseconds");
fn float getMillisecondsAndReset(B2Timer* timer) @cname("b2GetMillisecondsAndReset");
fn void sleepMilliseconds(int milliseconds) @cname("b2SleepMilliseconds");
fn void yield() @cname("b2Yield");

// Simple djb2 hash function for determinism testing
const B2_HASH_INIT = 5381;

alias UInt8 @local = char;
fn uint hash(uint hash, UInt8* data, int count) @cname("b2Hash");

// end_region BASE

// region ID

struct B2WorldId @compact
{
	ushort index1;
	ushort revision;
}

// Body id references a body instance. This should be treated as an opaque handle.
struct B2BodyId
{
	int index1;
	ushort revision;
	ushort world0;
}

struct B2ShapeId
{
	int index1;
	ushort world0;
	ushort revision;
}

struct B2JointId
{
	int index1;
	ushort world0;
	ushort revision;
}

struct B2ChainId
{
	int index1;
	ushort world0;
	ushort revision;
}

const B2WorldId NULL_WORLD_ID @local = {};
const B2BodyId  NULL_BODY_ID  @local = {};
const B2ShapeId NULL_SHAPE_ID @local = {};
const B2JointId NULL_JOINT_ID @local = {};
const B2ChainId NULL_CHAIN_ID @local = {};

macro bool @is_null(#id) => #id.index1 == 0;

macro bool @is_non_null(#id) => #id.index1 != 0;

macro bool @id_equals(#id1, #id2 ) => (#id1.index1 == #id2.index1 && #id1.world0 == #id2.world0 && #id1.revision == #id2.revision);

// end_region ID

// region TYPES

alias B2TaskCallback        = fn void(int startIndex, int endIndex, uint workerIndex, void* taskContext);
alias B2EnqueueTaskCallback = fn void*(B2TaskCallback* task, int itemCount, int minRange, void* taskContext, void* userContext);
alias B2FinishTaskCallback  = fn void(void* userTask, void* userContext);

struct B2RayResult
{
	B2ShapeId shapeId;
	B2Vec2 point;
	B2Vec2 normal;
	float fraction;
	bool hit;
}

/// World definition used to create a simulation world.
/// Must be initialized using defaultWorldDef().
struct B2WorldDef
{
	/// Gravity vector. Box2D has no up-vector defined.
	B2Vec2 gravity;

	/// Restitution velocity threshold, usually in m/s. Collisions above this
	/// speed have restitution applied (will bounce).
	float restitutionThreshold;

	/// This parameter controls how fast overlap is resolved and has units of meters per second
	float contactPushoutVelocity;

	/// Threshold velocity for hit events. Usually meters per second.
	float hitEventThreshold;

	/// Contact stiffness. Cycles per second.
	float contactHertz;

	/// Contact bounciness. Non-dimensional.
	float contactDampingRatio;

	/// Joint stiffness. Cycles per second.
	float jointHertz;

	/// Joint bounciness. Non-dimensional.
	float jointDampingRatio;

	/// Maximum linear velocity. Usually meters per second.
	float maximumLinearVelocity;

	/// Can bodies go to sleep to improve performance
	bool enableSleep;

	/// Enable continuous collision
	bool enableContinous;

	/// Number of workers to use with the provided task system. Box2D performs best when using only
	///	performance cores and accessing a single L2 cache. Efficiency cores and hyper-threading provide
	///	little benefit and may even harm performance.
	int workerCount;

	/// Function to spawn tasks
	B2EnqueueTaskCallback* enqueueTask;

	/// Function to finish a task
	B2FinishTaskCallback* finishTask;

	/// User context that is provided to enqueueTask and finishTask
	void* userTaskContext;

	/// Used internally to detect a valid definition. DO NOT SET.
	int internalValue;
}

enum B2BodyType
{
	/// zero mass, zero velocity, may be manually moved
	STATIC,

	/// zero mass, velocity set by user, moved by solver
	KINEMATIC,

	/// positive mass, velocity determined by forces, moved by solver
	DYNAMIC
}

/// A body definition holds all the data needed to construct a rigid body.
/// You can safely re-use body definitions. Shapes are added to a body after construction.
///	Body definitions are temporary objects used to bundle creation parameters.
/// Must be initialized using defaultBodyDef().
struct B2BodyDef
{
	/// The body type: static, kinematic, or dynamic.
	B2BodyType type;

	/// The initial world position of the body. Bodies should be created with the desired position.
	/// @note Creating bodies at the origin and then moving them nearly doubles the cost of body creation, especially
	///	if the body is moved after shapes have been added.
	B2Vec2 position;

	/// The initial world rotation of the body. Use b2MakeRot() if you have an angle.
	B2Rot rotation;

	/// The initial linear velocity of the body's origin. Typically in meters per second.
	B2Vec2 linearVelocity;

	/// The initial angular velocity of the body. Radians per second.
	float angularVelocity;

	/// Linear damping is use to reduce the linear velocity. The damping parameter
	/// can be larger than 1 but the damping effect becomes sensitive to the
	/// time step when the damping parameter is large.
	///	Generally linear damping is undesirable because it makes objects move slowly
	///	as if they are floating.
	float linearDamping;

	/// Angular damping is use to reduce the angular velocity. The damping parameter
	/// can be larger than 1.0f but the damping effect becomes sensitive to the
	/// time step when the damping parameter is large.
	///	Angular damping can be use slow down rotating bodies.
	float angularDamping;

	/// Scale the gravity applied to this body. Non-dimensional.
	float gravityScale;

	/// Sleep velocity threshold, default is 0.05 meter per second
	float sleepThreshold;

	/// Use this to store application specific body data.
	void* userData;

	/// Set this flag to false if this body should never fall asleep.
	bool enableSleep;

	/// Is this body initially awake or sleeping?
	bool isAwake;

	/// Should this body be prevented from rotating? Useful for characters.
	bool fixedRotation;

	/// Treat this body as high speed object that performs continuous collision detection
	/// against dynamic and kinematic bodies, but not other bullet bodies.
	///	@warning Bullets should be used sparingly. They are not a solution for general dynamic-versus-dynamic
	///	continuous collision. They may interfere with joint constraints.
	bool isBullet;

	/// Used to disable a body. A disabled body does not move or collide.
	bool isEnabled;

	/// Automatically compute mass and related properties on this body from shapes.
	/// Triggers whenever a shape is add/removed/changed. Default is true.
	bool automaticMass;

	/// This allows this body to bypass rotational speed limits. Should only be used
	///	for circular objects, like wheels.
	bool allowFastRotation;

	/// Used internally to detect a valid definition. DO NOT SET.
	int internalValue;
}

/// This is used to filter collision on shapes. It affects shape-vs-shape collision
///	and shape-versus-query collision (such as b2World_CastRay).
struct B2Filter @compact
{
	/// The collision category bits. Normally you would just set one bit. The category bits should
	/// represent your application object types. For example:
	/// @code{.cpp}
	/// enum MyCategories
	/// {
	///    Static  = 0x00000001,
	///    Dynamic = 0x00000002,
	///    Debris  = 0x00000004,
	///    Player  = 0x00000008,
	///    // etc
	/// };
	/// @endcode
	uint categoryBits;

	/// The collision mask bits. This states the categories that this
	/// shape would accept for collision.
	/// For example, you may want your player to only collide with static objects
	/// and other players.
	/// @code{.c}
	/// maskBits = Static | Player;
	/// @endcode
	uint maskBits;

	/// Collision groups allow a certain group of objects to never collide (negative)
	/// or always collide (positive). A group index of zero has no effect. Non-zero group filtering
	/// always wins against the mask bits.
	/// For example, you may want ragdolls to collide with other ragdolls but you don't want
	/// ragdoll self-collision. In this case you would give each ragdoll a unique negative group index
	/// and apply that group index to all shapes on the ragdoll.
	int groupIndex;
}

fn B2Filter defaultFilter() @cname("b2DefaultFilter");

/// The query filter is used to filter collisions between queries and shapes. For example,
/// you may want a ray-cast representing a projectile to hit players and the static environment
/// but not debris.
/// @ingroup shape
struct B2QueryFilter @compact
{
	/// The collision category bits of this query. Normally you would just set one bit.
	uint categoryBits;

	/// The collision mask bits. This states the shape categories that this
	/// query would accept for collision.
	uint maskBits;
}

/// Use this to initialize your query filter
fn B2QueryFilter defaultQueryFilter() @cname("b2DefaultQueryFilter");

enum B2ShapeType : int
{
	/// A circle with an offset
	CIRCLE,

	/// A capsule is an extruded circle
	CAPSULE,

	/// A line segment
	SEGMENT,

	/// A convex polygon
	POLYGON,

	/// A smooth segment owned by a chain shape
	SMOOTH_SEGMENT
}

/// Used to create a shape.
/// This is a temporary object used to bundle shape creation parameters. You may use
/// the same shape definition to create multiple shapes.
/// Must be initialized using defaultShapeDef().
struct B2ShapeDef
{
	/// Use this to store application specific shape data.
	void* userData;

	/// The Coulomb (dry) friction coefficient, usually in the range [0,1].
	float friction;

	/// The restitution (bounce) usually in the range [0,1].
	float restitution;

	/// The density, usually in kg/m^2.
	float density;

	/// Collision filtering data.
	B2Filter filter;

	/// Custom debug draw color.
	uint customColor;

	/// A sensor shape generates overlap events but never generates a collision response.
	bool isSensor;

	/// Enable sensor events for this shape. Only applies to kinematic and dynamic bodies. Ignored for sensors.
	bool enableSensorEvents;

	/// Enable contact events for this shape. Only applies to kinematic and dynamic bodies. Ignored for sensors.
	bool enableContactEvents;

	/// Enable hit events for this shape. Only applies to kinematic and dynamic bodies. Ignored for sensors.
	bool enableHitEvents;

	/// Enable pre-solve contact events for this shape. Only applies to dynamic bodies. These are expensive
	///	and must be carefully handled due to threading. Ignored for sensors.
	bool enablePreSolveEvents;

	/// Normally shapes on static bodies don't invoke contact creation when they are added to the world. This overrides
	///	that behavior and causes contact creation. This significantly slows down static body creation which can be important
	///	when there are many static shapes.
	bool forceContactCreation;

	/// Used internally to detect a valid definition. DO NOT SET.
	int internalValue;
}

struct B2ChainDef
{
	void* userData;
	B2Vec2* points;
	int count;
	float friction;
	float restitution;
	B2Filter filter;
	bool isLoop;
	int internalValue;
}

struct B2Profile @compact
{
	float step;
	float pairs;
	float collide;
	float solve;
	float buildIslands;
	float solveConstraints;
	float prepareTasks;
	float solverTasks;
	float prepareConstraints;
	float integrateVelocities;
	float warmStart;
	float solveVelocities;
	float integratePositions;
	float relaxVelocities;
	float applyRestitution;
	float storeImpulses;
	float finalizeBodies;
	float splitIslands;
	float sleepIslands;
	float hitEvents;
	float broadphase;
	float continuous;
}

struct B2Counters @compact
{
	int staticBodyCount;
	int bodyCount;
	int shapeCount;
	int contactCount;
	int jointCount;
	int islandCount;
	int stackUsed;
	int staticTreeHeight;
	int treeHeight;
	int byteCount;
	int taskCount;
	int[12] colorCounts;
}

enum B2JointType
{
	DISTANCE,
	MOTOR,
	MOUSE,
	PRISMATIC,
	REVOLUTE,
	WELD,
	WHEEL,
}

struct B2DistanceJointDef
{
	B2BodyId bodyIdA;
	B2BodyId bodyIdB;
	B2Vec2 localAnchorA;
	B2Vec2 localAnchorB;
	float length;
	bool enableSpring;
	float hertz;
	float dampingRatio;
	bool enableLimit;
	float minLength;
	float maxLength;
	bool enableMotor;
	float maxMotorForce;
	float motorSpeed;
	bool collideConnected;
	void* userData;
	int internalValue;
}

struct B2MotorJointDef
{
	B2BodyId bodyIdA;
	B2BodyId bodyIdB;
	B2Vec2 linearOffset;
	float angularOffset;
	float maxForce;
	float maxTorque;
	float correctionFactor;
	bool collideConnected;
	void* userData;
	int internalValue;
}

struct B2MouseJointDef
{
	B2BodyId bodyIdA;
	B2BodyId bodyIdB;
	B2Vec2 target;
	float hertz;
	float dampingRatio;
	float maxForce;
	bool collideConnected;
	void* userData;
	int internalValue;
}

struct B2PrismaticJointDef
{
	B2BodyId bodyIdA;
	B2BodyId bodyIdB;
	B2Vec2 localAnchorA;
	B2Vec2 localAnchorB;
	B2Vec2 localAxisA;
	float referenceAngle;
	bool enableSpring;
	float hertz;
	float dampingRatio;
	bool enableLimit;
	float lowerTranslation;
	float upperTranslation;
	bool enableMotor;
	float maxMotorForce;
	float motorSpeed;
	bool collideConnected;
	void* userData;
	int internalValue;
}

struct B2RevoluteJointDef
{
	B2BodyId bodyIdA;
	B2BodyId bodyIdB;
	B2Vec2 localAnchorA;
	B2Vec2 localAnchorB;
	float referenceAngle;
	bool enableSpring;
	float hertz;
	float dampingRatio;
	bool enableLimit;
	float lowerAngle;
	float upperAngle;
	bool enableMotor;
	float maxMotorTorque;
	float motorSpeed;
	float drawSize;
	bool collideConnected;
	void* userData;
	int internalValue;
}

struct B2WeldJointDef
{
	B2BodyId bodyIdA;
	B2BodyId bodyIdB;
	B2Vec2 localAnchorA;
	B2Vec2 localAnchorB;
	float referenceAngle;
	float linearHertz;
	float angularHertz;
	float linearDampingRatio;
	float angularDampingRatio;
	bool collideConnected;
	void* userData;
	int internalValue;
}

struct B2WheelJointDef
{
	B2BodyId bodyIdA;
	B2BodyId bodyIdB;
	B2Vec2 localAnchorA;
	B2Vec2 localAnchorB;
	B2Vec2 localAxisA;
	bool enableSpring;
	float hertz;
	float dampingRatio;
	bool enableLimit;
	float lowerTranslation;
	float upperTranslation;
	bool enableMotor;
	float maxMotorTorque;
	float motorSpeed;
	bool collideConnected;
	void* userData;
	int internalValue;
}

struct B2SensorBeginTouchEvent
{
	B2ShapeId sensorShapeId;
	B2ShapeId visitorShapeId;
}

struct B2SensorEndTouchEvent
{
	B2ShapeId sensorShapeId;
	B2ShapeId visitorShapeId;
}

struct B2SensorEvents
{
	B2SensorBeginTouchEvent* beginEvents;
	B2SensorEndTouchEvent* endEvents;
	int beginCount;
	int endCount;
}

struct B2ContactBeginTouchEvent
{
	B2ShapeId shapeIdA;
	B2ShapeId shapeIdB;
}

struct B2ContactEndTouchEvent
{
	B2ShapeId shapeIdA;
	B2ShapeId shapeIdB;
}

struct B2ContactHitEvent
{
	B2ShapeId shapeIdA;
	B2ShapeId shapeIdB;
	B2Vec2 point;
	B2Vec2 normal;
	float approachSpeed;
}

struct B2ContactEvents
{
	B2ContactBeginTouchEvent* beginEvents;
	B2ContactEndTouchEvent* endEvents;
	B2ContactHitEvent* hitEvents;
	int beginCount;
	int endCount;
	int hitCount;
}

struct B2BodyMoveEvent
{
	B2Transform transform;
	B2BodyId bodyId;
	void* userData;
	bool fellAsleep;
}

struct B2BodyEvents
{
	B2BodyMoveEvent* moveEvents;
	int moveCount;
}

struct B2ContactData
{
	B2ShapeId shapeIdA;
	B2ShapeId shapeIdB;
	B2Manifold manifold;
}

alias B2CustomFilterCallback  = fn bool(B2ShapeId shapeIdA, B2ShapeId shapeIdB, void* context);
alias B2PreSolveCallback      = fn bool(B2ShapeId shapeIdA, B2ShapeId shapeIdB, B2Manifold* manifold, void* context);
alias B2OverlapResultCallback = fn bool(B2ShapeId shapeId, void* context);
alias B2CastResultCallback    = fn float(B2ShapeId shapeId, B2Vec2 point, B2Vec2 normal, float fraction, void* context);


//=====================================================================================================
//                                  WORLD MODULE
//=====================================================================================================
module vendor::box2d::b2::b2world;
import vendor::box2d::b2::b2math;
fn B2WorldDef defaultDef() @cname("b2DefaultWorldDef");

<*
Create a world for rigid body simulation.
A world contains bodies, shapes, and constraints. You make create up to 128 worlds.
Each world is completely independent and may be simulated in parallel.

Returns
	the world id
*>
fn B2WorldId create(B2WorldDef* wdef) @cname("b2CreateWorld");
fn void destroy(B2WorldId worldId) @cname("b2DestroyWorld");

// world methods

// World id validation. Provides validation for up to 64K allocations.
fn bool B2WorldId.isValid(B2WorldId id) @cname("b2World_IsValid");
// Simulate a world for one time step.
fn void B2WorldId.step(B2WorldId worldId, float timeStep, int subStepCount) @cname("b2World_Step");
fn B2BodyEvents B2WorldId.getBodyEvents(B2WorldId worldId) @cname("b2World_GetBodyEvents");
fn B2SensorEvents B2WorldId.getSensorEvents(B2WorldId worldId) @cname("b2World_GetSensorEvents");
fn B2ContactEvents B2WorldId.getContactEvents(B2WorldId worldId) @cname("b2World_GetContactEvents");
fn void B2WorldId.overlapAABB(B2WorldId worldId, B2AABBox aabb, B2QueryFilter filter, B2OverlapResultCallback* fcn, void* context) @cname("b2World_OverlapAABB");
fn void B2WorldId.overlapCircle(B2WorldId worldId, B2Circle* circle, B2Transform transform, B2QueryFilter filter, B2OverlapResultCallback* fcn, void* context) @cname("b2World_OverlapCircle");
fn void B2WorldId.overlapCapsule(B2WorldId worldId, B2Capsule* capsule, B2Transform transform, B2QueryFilter filter, B2OverlapResultCallback* fcn, void* context) @cname("b2World_OverlapCapsule");
fn void B2WorldId.overlapPolygon(B2WorldId worldId, B2Polygon* polygon, B2Transform transform, B2QueryFilter filter, B2OverlapResultCallback* fcn, void* context) @cname("b2World_OverlapPolygon");
fn void B2WorldId.castRay(B2WorldId worldId, B2Vec2 origin, B2Vec2 translation, B2QueryFilter filter, B2CastResultCallback* fcn, void* context) @cname("b2World_CastRay");
fn B2RayResult B2WorldId.castRayClosest(B2WorldId worldId, B2Vec2 origin, B2Vec2 translation, B2QueryFilter filter) @cname("b2World_CastRayClosest");
fn void B2WorldId.castCircle(B2WorldId worldId, B2Circle* circle, B2Transform originTransform, B2Vec2 translation, B2QueryFilter filter, B2CastResultCallback* fcn, void* context) @cname("b2World_CastCircle");
fn void B2WorldId.castCapsule(B2WorldId worldId, B2Capsule* capsule, B2Transform originTransform, B2Vec2 translation, B2QueryFilter filter, B2CastResultCallback* fcn, void* context) @cname("b2World_CastCapsule");
fn void B2WorldId.castPolygon(B2WorldId worldId, B2Polygon* polygon, B2Transform originTransform, B2Vec2 translation, B2QueryFilter filter, B2CastResultCallback* fcn, void* context) @cname("b2World_CastPolygon");
fn void B2WorldId.enableSleeping(B2WorldId worldId, bool flag) @cname("b2World_EnableSleeping");
fn void B2WorldId.enableContinuous(B2WorldId worldId, bool flag) @cname("b2World_EnableContinuous");
fn void B2WorldId.setRestitutionThreshold(B2WorldId worldId, float value) @cname("b2World_SetRestitutionThreshold");
fn void B2WorldId.setHitEventThreshold(B2WorldId worldId, float value) @cname("b2World_SetHitEventThreshold");
fn void B2WorldId.setCustomFilterCallback(B2WorldId worldId, B2CustomFilterCallback* fcn, void* context) @cname("b2World_SetCustomFilterCallback");
fn void B2WorldId.setPreSolveCallback(B2WorldId worldId, B2PreSolveCallback* fcn, void* context) @cname("b2World_SetPreSolveCallback");
fn void B2WorldId.setGravity(B2WorldId worldId, B2Vec2 gravity) @cname("b2World_SetGravity");
fn B2Vec2 B2WorldId.getGravity(B2WorldId worldId) @cname("b2World_GetGravity");
fn void B2WorldId.explode(B2WorldId worldId, B2Vec2 position, float radius, float impulse) @cname("b2World_Explode");
fn void B2WorldId.setContactTuning(B2WorldId worldId, float hertz, float dampingRatio, float pushVelocity) @cname("b2World_SetContactTuning");
fn void B2WorldId.enableWarmStarting(B2WorldId worldId, bool flag) @cname("b2World_EnableWarmStarting");
fn B2Profile B2WorldId.getProfile(B2WorldId worldId) @cname("b2World_GetProfile");
fn B2Counters B2WorldId.getCounters(B2WorldId worldId) @cname("b2World_GetCounters");
fn void B2WorldId.dumpMemoryStats(B2WorldId worldId) @cname("b2World_DumpMemoryStats");

/// Call this to draw shapes and other debug draw data
fn void B2WorldId.debugDraw(B2WorldId worldId, B2DebugDraw* draw) @cname("b2World_Draw");

//=====================================================================================================
//                                  BODY MODULE
//=====================================================================================================
module vendor::box2d::b2::b2body;

import vendor::box2d::b2::b2math;

// Use this to initialize your body definition.
fn B2BodyDef defaultDef() @cname("b2DefaultBodyDef");

<*
Create a rigid body given a definition.
No reference to the definition is retained. So you can create the definition on the stack and pass it as a pointer.

ex:
B2BodyDef bodyDef  = b2body::defaultDef();
B2BodyId  myBodyId = b2body::create(myWorldId, &bodyDef);

Warning: b2body::create is locked during callbacks.
*>
fn B2BodyId create(B2WorldId worldId, B2BodyDef* bdef) @cname("b2CreateBody");
fn void destroy(B2BodyId bodyId) @cname("b2DestroyBody");

// body methods
fn bool B2BodyId.isValid(B2BodyId id) @cname("b2Body_IsValid");
fn B2BodyType B2BodyId.getType(B2BodyId bodyId) @cname("b2Body_GetType");
fn void B2BodyId.setType(B2BodyId bodyId, B2BodyType type) @cname("b2Body_SetType");
fn void B2BodyId.setUserData(B2BodyId bodyId, void* userData) @cname("b2Body_SetUserData");
fn void* B2BodyId.getUserData(B2BodyId bodyId) @cname("b2Body_GetUserData");
// Get the world position of a body. This is the location of the body origin.
fn B2Vec2 B2BodyId.getPosition(B2BodyId bodyId) @cname("b2Body_GetPosition");
// Get the world rotation of a body as a cosine/sine pair (complex number)
fn B2Rot B2BodyId.getRotation(B2BodyId bodyId) @cname("b2Body_GetRotation");
fn B2Transform B2BodyId.getTransform(B2BodyId bodyId) @cname("b2Body_GetTransform");
fn void B2BodyId.setTransform(B2BodyId bodyId, B2Vec2 position, B2Rot rotation) @cname("b2Body_SetTransform");
fn B2Vec2 B2BodyId.getLocalPoint(B2BodyId bodyId, B2Vec2 worldPoint) @cname("b2Body_GetLocalPoint");
// Get a world point on a body given a local point.
fn B2Vec2 B2BodyId.getWorldPoint(B2BodyId bodyId, B2Vec2 localPoint) @cname("b2Body_GetWorldPoint");
fn B2Vec2 B2BodyId.getLocalVector(B2BodyId bodyId, B2Vec2 worldVector) @cname("b2Body_GetLocalVector");
fn B2Vec2 B2BodyId.getWorldVector(B2BodyId bodyId, B2Vec2 localVector) @cname("b2Body_GetWorldVector");
fn B2Vec2 B2BodyId.getLinearVelocity(B2BodyId bodyId) @cname("b2Body_GetLinearVelocity");
fn float B2BodyId.getAngularVelocity(B2BodyId bodyId) @cname("b2Body_GetAngularVelocity");
fn void B2BodyId.setLinearVelocity(B2BodyId bodyId, B2Vec2 linearVelocity) @cname("b2Body_SetLinearVelocity");
fn void B2BodyId.setAngularVelocity(B2BodyId bodyId, float angularVelocity) @cname("b2Body_SetAngularVelocity");
fn void B2BodyId.applyForce(B2BodyId bodyId, B2Vec2 force, B2Vec2 point, bool wake) @cname("b2Body_ApplyForce");
fn void B2BodyId.applyForceToCenter(B2BodyId bodyId, B2Vec2 force, bool wake) @cname("b2Body_ApplyForceToCenter");
fn void B2BodyId.applyTorque(B2BodyId bodyId, float torque, bool wake) @cname("b2Body_ApplyTorque");
fn void B2BodyId.applyLinearImpulse(B2BodyId bodyId, B2Vec2 impulse, B2Vec2 point, bool wake) @cname("b2Body_ApplyLinearImpulse");
fn void B2BodyId.applyLinearImpulseToCenter(B2BodyId bodyId, B2Vec2 impulse, bool wake) @cname("b2Body_ApplyLinearImpulseToCenter");
fn void B2BodyId.applyAngularImpulse(B2BodyId bodyId, float impulse, bool wake) @cname("b2Body_ApplyAngularImpulse");
fn float B2BodyId.getMass(B2BodyId bodyId) @cname("b2Body_GetMass");
fn float B2BodyId.getRotationalInertia(B2BodyId bodyId) @cname("b2Body_GetRotationalInertia");
fn B2Vec2 B2BodyId.getLocalCenterOfMass(B2BodyId bodyId) @cname("b2Body_GetLocalCenterOfMass");
fn B2Vec2 B2BodyId.getWorldCenterOfMass(B2BodyId bodyId) @cname("b2Body_GetWorldCenterOfMass");
fn void B2BodyId.setMassData(B2BodyId bodyId, B2MassData massData) @cname("b2Body_SetMassData");
fn B2MassData B2BodyId.getMassData(B2BodyId bodyId) @cname("b2Body_GetMassData");
fn void B2BodyId.applyMassFromShapes(B2BodyId bodyId) @cname("b2Body_ApplyMassFromShapes");
fn void B2BodyId.setAutomaticMass(B2BodyId bodyId, bool automaticMass) @cname("b2Body_SetAutomaticMass");
fn bool B2BodyId.getAutomaticMass(B2BodyId bodyId) @cname("b2Body_GetAutomaticMass");
fn void B2BodyId.setLinearDamping(B2BodyId bodyId, float linearDamping) @cname("b2Body_SetLinearDamping");
fn float B2BodyId.getLinearDamping(B2BodyId bodyId) @cname("b2Body_GetLinearDamping");
fn void B2BodyId.setAngularDamping(B2BodyId bodyId, float angularDamping) @cname("b2Body_SetAngularDamping");
fn float B2BodyId.getAngularDamping(B2BodyId bodyId) @cname("b2Body_GetAngularDamping");
fn void B2BodyId.setGravityScale(B2BodyId bodyId, float gravityScale) @cname("b2Body_SetGravityScale");
fn float B2BodyId.getGravityScale(B2BodyId bodyId) @cname("b2Body_GetGravityScale");
fn bool B2BodyId.isAwake(B2BodyId bodyId) @cname("b2Body_IsAwake");
fn void B2BodyId.setAwake(B2BodyId bodyId, bool awake) @cname("b2Body_SetAwake");
fn void B2BodyId.enableSleep(B2BodyId bodyId, bool enableSleep) @cname("b2Body_EnableSleep");
fn bool B2BodyId.isSleepEnabled(B2BodyId bodyId) @cname("b2Body_IsSleepEnabled");
fn void B2BodyId.setSleepThreshold(B2BodyId bodyId, float sleepThreshold) @cname("b2Body_SetSleepThreshold");
fn float B2BodyId.getSleepThreshold(B2BodyId bodyId) @cname("b2Body_GetSleepThreshold");
fn bool B2BodyId.isEnabled(B2BodyId bodyId) @cname("b2Body_IsEnabled");
fn void B2BodyId.disable(B2BodyId bodyId) @cname("b2Body_Disable");
fn void B2BodyId.enable(B2BodyId bodyId) @cname("b2Body_Enable");
fn void B2BodyId.setFixedRotation(B2BodyId bodyId, bool flag) @cname("b2Body_SetFixedRotation");
fn bool B2BodyId.isFixedRotation(B2BodyId bodyId) @cname("b2Body_IsFixedRotation");
fn void B2BodyId.setBullet(B2BodyId bodyId, bool flag) @cname("b2Body_SetBullet");
fn bool B2BodyId.isBullet(B2BodyId bodyId) @cname("b2Body_IsBullet");
fn void B2BodyId.enableHitEvents(B2BodyId bodyId, bool enableHitEvents) @cname("b2Body_EnableHitEvents");
fn int B2BodyId.getShapeCount(B2BodyId bodyId) @cname("b2Body_GetShapeCount");
fn int B2BodyId.getShapes(B2BodyId bodyId, B2ShapeId* shapeArray, int capacity) @cname("b2Body_GetShapes");
fn int B2BodyId.getJointCount(B2BodyId bodyId) @cname("b2Body_GetJointCount");
fn int B2BodyId.getJoints(B2BodyId bodyId, B2JointId* jointArray, int capacity) @cname("b2Body_GetJoints");
fn int B2BodyId.getContactCapacity(B2BodyId bodyId) @cname("b2Body_GetContactCapacity");
fn int B2BodyId.getContactData(B2BodyId bodyId, B2ContactData* contactData, int capacity) @cname("b2Body_GetContactData");
fn B2AABBox B2BodyId.computeAABB(B2BodyId bodyId) @cname("b2Body_ComputeAABB");


//=====================================================================================================
//                                  SHAPE MODULE
//=====================================================================================================
module vendor::box2d::b2::b2shape;

import vendor::box2d::b2::b2math;

// Use this to initialize your shape definition.
fn B2ShapeDef defaultDef() @cname("b2DefaultShapeDef");

<*
Create a geometry shape and attach it to a body.
The shape definition and geometry are fully cloned. Contacts are not created until the next time step.

Returns
	the shape id for accessing the shape
*>
fn B2ShapeId createPolygon(B2BodyId bodyId, B2ShapeDef* sdef, B2Polygon* polygon) @cname("b2CreatePolygonShape");
fn B2ShapeId createCircle(B2BodyId bodyId, B2ShapeDef* sdef, B2Circle* circle) @cname("b2CreateCircleShape");
fn B2ShapeId createSegment(B2BodyId bodyId, B2ShapeDef* sdef, B2Segment* segment) @cname("b2CreateSegmentShape");
fn B2ShapeId createCapsule(B2BodyId bodyId, B2ShapeDef* sdef, B2Capsule* capsule) @cname("b2CreateCapsuleShape");

fn void destroy(B2ShapeId shapeId) @cname("b2DestroyShape");

// shape methods
fn bool B2ShapeId.isValid(B2ShapeId id) @cname("b2Shape_IsValid");
fn B2ShapeType B2ShapeId.getType(B2ShapeId shapeId) @cname("b2Shape_GetType");
fn B2BodyId B2ShapeId.getBody(B2ShapeId shapeId) @cname("b2Shape_GetBody");
fn bool B2ShapeId.isSensor(B2ShapeId shapeId) @cname("b2Shape_IsSensor");
fn void B2ShapeId.setUserData(B2ShapeId shapeId, void* userData) @cname("b2Shape_SetUserData");
fn void* B2ShapeId.getUserData(B2ShapeId shapeId) @cname("b2Shape_GetUserData");
fn void B2ShapeId.setDensity(B2ShapeId shapeId, float density) @cname("b2Shape_SetDensity");
fn float B2ShapeId.getDensity(B2ShapeId shapeId) @cname("b2Shape_GetDensity");
fn void B2ShapeId.setFriction(B2ShapeId shapeId, float friction) @cname("b2Shape_SetFriction");
fn float B2ShapeId.getFriction(B2ShapeId shapeId) @cname("b2Shape_GetFriction");
fn void B2ShapeId.setRestitution(B2ShapeId shapeId, float restitution) @cname("b2Shape_SetRestitution");
fn float B2ShapeId.getRestitution(B2ShapeId shapeId) @cname("b2Shape_GetRestitution");
fn B2Filter B2ShapeId.getFilter(B2ShapeId shapeId) @cname("b2Shape_GetFilter");
fn void B2ShapeId.setFilter(B2ShapeId shapeId, B2Filter filter) @cname("b2Shape_SetFilter");
fn void B2ShapeId.enableSensorEvents(B2ShapeId shapeId, bool flag) @cname("b2Shape_EnableSensorEvents");
fn bool B2ShapeId.areSensorEventsEnabled(B2ShapeId shapeId) @cname("b2Shape_AreSensorEventsEnabled");
fn void B2ShapeId.enableContactEvents(B2ShapeId shapeId, bool flag) @cname("b2Shape_EnableContactEvents");
fn bool B2ShapeId.areContactEventsEnabled(B2ShapeId shapeId) @cname("b2Shape_AreContactEventsEnabled");
fn void B2ShapeId.enablePreSolveEvents(B2ShapeId shapeId, bool flag) @cname("b2Shape_EnablePreSolveEvents");
fn bool B2ShapeId.arePreSolveEventsEnabled(B2ShapeId shapeId) @cname("b2Shape_ArePreSolveEventsEnabled");
fn void B2ShapeId.enableHitEvents(B2ShapeId shapeId, bool flag) @cname("b2Shape_EnableHitEvents");
fn bool B2ShapeId.areHitEventsEnabled(B2ShapeId shapeId) @cname("b2Shape_AreHitEventsEnabled");
fn bool B2ShapeId.testPoint(B2ShapeId shapeId, B2Vec2 point) @cname("b2Shape_TestPoint");
fn B2CastOutput B2ShapeId.rayCast(B2ShapeId shapeId, B2RayCastInput* input) @cname("b2Shape_RayCast");
fn B2Circle B2ShapeId.getCircle(B2ShapeId shapeId) @cname("b2Shape_GetCircle");
fn B2Segment B2ShapeId.getSegment(B2ShapeId shapeId) @cname("b2Shape_GetSegment");
fn B2ChainSegment B2ShapeId.getChainSegment(B2ShapeId shapeId) @cname("b2Shape_GetChainSegment");
fn B2Capsule B2ShapeId.getCapsule(B2ShapeId shapeId) @cname("b2Shape_GetCapsule");
fn B2Polygon B2ShapeId.getPolygon(B2ShapeId shapeId) @cname("b2Shape_GetPolygon");
fn void B2ShapeId.setCircle(B2ShapeId shapeId, B2Circle* circle) @cname("b2Shape_SetCircle");
fn void B2ShapeId.setCapsule(B2ShapeId shapeId, B2Capsule* capsule) @cname("b2Shape_SetCapsule");
fn void B2ShapeId.setSegment(B2ShapeId shapeId, B2Segment* segment) @cname("b2Shape_SetSegment");
fn void B2ShapeId.setPolygon(B2ShapeId shapeId, B2Polygon* polygon) @cname("b2Shape_SetPolygon");
fn B2ChainId B2ShapeId.getParentChain(B2ShapeId shapeId) @cname("b2Shape_GetParentChain");
fn int B2ShapeId.getContactCapacity(B2ShapeId shapeId) @cname("b2Shape_GetContactCapacity");
fn int B2ShapeId.getContactData(B2ShapeId shapeId, B2ContactData* contactData, int capacity) @cname("b2Shape_GetContactData");
fn B2AABBox B2ShapeId.getAABB(B2ShapeId shapeId) @cname("b2Shape_GetAABB");
fn B2Vec2 B2ShapeId.getClosestPoint(B2ShapeId shapeId, B2Vec2 target) @cname("b2Shape_GetClosestPoint");

//=====================================================================================================
//                                  CHAIN MODULE
//=====================================================================================================
module vendor::box2d::b2::b2chain;

// Use this to initialize your chain definition.
fn B2ChainDef defaultDef() @cname("b2DefaultChainDef");

fn B2ChainId create(B2BodyId bodyId, B2ChainDef* cdef) @cname("b2CreateChain");
fn void      destroy(B2ChainId chainId) @cname("b2DestroyChain");

// chain methods
fn void B2ChainId.setFriction(B2ChainId chainId, float friction) @cname("b2Chain_SetFriction");
fn void B2ChainId.setRestitution(B2ChainId chainId, float restitution) @cname("b2Chain_SetRestitution");
fn bool B2ChainId.isValid(B2ChainId id) @cname("b2Chain_IsValid");



// NOTE(HM)
//	Because there's more than one type of joint and all of them, share the same data structure,
//	I think would be hard to differentiate their functions, by turning them into methods,
//	so I decided to keep joints as simple functions, this way their module name can be used as a differentiator.

//=====================================================================================================
//                                  GLOBAL JOINT MODULE
//=====================================================================================================
module vendor::box2d::b2::b2joint;

import vendor::box2d::b2::b2math;

<*
	NOTE(HM):
	Even thou this is a seperate module, this functions work with all joints types...
	So for example you can use b2joint:: with a distance joint:

	B2DistanceJointDef dJointDef  = b2distanceJoint::defaultDef();
	B2JointId myDJointId          = b2distanceJoint::create(myWorldId, &dJointDef);

	if(b2joint::isValid(myDJointId)) {
		// do something
	}
	b2joint::destroy(myDJointId);

	etc,
*>

fn void destroy(B2JointId jointId) @cname("b2DestroyJoint");
fn bool isValid(B2JointId id) @cname("b2Joint_IsValid");
//
fn B2JointType getType(B2JointId jointId) @cname("b2Joint_GetType");
fn B2BodyId getBodyA(B2JointId jointId) @cname("b2Joint_GetBodyA");
fn B2BodyId getBodyB(B2JointId jointId) @cname("b2Joint_GetBodyB");
fn B2Vec2 getLocalAnchorA(B2JointId jointId) @cname("b2Joint_GetLocalAnchorA");
fn B2Vec2 getLocalAnchorB(B2JointId jointId) @cname("b2Joint_GetLocalAnchorB");
fn void setCollideConnected(B2JointId jointId, bool shouldCollide) @cname("b2Joint_SetCollideConnected");
fn bool getCollideConnected(B2JointId jointId) @cname("b2Joint_GetCollideConnected");
fn void setUserData(B2JointId jointId, void* userData) @cname("b2Joint_SetUserData");
fn void* getUserData(B2JointId jointId) @cname("b2Joint_GetUserData");
fn void wakeBodies(B2JointId jointId) @cname("b2Joint_WakeBodies");
fn B2Vec2 getConstraintForce(B2JointId jointId) @cname("b2Joint_GetConstraintForce");
fn float getConstraintTorque(B2JointId jointId) @cname("b2Joint_GetConstraintTorque");

//=====================================================================================================
//                                  DISTANCE JOINT MODULE
//=====================================================================================================
module vendor::box2d::b2::b2distjoint;

// Use this to initialize your distance joint definition.
fn B2DistanceJointDef defaultDef() @cname("b2DefaultDistanceJointDef");

fn B2JointId create(B2WorldId worldId, B2DistanceJointDef* ddef) @cname("b2CreateDistanceJoint");

fn void setLength(B2JointId jointId, float length) @cname("b2DistanceJoint_SetLength");
fn float getLength(B2JointId jointId) @cname("b2DistanceJoint_GetLength");
fn void enableSpring(B2JointId jointId, bool enableSpring) @cname("b2DistanceJoint_EnableSpring");
fn bool isSpringEnabled(B2JointId jointId) @cname("b2DistanceJoint_IsSpringEnabled");
fn void setSpringHertz(B2JointId jointId, float hertz) @cname("b2DistanceJoint_SetSpringHertz");
fn void setSpringDampingRatio(B2JointId jointId, float dampingRatio) @cname("b2DistanceJoint_SetSpringDampingRatio");
fn float getSpringHertz(B2JointId jointId) @cname("b2DistanceJoint_GetSpringHertz");
fn float getSpringDampingRatio(B2JointId jointId) @cname("b2DistanceJoint_GetSpringDampingRatio");
fn void enableLimit(B2JointId jointId, bool enableLimit) @cname("b2DistanceJoint_EnableLimit");
fn bool isLimitEnabled(B2JointId jointId) @cname("b2DistanceJoint_IsLimitEnabled");
fn void setLengthRange(B2JointId jointId, float minLength, float maxLength) @cname("b2DistanceJoint_SetLengthRange");
fn float getMinLength(B2JointId jointId) @cname("b2DistanceJoint_GetMinLength");
fn float getMaxLength(B2JointId jointId) @cname("b2DistanceJoint_GetMaxLength");
fn float getCurrentLength(B2JointId jointId) @cname("b2DistanceJoint_GetCurrentLength");
fn void enableMotor(B2JointId jointId, bool enableMotor) @cname("b2DistanceJoint_EnableMotor");
fn bool isMotorEnabled(B2JointId jointId) @cname("b2DistanceJoint_IsMotorEnabled");
fn void setMotorSpeed(B2JointId jointId, float motorSpeed) @cname("b2DistanceJoint_SetMotorSpeed");
fn float getMotorSpeed(B2JointId jointId) @cname("b2DistanceJoint_GetMotorSpeed");
fn void setMaxMotorForce(B2JointId jointId, float force) @cname("b2DistanceJoint_SetMaxMotorForce");
fn float getMaxMotorForce(B2JointId jointId) @cname("b2DistanceJoint_GetMaxMotorForce");
fn float getMotorForce(B2JointId jointId) @cname("b2DistanceJoint_GetMotorForce");


//=====================================================================================================
//                                  MOTOR JOINT MODULE
//=====================================================================================================
module vendor::box2d::b2::b2motorjoint;

import vendor::box2d::b2::b2math;

// Use this to initialize your motor joint definition.
fn B2MotorJointDef defaultDef() @cname("b2DefaultMotorJointDef");

fn B2JointId create(B2WorldId worldId, B2MotorJointDef* mdef) @cname("b2CreateMotorJoint");

fn void setLinearOffset(B2JointId jointId, B2Vec2 linearOffset) @cname("b2MotorJoint_SetLinearOffset");
fn B2Vec2 getLinearOffset(B2JointId jointId) @cname("b2MotorJoint_GetLinearOffset");
fn void setAngularOffset(B2JointId jointId, float angularOffset) @cname("b2MotorJoint_SetAngularOffset");
fn float getAngularOffset(B2JointId jointId) @cname("b2MotorJoint_GetAngularOffset");
fn void setMaxForce(B2JointId jointId, float maxForce) @cname("b2MotorJoint_SetMaxForce");
fn float getMaxForce(B2JointId jointId) @cname("b2MotorJoint_GetMaxForce");
fn void setMaxTorque(B2JointId jointId, float maxTorque) @cname("b2MotorJoint_SetMaxTorque");
fn float getMaxTorque(B2JointId jointId) @cname("b2MotorJoint_GetMaxTorque");
fn void setCorrectionFactor(B2JointId jointId, float correctionFactor) @cname("b2MotorJoint_SetCorrectionFactor");
fn float getCorrectionFactor(B2JointId jointId) @cname("b2MotorJoint_GetCorrectionFactor");

//=====================================================================================================
//                                  MOUSE JOINT MODULE
//=====================================================================================================
module vendor::box2d::b2::b2mousejoint;

import vendor::box2d::b2::b2math;

// Use this to initialize your mouse joint definition.
fn B2MouseJointDef defaultDef() @cname("b2DefaultMouseJointDef");

fn B2JointId create(B2WorldId worldId, B2MouseJointDef* mdef) @cname("b2CreateMouseJoint");

fn void setTarget(B2JointId jointId, B2Vec2 target) @cname("b2MouseJoint_SetTarget");
fn B2Vec2 getTarget(B2JointId jointId) @cname("b2MouseJoint_GetTarget");
fn void setSpringHertz(B2JointId jointId, float hertz) @cname("b2MouseJoint_SetSpringHertz");
fn float getSpringHertz(B2JointId jointId) @cname("b2MouseJoint_GetSpringHertz");
fn void setSpringDampingRatio(B2JointId jointId, float dampingRatio) @cname("b2MouseJoint_SetSpringDampingRatio");
fn float getSpringDampingRatio(B2JointId jointId) @cname("b2MouseJoint_GetSpringDampingRatio");
fn void setMaxForce(B2JointId jointId, float maxForce) @cname("b2MouseJoint_SetMaxForce");
fn float getMaxForce(B2JointId jointId) @cname("b2MouseJoint_GetMaxForce");

//=====================================================================================================
//                                  PRISMATIC JOINT MODULE
//=====================================================================================================
module vendor::box2d::b2::b2prismaticjoint;

// Use this to initialize your prismatic joint definition.
fn B2PrismaticJointDef defaultDef() @cname("b2DefaultPrismaticJointDef");

fn B2JointId create(B2WorldId worldId, B2PrismaticJointDef* pdef) @cname("b2CreatePrismaticJoint");

fn void enableSpring(B2JointId jointId, bool enableSpring) @cname("b2PrismaticJoint_EnableSpring");
fn bool isSpringEnabled(B2JointId jointId) @cname("b2PrismaticJoint_IsSpringEnabled");
fn void setSpringHertz(B2JointId jointId, float hertz) @cname("b2PrismaticJoint_SetSpringHertz");
fn float getSpringHertz(B2JointId jointId) @cname("b2PrismaticJoint_GetSpringHertz");
fn void setSpringDampingRatio(B2JointId jointId, float dampingRatio) @cname("b2PrismaticJoint_SetSpringDampingRatio");
fn float getSpringDampingRatio(B2JointId jointId) @cname("b2PrismaticJoint_GetSpringDampingRatio");
fn void enableLimit(B2JointId jointId, bool enableLimit) @cname("b2PrismaticJoint_EnableLimit");
fn bool isLimitEnabled(B2JointId jointId) @cname("b2PrismaticJoint_IsLimitEnabled");
fn float getLowerLimit(B2JointId jointId) @cname("b2PrismaticJoint_GetLowerLimit");
fn float getUpperLimit(B2JointId jointId) @cname("b2PrismaticJoint_GetUpperLimit");
fn void setLimits(B2JointId jointId, float lower, float upper) @cname("b2PrismaticJoint_SetLimits");
fn void enableMotor(B2JointId jointId, bool enableMotor) @cname("b2PrismaticJoint_EnableMotor");
fn bool isMotorEnabled(B2JointId jointId) @cname("b2PrismaticJoint_IsMotorEnabled");
fn void setMotorSpeed(B2JointId jointId, float motorSpeed) @cname("b2PrismaticJoint_SetMotorSpeed");
fn float getMotorSpeed(B2JointId jointId) @cname("b2PrismaticJoint_GetMotorSpeed");
fn void setMaxMotorForce(B2JointId jointId, float force) @cname("b2PrismaticJoint_SetMaxMotorForce");
fn float getMaxMotorForce(B2JointId jointId) @cname("b2PrismaticJoint_GetMaxMotorForce");
fn float getMotorForce(B2JointId jointId) @cname("b2PrismaticJoint_GetMotorForce");

//=====================================================================================================
//                                  REVOLUTE JOINT MODULE
//=====================================================================================================
module vendor::box2d::b2::b2revolutejoint;

// Use this to initialize your revolute joint definition.
fn B2RevoluteJointDef defaultDef() @cname("b2DefaultRevoluteJointDef");

fn B2JointId create(B2WorldId worldId, B2RevoluteJointDef* rdef) @cname("b2CreateRevoluteJoint");

fn void enableSpring(B2JointId jointId, bool enableSpring) @cname("b2RevoluteJoint_EnableSpring");
fn bool isSpringEnabled(B2JointId jointId) @cname("b2RevoluteJoint_IsSpringEnabled");
fn void setSpringHertz(B2JointId jointId, float hertz) @cname("b2RevoluteJoint_SetSpringHertz");
fn float getSpringHertz(B2JointId jointId) @cname("b2RevoluteJoint_GetSpringHertz");
fn void setSpringDampingRatio(B2JointId jointId, float dampingRatio) @cname("b2RevoluteJoint_SetSpringDampingRatio");
fn float getSpringDampingRatio(B2JointId jointId) @cname("b2RevoluteJoint_GetSpringDampingRatio");
fn float getAngle(B2JointId jointId) @cname("b2RevoluteJoint_GetAngle");
fn void enableLimit(B2JointId jointId, bool enableLimit) @cname("b2RevoluteJoint_EnableLimit");
fn bool isLimitEnabled(B2JointId jointId) @cname("b2RevoluteJoint_IsLimitEnabled");
fn float getLowerLimit(B2JointId jointId) @cname("b2RevoluteJoint_GetLowerLimit");
fn float getUpperLimit(B2JointId jointId) @cname("b2RevoluteJoint_GetUpperLimit");
fn void setLimits(B2JointId jointId, float lower, float upper) @cname("b2RevoluteJoint_SetLimits");
fn void enableMotor(B2JointId jointId, bool enableMotor) @cname("b2RevoluteJoint_EnableMotor");
fn bool isMotorEnabled(B2JointId jointId) @cname("b2RevoluteJoint_IsMotorEnabled");
fn void setMotorSpeed(B2JointId jointId, float motorSpeed) @cname("b2RevoluteJoint_SetMotorSpeed");
fn float getMotorSpeed(B2JointId jointId) @cname("b2RevoluteJoint_GetMotorSpeed");
fn float getMotorTorque(B2JointId jointId) @cname("b2RevoluteJoint_GetMotorTorque");
fn void setMaxMotorTorque(B2JointId jointId, float torque) @cname("b2RevoluteJoint_SetMaxMotorTorque");
fn float getMaxMotorTorque(B2JointId jointId) @cname("b2RevoluteJoint_GetMaxMotorTorque");

//=====================================================================================================
//                                  WELD JOINT MODULE
//=====================================================================================================
module vendor::box2d::b2::b2weldjoint;

// Use this to initialize your weld joint definition.
fn B2WeldJointDef defaultDef() @cname("b2DefaultWeldJointDef");

fn B2JointId create(B2WorldId worldId, B2WeldJointDef* wdef) @cname("b2CreateWeldJoint");

fn void setLinearHertz(B2JointId jointId, float hertz) @cname("b2WeldJoint_SetLinearHertz");
fn float getLinearHertz(B2JointId jointId) @cname("b2WeldJoint_GetLinearHertz");
fn void setLinearDampingRatio(B2JointId jointId, float dampingRatio) @cname("b2WeldJoint_SetLinearDampingRatio");
fn float getLinearDampingRatio(B2JointId jointId) @cname("b2WeldJoint_GetLinearDampingRatio");
fn void setAngularHertz(B2JointId jointId, float hertz) @cname("b2WeldJoint_SetAngularHertz");
fn float getAngularHertz(B2JointId jointId) @cname("b2WeldJoint_GetAngularHertz");
fn void setAngularDampingRatio(B2JointId jointId, float dampingRatio) @cname("b2WeldJoint_SetAngularDampingRatio");
fn float getAngularDampingRatio(B2JointId jointId) @cname("b2WeldJoint_GetAngularDampingRatio");

//=====================================================================================================
//                                  WHEEL JOINT MODULE
//=====================================================================================================
module vendor::box2d::b2::b2wheeljoint;

// Use this to initialize your wheel joint definition.
fn B2WheelJointDef defaultDef() @cname("b2DefaultWheelJointDef");

fn B2JointId create(B2WorldId worldId, B2WheelJointDef* wdef) @cname("b2CreateWheelJoint");

fn void enableSpring(B2JointId jointId, bool enableSpring) @cname("b2WheelJoint_EnableSpring");
fn bool isSpringEnabled(B2JointId jointId) @cname("b2WheelJoint_IsSpringEnabled");
fn void setSpringHertz(B2JointId jointId, float hertz) @cname("b2WheelJoint_SetSpringHertz");
fn float getSpringHertz(B2JointId jointId) @cname("b2WheelJoint_GetSpringHertz");
fn void setSpringDampingRatio(B2JointId jointId, float dampingRatio) @cname("b2WheelJoint_SetSpringDampingRatio");
fn float getSpringDampingRatio(B2JointId jointId) @cname("b2WheelJoint_GetSpringDampingRatio");
fn void enableLimit(B2JointId jointId, bool enableLimit) @cname("b2WheelJoint_EnableLimit");
fn bool isLimitEnabled(B2JointId jointId) @cname("b2WheelJoint_IsLimitEnabled");
fn float getLowerLimit(B2JointId jointId) @cname("b2WheelJoint_GetLowerLimit");
fn float getUpperLimit(B2JointId jointId) @cname("b2WheelJoint_GetUpperLimit");
fn void setLimits(B2JointId jointId, float lower, float upper) @cname("b2WheelJoint_SetLimits");
fn void enableMotor(B2JointId jointId, bool enableMotor) @cname("b2WheelJoint_EnableMotor");
fn bool isMotorEnabled(B2JointId jointId) @cname("b2WheelJoint_IsMotorEnabled");
fn void setMotorSpeed(B2JointId jointId, float motorSpeed) @cname("b2WheelJoint_SetMotorSpeed");
fn float getMotorSpeed(B2JointId jointId) @cname("b2WheelJoint_GetMotorSpeed");
fn void setMaxMotorTorque(B2JointId jointId, float torque) @cname("b2WheelJoint_SetMaxMotorTorque");
fn float getMaxMotorTorque(B2JointId jointId) @cname("b2WheelJoint_GetMaxMotorTorque");
fn float getMotorTorque(B2JointId jointId) @cname("b2WheelJoint_GetMotorTorque");

// end_region TYPES


// region COLLISION
//=====================================================================================================
//                                  B2 MODULE (B)
//=====================================================================================================
module vendor::box2d::b2;

/// The maximum number of vertices on a convex polygon. Changing this affects performance even if you
/// don't use more vertices.
const MAX_POLYGON_VERTICES = 8;

struct B2RayCastInput
{
	B2Vec2 origin;
	B2Vec2 translation;
	float maxFraction;
}

struct B2ShapeCastInput
{
	B2Vec2[MAX_POLYGON_VERTICES] points;
	int count;
	float radius;
	B2Vec2 translation;
	float maxFraction;
}

struct B2CastOutput
{
	B2Vec2 normal;
	B2Vec2 point;
	float fraction;
	int iterations;
	bool hit;
}

struct B2MassData
{
	float mass;
	B2Vec2 center;
	float rotationalInertia;
}

struct B2Circle
{
	B2Vec2 center;
	float radius;
}

struct B2Capsule
{
	B2Vec2 center1;

	B2Vec2 center2;

	float radius;
}

/// A solid convex polygon. It is assumed that the interior of the polygon is to
/// the left of each edge.
/// Polygons have a maximum number of vertices equal to MAX_POLYGON_VERTICES.
/// In most cases you should not need many vertices for a convex polygon.
/// @warning DO NOT fill this out manually, instead use a helper function like
/// makePolygon or makeBox.
struct B2Polygon
{
	/// The polygon vertices
	B2Vec2[MAX_POLYGON_VERTICES] vertices;
	/// The outward normal vectors of the polygon sides
	B2Vec2[MAX_POLYGON_VERTICES] normals;
	/// The centroid of the polygon
	B2Vec2 centroid;
	/// The external radius for rounded polygons
	float radius;
	/// The number of polygon vertices
	int count;
}

struct B2Segment
{
	B2Vec2 point1;
	B2Vec2 point2;
}

struct B2ChainSegment
{
	B2Vec2 ghost1;
	B2Segment segment;
	B2Vec2 ghost2;
	int chainId;
}

/// Helper functions
fn bool isValidRay(B2RayCastInput* input) @cname("b2IsValidRay");
//
fn B2Polygon makePolygon(B2Hull* hull, float radius) @cname("b2MakePolygon");
fn B2Polygon makeOffsetPolygon(B2Hull* hull, float radius, B2Transform transform) @cname("b2MakeOffsetPolygon");
// Make a square polygon, bypassing the need for a convex hull.
fn B2Polygon makeSquare(float h) @cname("b2MakeSquare");
// Make a box (rectangle) polygon, bypassing the need for a convex hull.
fn B2Polygon makeBox(float hx, float hy) @cname("b2MakeBox");
fn B2Polygon makeRoundedBox(float hx, float hy, float radius) @cname("b2MakeRoundedBox");
fn B2Polygon makeOffsetBox(float hx, float hy, B2Vec2 center, B2Rot rotation) @cname("b2MakeOffsetBox");
//
fn B2Polygon transformPolygon(B2Transform transform, B2Polygon* polygon) @cname("b2TransformPolygon");
//
fn B2MassData computeCircleMass(B2Circle* shape, float density) @cname("b2ComputeCircleMass");
fn B2MassData computeCapsuleMass(B2Capsule* shape, float density) @cname("b2ComputeCapsuleMass");
fn B2MassData computePolygonMass(B2Polygon* shape, float density) @cname("b2ComputePolygonMass");
fn B2AABBox computeCircleAABB(B2Circle* shape, B2Transform transform) @cname("b2ComputeCircleAABB");
fn B2AABBox computeCapsuleAABB(B2Capsule* shape, B2Transform transform) @cname("b2ComputeCapsuleAABB");
fn B2AABBox computePolygonAABB(B2Polygon* shape, B2Transform transform) @cname("b2ComputePolygonAABB");
fn B2AABBox computeSegmentAABB(B2Segment* shape, B2Transform transform) @cname("b2ComputeSegmentAABB");
//
fn bool pointInCircle(B2Vec2 point, B2Circle* shape) @cname("b2PointInCircle");
fn bool pointInCapsule(B2Vec2 point, B2Capsule* shape) @cname("b2PointInCapsule");
fn bool pointInPolygon(B2Vec2 point, B2Polygon* shape) @cname("b2PointInPolygon");
//
fn B2CastOutput rayCastCircle(B2RayCastInput* input, B2Circle* shape) @cname("b2RayCastCircle");
fn B2CastOutput rayCastCapsule(B2RayCastInput* input, B2Capsule* shape) @cname("b2RayCastCapsule");
fn B2CastOutput rayCastSegment(B2RayCastInput* input, B2Segment* shape, bool oneSided) @cname("b2RayCastSegment");
fn B2CastOutput rayCastPolygon(B2RayCastInput* input, B2Polygon* shape) @cname("b2RayCastPolygon");
//
fn B2CastOutput shapeCastCircle(B2ShapeCastInput* input, B2Circle* shape) @cname("b2ShapeCastCircle");
fn B2CastOutput shapeCastCapsule(B2ShapeCastInput* input, B2Capsule* shape) @cname("b2ShapeCastCapsule");
fn B2CastOutput shapeCastSegment(B2ShapeCastInput* input, B2Segment* shape) @cname("b2ShapeCastSegment");
fn B2CastOutput shapeCastPolygon(B2ShapeCastInput* input, B2Polygon* shape) @cname("b2ShapeCastPolygon");
///

struct B2Hull
{
	B2Vec2[MAX_POLYGON_VERTICES] points;
	int count;
}

fn B2Hull computeHull(B2Vec2* points, int count) @cname("b2ComputeHull");
fn bool validateHull(B2Hull* hull) @cname("b2ValidateHull");

struct B2SegmentDistanceResult @compact
{
	B2Vec2 closest1;
	B2Vec2 closest2;
	float fraction1;
	float fraction2;
	float distanceSquared;
}

fn B2SegmentDistanceResult segmentDistance(B2Vec2 p1, B2Vec2 q1, B2Vec2 p2, B2Vec2 q2) @cname("b2SegmentDistance");

struct B2DistanceProxy
{
	B2Vec2[MAX_POLYGON_VERTICES] points;
	int count;
	float radius;
}

struct B2DistanceCache
{
	short count;
	char[3] indexA;
	char[3] indexB;
}

// NOTE(HM) c3 is a zero initialized language by default.
// So I'm not sure if this is really needed but it exists in the C based box2d library...
const B2DistanceCache EMPTY_DISTANCE_CACHE = {};

struct B2DistanceInput
{
	B2DistanceProxy proxyA;
	B2DistanceProxy proxyB;
	B2Transform transformA;
	B2Transform transformB;
	bool useRadii;
}

struct B2DistanceOutput
{
	B2Vec2 pointA;
	B2Vec2 pointB;
	float distance;
	int iterations;
	int simplexCount;
}

struct B2SimplexVertex
{
	B2Vec2 wA;
	B2Vec2 wB;
	B2Vec2 w;
	float a;
	int indexA;
	int indexB;
}

struct B2Simplex
{
	B2SimplexVertex v1, v2, v3;
	int count;
}

fn B2DistanceOutput shapeDistance(B2DistanceCache* cache, B2DistanceInput* input, B2Simplex* simplexes, int simplexCapacity) @cname("b2ShapeDistance");

struct B2ShapeCastPairInput
{
	B2DistanceProxy proxyA;
	B2DistanceProxy proxyB;
	B2Transform transformA;
	B2Transform transformB;
	B2Vec2 translationB;
	float maxFraction;
}

fn B2CastOutput shapeCast(B2ShapeCastPairInput* input) @cname("b2ShapeCast");
fn B2DistanceProxy makeProxy(B2Vec2* vertices, int count, float radius) @cname("b2MakeProxy");

struct B2Sweep @compact
{
	B2Vec2 localCenter;
	B2Vec2 c1;
	B2Vec2 c2;
	B2Rot q1;
	B2Rot q2;
}

fn B2Transform getSweepTransform(B2Sweep* sweep, float time) @cname("b2GetSweepTransform");

struct B2TOIInput
{
	B2DistanceProxy proxyA;
	B2DistanceProxy proxyB;
	B2Sweep sweepA;
	B2Sweep sweepB;
	float tMax;
}

enum B2TOIState
{
	UNKNOWN,
	FAILED,
	OVERLAPPED,
	HIT,
	SEPARATED
}

struct B2TOIOutput
{
	B2TOIState state;
	float t;
}

fn B2TOIOutput timeOfImpact(B2TOIInput* input) @cname("b2TimeOfImpact");

struct B2ManifoldPoint
{
	B2Vec2 point;
	B2Vec2 anchorA;
	B2Vec2 anchorB;
	float separation;
	float normalImpulse;
	float tangentImpulse;
	float maxNormalImpulse;
	float normalVelocity;
	ushort id;
	bool persisted;
}

struct B2Manifold
{
	B2ManifoldPoint[2] points;
	B2Vec2 normal;
	int pointCount;
}

//=====================================================================================================
//                                  COLLIDE MODULE
//=====================================================================================================
module vendor::box2d::b2::b2collide;

import vendor::box2d::b2::b2math;

fn B2Manifold circles(B2Circle* circleA, B2Transform xfA, B2Circle* circleB, B2Transform xfB) @cname("b2CollideCircles");
fn B2Manifold capsuleAndCircle(B2Capsule* capsuleA, B2Transform xfA, B2Circle* circleB, B2Transform xfB) @cname("b2CollideCapsuleAndCircle");
fn B2Manifold segmentAndCircle(B2Segment* segmentA, B2Transform xfA, B2Circle* circleB, B2Transform xfB) @cname("b2CollideSegmentAndCircle");
fn B2Manifold polygonAndCircle(B2Polygon* polygonA, B2Transform xfA, B2Circle* circleB, B2Transform xfB) @cname("b2CollidePolygonAndCircle");
fn B2Manifold capsules(B2Capsule* capsuleA, B2Transform xfA, B2Capsule* capsuleB, B2Transform xfB) @cname("b2CollideCapsules");
fn B2Manifold segmentAndCapsule(B2Segment* segmentA, B2Transform xfA, B2Capsule* capsuleB, B2Transform xfB) @cname("b2CollideSegmentAndCapsule");
fn B2Manifold polygonAndCapsule(B2Polygon* polygonA, B2Transform xfA, B2Capsule* capsuleB, B2Transform xfB) @cname("b2CollidePolygonAndCapsule");
fn B2Manifold polygons(B2Polygon* polygonA, B2Transform xfA, B2Polygon* polygonB, B2Transform xfB) @cname("b2CollidePolygons");
fn B2Manifold segmentAndPolygon(B2Segment* segmentA, B2Transform xfA, B2Polygon* polygonB, B2Transform xfB) @cname("b2CollideSegmentAndPolygon");
fn B2Manifold chainSegmentAndCircle(B2ChainSegment* segmentA, B2Transform xfA, B2Circle* circleB, B2Transform xfB) @cname("b2CollideChainSegmentAndCircle");
fn B2Manifold chainSegmentAndCapsule(B2ChainSegment* segmentA, B2Transform xfA, B2Capsule* capsuleB, B2Transform xfB, B2DistanceCache* cache) @cname("b2CollideChainSegmentAndCapsule");
fn B2Manifold chainSegmentAndPolygon(B2ChainSegment* segmentA, B2Transform xfA, B2Polygon* polygonB, B2Transform xfB, B2DistanceCache* cache) @cname("b2CollideChainSegmentAndPolygon");


//=====================================================================================================
//                                  B2 MODULE (C)
//=====================================================================================================
module vendor::box2d::b2;

const DEFAULT_CATEGORY_BITS = 1;
const DEFAULT_MASK_BITS     = ulong.max; //(UINT64_MAX )

struct B2TreeNode
{
	B2AABBox aabb;
	ulong categoryBits;
	union
	{
		int parent;
		int next;
	}
	int child1;
	int child2;
	int userData;
	short height;
	bool enlarged;
	CChar[5] pad; // NOTE(HM) ignore just here to keep struct alignment...
}

struct B2DynamicTree
{
	B2TreeNode* nodes;
	int root;
	int nodeCount;
	int nodeCapacity;
	int freeList;
	int proxyCount;
	int* leafIndices;
	B2AABBox* leafBoxes;
	B2Vec2* leafCenters;
	int* binIndices;
	int rebuildCapacity;
}

//=====================================================================================================
//                                  DYNAMIC TREE MODULE
//=====================================================================================================
module vendor::box2d::b2::b2dyntree;

import vendor::box2d::b2::b2math;

fn B2DynamicTree create() @cname("b2DynamicTree_Create");

fn void B2DynamicTree.destroy(B2DynamicTree* tree) @cname("b2DynamicTree_Destroy");
fn int B2DynamicTree.createProxy(B2DynamicTree* tree, B2AABBox aabb, ulong categoryBits, int userData) @cname("b2DynamicTree_CreateProxy");
fn void B2DynamicTree.destroyProxy(B2DynamicTree* tree, int proxyId) @cname("b2DynamicTree_DestroyProxy");
fn void B2DynamicTree.moveProxy(B2DynamicTree* tree, int proxyId, B2AABBox aabb) @cname("b2DynamicTree_MoveProxy");
fn void B2DynamicTree.enlargeProxy(B2DynamicTree* tree, int proxyId, B2AABBox aabb) @cname("b2DynamicTree_EnlargeProxy");

alias B2TreeQueryCallback = fn bool(int proxyId, int userData, void* context);

fn void B2DynamicTree.query(B2DynamicTree* tree, B2AABBox aabb, ulong maskBits, B2TreeQueryCallback* callback, void* context) @cname("b2DynamicTree_Query");

alias B2TreeRayCastCallback = fn float(B2RayCastInput* input, int proxyId, int userData, void* context);

fn void B2DynamicTree.rayCast(B2DynamicTree* tree, B2RayCastInput* input, ulong maskBits, B2TreeRayCastCallback* callback, void* context) @cname("b2DynamicTree_RayCast");

alias B2TreeShapeCastCallback = fn float(B2ShapeCastInput* input, int proxyId, int userData, void* context);

fn void B2DynamicTree.shapeCast(B2DynamicTree* tree, B2ShapeCastInput* input, ulong maskBits, B2TreeShapeCastCallback* callback, void* context) @cname("b2DynamicTree_ShapeCast");
fn void B2DynamicTree.validate(B2DynamicTree* tree) @cname("b2DynamicTree_Validate");
fn int B2DynamicTree.getHeight(B2DynamicTree* tree) @cname("b2DynamicTree_GetHeight");
fn int B2DynamicTree.getMaxBalance(B2DynamicTree* tree) @cname("b2DynamicTree_GetMaxBalance");
fn float B2DynamicTree.getAreaRatio(B2DynamicTree* tree) @cname("b2DynamicTree_GetAreaRatio");
fn void B2DynamicTree.rebuildBottomUp(B2DynamicTree* tree) @cname("b2DynamicTree_RebuildBottomUp");
fn int B2DynamicTree.getProxyCount(B2DynamicTree* tree) @cname("b2DynamicTree_GetProxyCount");
fn int B2DynamicTree.rebuild(B2DynamicTree* tree, bool fullBuild) @cname("b2DynamicTree_Rebuild");
fn void B2DynamicTree.shiftOrigin(B2DynamicTree* tree, B2Vec2 newOrigin) @cname("b2DynamicTree_ShiftOrigin");
fn int B2DynamicTree.getByteCount(B2DynamicTree* tree) @cname("b2DynamicTree_GetByteCount");

// end_region COLLISION


// region MATH
//=====================================================================================================
//                                  B2 MATH MODULE
//=====================================================================================================
module vendor::box2d::b2::b2math;

alias B2Vec2 = float[2]; // NOTE(HM) to support C3 vector math using (float[<2>])

struct B2Rot @compact
{
	float c; // cosine and sine
	float s;
}

/// A 2D rigid transform
struct B2Transform
{
	B2Vec2 p;
	B2Rot q;
}

struct B2Mat22 @compact
{
	B2Vec2 cx, cy;
}

struct B2AABBox @compact
{
	B2Vec2 lowerBound;
	B2Vec2 upperBound;
}

const B2Vec2 VEC2_ZERO    = { 0.0f, 0.0f };
const B2Rot ROT_IDENTITY = { 1.0f, 0.0f };
const B2Transform TRANSFORM_IDENTITY = { { 0.0f, 0.0f }, { 1.0f, 0.0f } };
const B2Mat22 MAT22_ZERO  = { { 0.0f, 0.0f }, { 0.0f, 0.0f } };

// WARNING(HM) Most math functions are not accesible, at lest on box2d 3.0 static library,
// function symbols (func names) are not exported in the library, this may or may not change
// in future box2d versions, for now I recomend using C3 math functions (or others) when possible.

// Compute an approximate arctangent in the range [-pi, pi] This is hand coded for cross platform determinism.
fn float atan2(float y, float x) @cname("b2Atan2");
fn bool isValid(float a) @cname("b2IsValid");
fn bool vec2_IsValid(B2Vec2 v) @cname("b2Vec2_IsValid");
fn bool rot_IsValid(B2Rot q) @cname("b2Rot_IsValid");
fn bool aabb_IsValid(B2AABBox aabb) @cname("b2AABB_IsValid");
<*
Box2D bases all length units on meters, but you may need different units for your game.
You can set this value to use different units. This should be done at application startup and only modified once. Default value is 1.

Warning
	This must be modified before any calls to Box2D
*>
fn void  setLengthUnitsPerMeter(float lengthUnits) @cname("b2SetLengthUnitsPerMeter");
fn float getLengthUnitsPerMeter() @cname("b2GetLengthUnitsPerMeter");

// end_region MATH


// region DEBUG

//=====================================================================================================
//                                  B2 MODULE (D)
//=====================================================================================================
module vendor::box2d::b2;

/// These colors are used for debug draw.
/// See https://www.rapidtables.com/web/color/index.html
enum B2HexColor : (int value)
{
	ALICE_BLUE           {0xf0f8ff},
	ANTIQUE_WHITE        {0xfaebd7},
	AQUA                 {0x00ffff},
	AQUAMARINE           {0x7fffd4},
	AZURE                {0xf0ffff},
	BEIGE                {0xf5f5dc},
	BISQUE               {0xffe4c4},
	BLACK                {0x000000},
	BLANCHED_ALMOND      {0xffebcd},
	BLUE                 {0x0000ff},
	BLUE_VIOLET          {0x8a2be2},
	BROWN                {0xa52a2a},
	BURLYWOOD            {0xdeb887},
	CADET_BLUE           {0x5f9ea0},
	CHARTREUSE           {0x7fff00},
	CHOCOLATE            {0xd2691e},
	CORAL                {0xff7f50},
	CORN_FLOWER_BLUE     {0x6495ed},
	CORN_SILK            {0xfff8dc},
	CRIMSON              {0xdc143c},
	CYAN                 {0x00ffff},
	DARK_BLUE            {0x00008b},
	DARK_CYAN            {0x008b8b},
	DARK_GOLDENROD       {0xb8860b},
	DARK_GRAY            {0xa9a9a9},
	DARK_GREEN           {0x006400},
	DARK_KHAKI           {0xbdb76b},
	DARK_MAGENTA         {0x8b008b},
	DARK_OLIVEGREEN      {0x556b2f},
	DARK_ORANGE          {0xff8c00},
	DARK_ORCHID          {0x9932cc},
	DARK_RED             {0x8b0000},
	DARK_SALMON          {0xe9967a},
	DARK_SEAGREEN        {0x8fbc8f},
	DARK_SLATEBLUE       {0x483d8b},
	DARK_SLATEGRAY       {0x2f4f4f},
	DARK_TURQUOISE       {0x00ced1},
	DARK_VIOLET          {0x9400d3},
	DEEP_PINK            {0xff1493},
	DEEP_SKYBLUE         {0x00bfff},
	DIMGRAY              {0x696969},
	DODGERBLUE           {0x1e90ff},
	FIREBRICK            {0xb22222},
	FLORALWHITE          {0xfffaf0},
	FORESTGREEN          {0x228b22},
	FUCHSIA              {0xff00ff},
	GAINSBORO            {0xdcdcdc},
	GHOSTWHITE           {0xf8f8ff},
	GOLD                 {0xffd700},
	GOLDENROD            {0xdaa520},
	GRAY                 {0xbebebe},
	GRAY1                {0x1a1a1a},
	GRAY2                {0x333333},
	GRAY3                {0x4d4d4d},
	GRAY4                {0x666666},
	GRAY5                {0x7f7f7f},
	GRAY6                {0x999999},
	GRAY7                {0xb3b3b3},
	GRAY8                {0xcccccc},
	GRAY9                {0xe5e5e5},
	GREEN                {0x00ff00},
	GREENYELLOW          {0xadff2f},
	HONEYDEW             {0xf0fff0},
	HOTPINK              {0xff69b4},
	INDIANRED            {0xcd5c5c},
	INDIGO               {0x4b0082},
	IVORY                {0xfffff0},
	KHAKI                {0xf0e68c},
	LAVENDER             {0xe6e6fa},
	LAVENDERBLUSH        {0xfff0f5},
	LAWNGREEN            {0x7cfc00},
	LEMONCHIFFON         {0xfffacd},
	LIGHTBLUE            {0xadd8e6},
	LIGHTCORAL           {0xf08080},
	LIGHTCYAN            {0xe0ffff},
	LIGHTGOLDENROD       {0xeedd82},
	LIGHTGOLDENRODYELLOW {0xfafad2},
	LIGHTGRAY            {0xd3d3d3},
	LIGHTGREEN           {0x90ee90},
	LIGHTPINK            {0xffb6c1},
	LIGHTSALMON          {0xffa07a},
	LIGHTSEAGREEN        {0x20b2aa},
	LIGHTSKYBLUE         {0x87cefa},
	LIGHTSLATEBLUE       {0x8470ff},
	LIGHTSLATEGRAY       {0x778899},
	LIGHTSTEELBLUE       {0xb0c4de},
	LIGHTYELLOW          {0xffffe0},
	LIME                 {0x00ff00},
	LIMEGREEN            {0x32cd32},
	LINEN                {0xfaf0e6},
	MAGENTA              {0xff00ff},
	MAROON               {0xb03060},
	MEDIUMAQUAMARINE     {0x66cdaa},
	MEDIUMBLUE           {0x0000cd},
	MEDIUMORCHID         {0xba55d3},
	MEDIUMPURPLE         {0x9370db},
	MEDIUMSEAGREEN       {0x3cb371},
	MEDIUMSLATEBLUE      {0x7b68ee},
	MEDIUMSPRINGGREEN    {0x00fa9a},
	MEDIUMTURQUOISE      {0x48d1cc},
	MEDIUMVIOLETRED      {0xc71585},
	MIDNIGHTBLUE         {0x191970},
	MINTCREAM            {0xf5fffa},
	MISTYROSE            {0xffe4e1},
	MOCCASIN             {0xffe4b5},
	NAVAJOWHITE          {0xffdead},
	NAVY                 {0x000080},
	NAVYBLUE             {0x000080},
	OLDLACE              {0xfdf5e6},
	OLIVE                {0x808000},
	OLIVEDRAB            {0x6b8e23},
	ORANGE               {0xffa500},
	ORANGERED            {0xff4500},
	ORCHID               {0xda70d6},
	PALEGOLDENROD        {0xeee8aa},
	PALEGREEN            {0x98fb98},
	PALETURQUOISE        {0xafeeee},
	PALEVIOLETRED        {0xdb7093},
	PAPAYAWHIP           {0xffefd5},
	PEACHPUFF            {0xffdab9},
	PERU                 {0xcd853f},
	PINK                 {0xffc0cb},
	PLUM                 {0xdda0dd},
	POWDERBLUE           {0xb0e0e6},
	PURPLE               {0xa020f0},
	REBECCAPURPLE        {0x663399},
	RED                  {0xff0000},
	ROSYBROWN            {0xbc8f8f},
	ROYALBLUE            {0x4169e1},
	SADDLEBROWN          {0x8b4513},
	SALMON               {0xfa8072},
	SANDYBROWN           {0xf4a460},
	SEAGREEN             {0x2e8b57},
	SEASHELL             {0xfff5ee},
	SIENNA               {0xa0522d},
	SILVER               {0xc0c0c0},
	SKYBLUE              {0x87ceeb},
	SLATEBLUE            {0x6a5acd},
	SLATEGRAY            {0x708090},
	SNOW                 {0xfffafa},
	SPRINGGREEN          {0x00ff7f},
	STEELBLUE            {0x4682b4},
	TAN                  {0xd2b48c},
	TEAL                 {0x008080},
	THISTLE              {0xd8bfd8},
	TOMATO               {0xff6347},
	TURQUOISE            {0x40e0d0},
	VIOLET               {0xee82ee},
	VIOLETRED            {0xd02090},
	WHEAT                {0xf5deb3},
	WHITE                {0xffffff},
	WHITESMOKE           {0xf5f5f5},
	YELLOW               {0xffff00},
	YELLOWGREEN          {0x9acd32},
	BOX2DRED             {0xdc3132},
	BOX2DBLUE            {0x30aebf},
	BOX2DGREEN           {0x8cc924},
	BOX2DYELLOW          {0xffee8c}
}

alias B2DrawPolygonCallback      = fn void(B2Vec2* vertices, int vertexCount, B2HexColor color, void* context);
alias B2DrawSolidPolygonCallback = fn void(B2Transform transform, B2Vec2* vertices, int vertexCount, float radius, B2HexColor color, void* context);
alias B2DrawCircleCallback       = fn void(B2Vec2 center, float radius, B2HexColor color, void* context);
alias B2DrawSolidCircleCallback  = fn void(B2Transform transform, float radius, B2HexColor color, void* context);
alias B2DrawCapsuleCallback      = fn void(B2Vec2 p1, B2Vec2 p2, float radius, B2HexColor color, void* context);
alias B2DrawSolidCapsuleCallback = fn void(B2Vec2 p1, B2Vec2 p2, float radius, B2HexColor color, void* context);
alias B2DrawSegmentCallback      = fn void(B2Vec2 p1, B2Vec2 p2, B2HexColor color, void* context);
alias B2DrawTransformCallback    = fn void(B2Transform transform,  void* context);
alias B2DrawPointCallback        = fn void(B2Vec2 p, float size, B2HexColor color, void* context);
alias B2DrawStringCallback       = fn void(B2Vec2 p, ZString txt, void* context);

//This struct holds callbacks you can implement to draw a Box2D world.
struct B2DebugDraw
{
	B2DrawPolygonCallback drawPolygon; // Draw a closed polygon provided in CCW (Counter Clock Wise) order.
	B2DrawSolidPolygonCallback drawSolidPolygon; // Draw a solid closed polygon provided in CCW order.
	B2DrawCircleCallback drawCircle;
	B2DrawSolidCircleCallback drawSolidCircle;
	B2DrawCapsuleCallback drawCapsule;
	B2DrawSolidCapsuleCallback drawSolidCapsule;
	B2DrawSegmentCallback drawSegment; // Draw a line segment.
	B2DrawTransformCallback drawTransform; // Draw a transform. Choose your own length scale.
	B2DrawPointCallback drawPoint;
	B2DrawStringCallback drawString;

	/// Bounds to use if restricting drawing to a rectangular region
	B2AABBox drawingBounds;

	/// Option to restrict drawing to a rectangular region. May suffer from unstable depth sorting.
	bool useDrawingBounds;

	/// Option to draw shapes
	bool drawShapes;

	/// Option to draw joints
	bool drawJoints;

	/// Option to draw additional information for joints
	bool drawJointExtras;

	/// Option to draw the bounding boxes for shapes
	bool drawAABBs;

	/// Option to draw the mass and center of mass of dynamic bodies
	bool drawMass;

	/// Option to draw contact points
	bool drawContacts;

	/// Option to visualize the graph coloring used for contacts and joints
	bool drawGraphColors;

	/// Option to draw contact normals
	bool drawContactNormals;

	/// Option to draw contact normal impulses
	bool drawContactImpulses;

	/// Option to draw contact friction impulses
	bool drawFrictionImpulses;

	/// User context that is passed as an argument to drawing callback functions
	void* context;
}

fn B2DebugDraw defaultDebugDraw() @cname("b2DefaultDebugDraw");

// end_region DEBUG
