// This file requires 0.7.7 or later.
module raylib55::rl;

const float PI = 3.14159265358979323846f;
const float DEG2RAD = PI / 180.0f;
const float RAD2DEG = 180.0f / PI;

// Some Basic Colors
// NOTE: Custom raylib color palette for amazing visuals on WHITE background
const RLColor LIGHTGRAY   = { 200, 200, 200, 255 };   // Light Gray
const RLColor GRAY        = { 130, 130, 130, 255 };   // Gray
const RLColor DARKGRAY    = { 80, 80, 80, 255 };      // Dark Gray
const RLColor YELLOW      = { 253, 249, 0, 255 };     // Yellow
const RLColor GOLD        = { 255, 203, 0, 255 };     // Gold
const RLColor ORANGE      = { 255, 161, 0, 255 };     // Orange
const RLColor PINK        = { 255, 109, 194, 255 };   // Pink
const RLColor RED         = { 230, 41, 55, 255 };     // Red
const RLColor MAROON      = { 190, 33, 55, 255 };     // Maroon
const RLColor GREEN       = { 0, 228, 48, 255 };      // Green
const RLColor LIME        = { 0, 158, 47, 255 };      // Lime
const RLColor DARKGREEN   = { 0, 117, 44, 255 };      // Dark Green
const RLColor SKYBLUE     = { 102, 191, 255, 255 };   // Sky Blue
const RLColor BLUE        = { 0, 121, 241, 255 };     // Blue
const RLColor DARKBLUE    = { 0, 82, 172, 255 };      // Dark Blue
const RLColor PURPLE      = { 200, 122, 255, 255 };   // Purple
const RLColor VIOLET      = { 135, 60, 190, 255 };    // Violet
const RLColor DARKPURPLE  = { 112, 31, 126, 255 };    // Dark Purple
const RLColor BEIGE       = { 211, 176, 131, 255 };   // Beige
const RLColor BROWN       = { 127, 106, 79, 255 };    // Brown
const RLColor DARKBROWN   = { 76, 63, 47, 255 };      // Dark Brown

const RLColor WHITE       = { 255, 255, 255, 255 };   // White
const RLColor BLACK       = { 0, 0, 0, 255 };         // Black
const RLColor BLANK       = { 0, 0, 0, 0 };           // Blank (Transparent)
const RLColor MAGENTA     = { 255, 0, 255, 255 };     // Magenta
const RLColor RAYWHITE    = { 245, 245, 245, 255 };   // My own White (raylib logo)

alias RLVector2 = float[<2>];
alias RLVector3 = float[<3>];
alias RLVector4 = float[<4>];

// Quaternion, 4 components (RLVector4 alias)
alias RLQuaternion = RLVector4;

// Matrix, 4x4 components, column major, OpenGL style, right handed
struct RLMatrix
{
	float m0, m4, m8, m12;  // Matrix first row (4 components)
	float m1, m5, m9, m13;  // Matrix second row (4 components)
	float m2, m6, m10, m14; // Matrix third row (4 components)
	float m3, m7, m11, m15; // Matrix fourth row (4 components)
}

// Color, 4 components, R8G8B8A8 (32bit)
alias RLColor = char[<4>];

// Rectangle, 4 components
union RLRectangle
{
	struct
	{
		float x;         // Rectangle top-left corner position x
		float y;         // Rectangle top-left corner position y
		float width;     // Rectangle width
		float height;    // Rectangle height
	}
	struct
	{
		RLVector2 pos;
		RLVector2 size;
	}
}

// Image, pixel data stored in CPU memory (RAM)
struct RLImage
{
	void* data;              // Image raw data
	CInt width;              // Image base width
	CInt height;             // Image base height
	CInt mipmaps;            // Mipmap levels, 1 by default
	RLPixelFormat format;    // Data format (PixelFormat type)
}

// Texture, tex data stored in GPU memory (VRAM)
struct RLTexture
{
	CUInt id;                // OpenGL texture id
	CInt width;              // Texture base width
	CInt height;             // Texture base height
	CInt mipmaps;            // Mipmap levels, 1 by default
	RLPixelFormat format;    // Data format (RLPixelFormat type)
}

// Texture2D, same as Texture
alias RLTexture2D = RLTexture;

// TextureCubemap, same as Texture
alias RLTextureCubemap = RLTexture;

// RLRenderTexture, fbo for texture rendering
struct RLRenderTexture
{
	CUInt id;             // OpenGL framebuffer object id
	RLTexture texture;    // Color buffer attachment texture
	RLTexture depth;      // Depth buffer attachment texture
}

// RenderTexture2D, same as RenderTexture
alias RenderTexture2D = RLRenderTexture;

// NPatchInfo, n-patch layout info
struct RLNPatchInfo
{
	RLRectangle source;       // Texture source rectangle
	CInt left;                // Left border offset
	CInt top;                 // Top border offset
	CInt right;               // Right border offset
	CInt bottom;              // Bottom border offset
	RLNPatchLayout layout;    // Layout of the n-patch: 3x3, 1x3 or 3x1
}

// GlyphInfo, font characters glyphs info
struct RLGlyphInfo
{
	CInt value;            // Character value (Unicode)
	CInt[<2>] offset_x;    // Character offset when drawing
	CInt advance_x;        // Character advance position X
	RLImage image;         // Character image data
}

// Font, font texture and GlyphInfo array data
struct RLFont
{
	CInt base_size;         // Base size (default chars height)
	CInt glyph_count;       // Number of glyph characters
	CInt glyph_padding;     // Padding around the glyph characters
	RLTexture2D texture;    // Texture atlas containing the glyphs
	RLRectangle* recs;      // Rectangles in texture for the glyphs
	RLGlyphInfo* glyphs;    // Glyphs info data
}

// Camera, defines position/orientation in 3d space
struct RLCamera3D
{
	RLVector3 position;               // Camera position
	RLVector3 target;                 // Camera target it looks-at
	RLVector3 up;                     // Camera up vector (rotation over its axis)
	float fovy;                       // Camera field-of-view apperture in Y (degrees) in perspective, used as near plane width in orthographic
	RLCameraProjection projection;    // Camera projection: CAMERA_PERSPECTIVE or CAMERA_ORTHOGRAPHIC
}

alias RLCamera = RLCamera3D;    // Camera type fallback, defaults to Camera3D

// Camera2D, defines position/orientation in 2d space
struct RLCamera2D
{
	RLVector2 offset;    // Camera offset (displacement from target)
	RLVector2 target;    // Camera target (rotation and zoom origin)
	float rotation;      // Camera rotation in degrees
	float zoom;          // Camera zoom (scaling), should be 1.0f by default
}

// Mesh, vertex data and vao/vbo
struct RLMesh
{
	CInt vertex_count;      // Number of vertices stored in arrays
	CInt triangle_count;    // Number of triangles stored (indexed or not)

	// Vertex attributes data
	float* vertices;      // Vertex position (XYZ - 3 components per vertex) (shader-location = 0)
	float* texcoords;     // Vertex texture coordinates (UV - 2 components per vertex) (shader-location = 1)
	float* texcoords2;    // Vertex second texture coordinates (useful for lightmaps) (shader-location = 5)
	float* normals;       // Vertex normals (XYZ - 3 components per vertex) (shader-location = 2)
	float* tangents;      // Vertex tangents (XYZW - 4 components per vertex) (shader-location = 4)
	CChar* colors;        // Vertex colors (RGBA - 4 components per vertex) (shader-location = 3)
	CUShort *indices;     // Vertex indices (in case vertex data comes indexed)

	// Animation vertex data
	float* anim_vertices;       // Animated vertex positions (after bones transformations)
	float* anim_normals;        // Animated normals (after bones transformations)
	CChar* bone_ids;            // Vertex bone ids, max 255 bone ids, up to 4 bones influence by vertex (skinning)
	float* bone_weights;        // Vertex bone weight, up to 4 bones influence by vertex (skinning)
	RLMatrix *bone_matrices;    // Bones animated transformation matrices
	CInt bone_count;            // Number of bones

	// OpenGL identifiers
	CUInt vao_id;     // OpenGL Vertex Array Object id
	CUInt* vbo_id;    // OpenGL Vertex Buffer Objects id (default vertex data)
}

// RLShader
struct RLShader
{
	CUInt id;      // RLShader program id
	CInt* locs;    // RLShader locations array (RL_MAX_SHADER_LOCATIONS)
}

// RLMaterialMap
struct RLMaterialMap
{
	RLTexture2D texture;    // RLMaterial map texture
	RLColor color;          // RLMaterial map color
	float value;            // RLMaterial map value
}

// RLMaterial, includes shader and maps
struct RLMaterial
{
	RLShader shader;        // RLMaterial shader
	RLMaterialMap* maps;    // RLMaterial maps array (MAX_MATERIAL_MAPS)
	float[4] params;        // RLMaterial generic parameters (if required)
}

// RLTransform, vectex transformation data
struct RLTransform
{
	RLVector3 translation;    // Translation
	RLQuaternion rotation;    // Rotation
	RLVector3 scale;          // Scale
}

// Bone, skeletal animation bone
struct RLBoneInfo
{
	CChar[32] name;         // Bone name
	CInt parent;            // Bone parent
}

// RLModel, meshes, materials and animation data
struct RLModel
{
	RLMatrix transform;       // Local transform matrix
	CInt mesh_count;          // Number of meshes
	CInt material_count;      // Number of materials
	RLMesh* meshes;           // Meshes array
	RLMaterial* materials;    // Materials array
	CInt* mesh_material;      // RLMesh material number

	// Animation data
	CInt bone_count;           // Number of bones
	RLBoneInfo* bones;         // Bones information (skeleton)
	RLTransform* bind_pose;    // Bones base transformation (pose)
}

// RLModelAnimation
struct RLModelAnimation
{
	CInt bone_count;              // Number of bones
	CInt frame_count;             // Number of animation frames
	RLBoneInfo* bones;            // Bones information (skeleton)
	RLTransform** frame_poses;    // Poses array by frame
	CChar[32] name;               // Animation name
}

// RLRay, ray for raycasting
struct RLRay
{
	RLVector3 position;     // RLRay position (origin)
	RLVector3 direction;    // RLRay direction (normalized)
}

// RLRayCollision, ray hit information
struct RLRayCollision
{
	bool hit;            // Did the ray hit something?
	float distance;      // Distance to nearest hit
	RLVector3 point;     // Point of nearest hit
	RLVector3 normal;    // Surface normal of hit
}

// RLBoundingBox
struct RLBoundingBox @compact
{
	RLVector3 min;            // Minimum vertex box-corner
	RLVector3 max;            // Maximum vertex box-corner
}

// RLWave, audio wave data
struct RLWave
{
	CUInt frameCount;     // Total number of frames (considering channels)
	CUInt sample_rate;    // Frequency (samples per second)
	CUInt sample_size;    // Bit depth (bits per sample): 8, 16, 32 (24 not supported)
	CUInt channels;       // Number of channels (1-mono, 2-stereo, ...)
	void* data;           // Buffer data pointer
}

alias RLAudioBufferRef = void*;
alias RLAudioProcessorRef = void*;

// RLAudioStream, custom audio stream
struct RLAudioStream
{
	RLAudioBufferRef buffer;          // Pointer to internal data used by the audio system
	RLAudioProcessorRef processor;    // Pointer to internal data processor, useful for audio effects

	CUInt sample_rate;                // Frequency (samples per second)
	CUInt sample_size;                // Bit depth (bits per sample): 8, 16, 32 (24 not supported)
	CUInt channels;                   // Number of channels (1-mono, 2-stereo, ...)
}


// RLSound
struct RLSound
{
	RLAudioStream stream;    // Audio stream
	CUInt frame_count;       // Total number of frames (considering channels)
}

// RLMusic, audio stream, anything longer than ~10 seconds should be streamed
struct RLMusic
{
	RLAudioStream stream;    // Audio stream
	CUInt frame_count;       // Total number of frames (considering channels)
	bool looping;            // Music looping enable

	CInt ctx_type;           // Type of music context (audio filetype)
	void* ctx_data;          // Audio context data, depends on type
}

// RLVrDeviceInfo, Head-Mounted-Display device parameters
struct RLVrDeviceInfo
{
	CInt h_resolution;                  // Horizontal resolution in pixels
	CInt v_resolution;                  // Vertical resolution in pixels
	float h_screen_size;                // Horizontal size in meters
	float v_screen_size;                // Vertical size in meters
	float v_screen_center;              // Screen center in meters
	float eye_to_screen_distance;       // Distance between eye and display in meters
	float lens_separation_distance;     // Lens separation distance in meters
	float interpupillary_distance;      // IPD (distance between pupils) in meters
	float[4] lens_distortion_values;    // Lens distortion constant parameters
	float[4] chroma_ab_correction;      // Chromatic aberration correction parameters
}

// RLVrStereoConfig, VR stereo rendering configuration for simulator
struct RLVrStereoConfig
{
	RLMatrix[2] projection;          // VR projection matrices (per eye)
	RLMatrix[2] view_offset;         // VR view offset matrices (per eye)
	float[2] left_lens_center;       // VR left lens center
	float[2] right_lens_center;      // VR right lens center
	float[2] left_screen_center;     // VR left screen center
	float[2] right_screen_center;    // VR right screen center
	float[2] scale;                  // VR distortion scale
	float[2] scaleIn;                // VR distortion scale in
}

struct RLFilePathList
{
	CUInt capacity;    // Filepaths max entries
	CUInt count;       // Filepaths entries count
	ZString* paths;    // Filepaths entries
}

// Automation event
struct RLAutomationEvent
{
	CUInt frame;      // Event frame
	CUInt type;       // Event type (AutomationEventType)
	CInt[4] params;   // Event parameters (if required)
}

// Automation event list
struct RLAutomationEventList
{
	CUInt capacity;               // Events max entries (MAX_AUTOMATION_EVENTS)
	CUInt count;                  // Events entries count
	RLAutomationEvent* events;    // Events entries
}

// Trace log level
// NOTE: Organized by priority level
enum RLTraceLogLevel : const CInt
{
	ALL = 0,        // Display all logs
	TRACE,          // Trace logging, intended for internal use only
	DEBUG,          // Debug logging, used for internal debugging, it should be disabled on release builds
	INFO,           // Info logging, used for program execution info
	WARNING,        // Warning logging, used on recoverable failures
	ERROR,          // Error logging, used on unrecoverable failures
	FATAL,          // Fatal logging, used to abort program: exit(EXIT_FAILURE)
	NONE            // Disable logging
}

// Mouse buttons
enum RLMouseButton : CInt
{
	LEFT,           // Mouse button left
	RIGHT,          // Mouse button right
	MIDDLE,         // Mouse button middle (pressed wheel)
	SIDE,           // Mouse button side (advanced mouse device)
	EXTRA,          // Mouse button extra (advanced mouse device)
	FORWARD,        // Mouse button forward (advanced mouse device)
	BACK,           // Mouse button back (advanced mouse device)
}

// Mouse cursor
enum RLMouseCursor : CInt
{
	DEFAULT,            // Default pointer shape
	ARROW,              // Arrow shape
	IBEAM,              // Text writing cursor shape
	CROSSHAIR,          // Cross shape
	POINTING_HAND,      // Pointing hand cursor
	RESIZE_EW,          // Horizontal resize/move arrow shape
	RESIZE_NS,          // Vertical resize/move arrow shape
	RESIZE_NWSE,        // Top-left to bottom-right diagonal resize/move arrow shape
	RESIZE_NESW,        // The top-right to bottom-left diagonal resize/move arrow shape
	RESIZE_ALL,         // The omnidirectional resize/move cursor shape
	NOT_ALLOWED,        // The operation-not-allowed shape
}

// Gamepad buttons
enum RLGamepadButton : CInt
{
	UNKNOWN,             // Unknown button, just for error checking
	LEFT_FACE_UP,        // Gamepad left DPAD up button
	LEFT_FACE_RIGHT,     // Gamepad left DPAD right button
	LEFT_FACE_DOWN,      // Gamepad left DPAD down button
	LEFT_FACE_LEFT,      // Gamepad left DPAD left button
	RIGHT_FACE_UP,       // Gamepad right button up (i.e. PS3: Triangle, Xbox: Y)
	RIGHT_FACE_RIGHT,    // Gamepad right button right (i.e. PS3: Circle, Xbox: B)
	RIGHT_FACE_DOWN,     // Gamepad right button down (i.e. PS3: Cross, Xbox: A)
	RIGHT_FACE_LEFT,     // Gamepad right button left (i.e. PS3: Square, Xbox: X)
	LEFT_TRIGGER_1,      // Gamepad top/back trigger left (first), it could be a trailing button
	LEFT_TRIGGER_2,      // Gamepad top/back trigger left (second), it could be a trailing button
	RIGHT_TRIGGER_1,     // Gamepad top/back trigger right (first), it could be a trailing button
	RIGHT_TRIGGER_2,     // Gamepad top/back trigger right (second), it could be a trailing button
	MIDDLE_LEFT,         // Gamepad center buttons, left one (i.e. PS3: Select)
	MIDDLE,              // Gamepad center buttons, middle one (i.e. PS3: PS, Xbox: XBOX)
	MIDDLE_RIGHT,        // Gamepad center buttons, right one (i.e. PS3: Start)
	LEFT_THUMB,          // Gamepad joystick pressed button left
	RIGHT_THUMB          // Gamepad joystick pressed button right
}

enum RLGamepadAxis : CInt
{
	LEFT_X,             // Gamepad left stick X axis
	LEFT_Y,             // Gamepad left stick Y axis
	RIGHT_X,            // Gamepad right stick X axis
	RIGHT_Y,            // Gamepad right stick Y axis
	LEFT_TRIGGER,       // Gamepad back trigger left, pressure level: [1..-1]
	RIGHT_TRIGGER,      // Gamepad back trigger right, pressure level: [1..-1]
}

// RLMaterial map index
enum RLMaterialMapIndex : const CInt
{
	ALBEDO = 0,        // Albedo material (same as: MATERIAL_MAP_DIFFUSE)
	METALNESS,         // Metalness material (same as: MATERIAL_MAP_SPECULAR)
	NORMAL,            // Normal material
	ROUGHNESS,         // Roughness material
	OCCLUSION,         // Ambient occlusion material
	EMISSION,          // Emission material
	HEIGHT,            // Heightmap material
	CUBEMAP,           // Cubemap material (NOTE: Uses GL_TEXTURE_CUBE_MAP)
	IRRADIANCE,        // Irradiance material (NOTE: Uses GL_TEXTURE_CUBE_MAP)
	PREFILTER,         // Prefilter material (NOTE: Uses GL_TEXTURE_CUBE_MAP)
	BRDF,              // Brdf material

	DIFFUSE = ALBEDO,  // #define MATERIAL_MAP_DIFFUSE      MATERIAL_MAP_ALBEDO
	SPECULAR = METALNESS, // #define MATERIAL_MAP_SPECULAR     MATERIAL_MAP_METALNESS
}

// RLShader location index
enum RLShaderLocationIndex : const CInt
{
	VERTEX_POSITION = 0, // RLShader location: vertex attribute: position
	VERTEX_TEXCOORD01,   // RLShader location: vertex attribute: texcoord01
	VERTEX_TEXCOORD02,   // RLShader location: vertex attribute: texcoord02
	VERTEX_NORMAL,       // RLShader location: vertex attribute: normal
	VERTEX_TANGENT,      // RLShader location: vertex attribute: tangent
	VERTEX_COLOR,        // RLShader location: vertex attribute: color
	MATRIX_MVP,          // RLShader location: matrix uniform: model-view-projection
	MATRIX_VIEW,         // RLShader location: matrix uniform: view (camera transform)
	MATRIX_PROJECTION,   // RLShader location: matrix uniform: projection
	MATRIX_MODEL,        // RLShader location: matrix uniform: model (transform)
	MATRIX_NORMAL,       // RLShader location: matrix uniform: normal
	VECTOR_VIEW,         // RLShader location: vector uniform: view
	COLOR_DIFFUSE,       // RLShader location: vector uniform: diffuse color
	COLOR_SPECULAR,      // RLShader location: vector uniform: specular color
	COLOR_AMBIENT,       // RLShader location: vector uniform: ambient color
	MAP_ALBEDO,          // RLShader location: sampler2d texture: albedo (same as: SHADER_LOC_MAP_DIFFUSE)
	MAP_METALNESS,       // RLShader location: sampler2d texture: metalness (same as: SHADER_LOC_MAP_SPECULAR)
	MAP_NORMAL,          // RLShader location: sampler2d texture: normal
	MAP_ROUGHNESS,       // RLShader location: sampler2d texture: roughness
	MAP_OCCLUSION,       // RLShader location: sampler2d texture: occlusion
	MAP_EMISSION,        // RLShader location: sampler2d texture: emission
	MAP_HEIGHT,          // RLShader location: sampler2d texture: height
	MAP_CUBEMAP,         // RLShader location: samplerCube texture: cubemap
	MAP_IRRADIANCE,      // RLShader location: samplerCube texture: irradiance
	MAP_PREFILTER,       // RLShader location: samplerCube texture: prefilter
	MAP_BRDF,            // RLShader location: sampler2d texture: brdf
	VERTEX_BONEIDS,      // RLShader location: vertex attribute: boneIds
	VERTEX_BONEWEIGHTS,  // RLShader location: vertex attribute: boneWeights
	BONE_MATRICES,       // RLShader location: array of matrices uniform: boneMatrices

	MAP_DIFFUSE = MAP_ALBEDO, // #define SHADER_LOC_MAP_DIFFUSE      SHADER_LOC_MAP_ALBEDO
	MAP_SPECULAR = MAP_METALNESS, // #define SHADER_LOC_MAP_SPECULAR     SHADER_LOC_MAP_METALNESS
}

// RLShader uniform data type
enum RLShaderUniformDataType : CInt
{
	FLOAT,           // RLShader uniform type: float
	VEC2,            // RLShader uniform type: vec2 (2 float)
	VEC3,            // RLShader uniform type: vec3 (3 float)
	VEC4,            // RLShader uniform type: vec4 (4 float)
	INT,             // RLShader uniform type: int
	IVEC2,           // RLShader uniform type: ivec2 (2 int)
	IVEC3,           // RLShader uniform type: ivec3 (3 int)
	IVEC4,           // RLShader uniform type: ivec4 (4 int)
	SAMPLER2D        // RLShader uniform type: sampler2d
}

// RLShader attribute data types
enum RLShaderAttributeDataType : CInt
{
	FLOAT,            // RLShader attribute type: float
	VEC2,             // RLShader attribute type: vec2 (2 float)
	VEC3,             // RLShader attribute type: vec3 (3 float)
	VEC4              // RLShader attribute type: vec4 (4 float)
}

// Pixel formats
// NOTE: Support depends on OpenGL version and platform
enum RLPixelFormat : const CInt
{
	UNCOMPRESSED_GRAYSCALE = 1, // 8 bit per pixel (no alpha)
	UNCOMPRESSED_GRAY_ALPHA,    // 8*2 bpp (2 channels)
	UNCOMPRESSED_R5G6B5,        // 16 bpp
	UNCOMPRESSED_R8G8B8,        // 24 bpp
	UNCOMPRESSED_R5G5B5A1,      // 16 bpp (1 bit alpha)
	UNCOMPRESSED_R4G4B4A4,      // 16 bpp (4 bit alpha)
	UNCOMPRESSED_R8G8B8A8,      // 32 bpp
	UNCOMPRESSED_R32,           // 32 bpp (1 channel - float)
	UNCOMPRESSED_R32G32B32,     // 32*3 bpp (3 channels - float)
	UNCOMPRESSED_R32G32B32A32,  // 32*4 bpp (4 channels - float)
	UNCOMPRESSED_R16,           // 16 bpp (1 channel - half float)
	UNCOMPRESSED_R16G16B16,     // 16*3 bpp (3 channels - half float)
	UNCOMPRESSED_R16G16B16A16,  // 16*4 bpp (4 channels - half float)
	COMPRESSED_DXT1_RGB,        // 4 bpp (no alpha)
	COMPRESSED_DXT1_RGBA,       // 4 bpp (1 bit alpha)
	COMPRESSED_DXT3_RGBA,       // 8 bpp
	COMPRESSED_DXT5_RGBA,       // 8 bpp
	COMPRESSED_ETC1_RGB,        // 4 bpp
	COMPRESSED_ETC2_RGB,        // 4 bpp
	COMPRESSED_ETC2_EAC_RGBA,   // 8 bpp
	COMPRESSED_PVRT_RGB,        // 4 bpp
	COMPRESSED_PVRT_RGBA,       // 4 bpp
	COMPRESSED_ASTC_4X4_RGBA,   // 8 bpp
	COMPRESSED_ASTC_8X8_RGBA    // 2 bpp
}

// RLTexture parameters: filter mode
// NOTE 1: Filtering considers mipmaps if available in the texture
// NOTE 2: Filter is accordingly set for minification and magnification
enum RLTextureFilter : CInt
{
	POINT,               // No filter, just pixel approximation
	BILINEAR,                // Linear filtering
	TRILINEAR,               // Trilinear filtering (linear with mipmaps)
	ANISOTROPIC_4X,          // Anisotropic filtering 4x
	ANISOTROPIC_8X,          // Anisotropic filtering 8x
	ANISOTROPIC_16X,         // Anisotropic filtering 16x
}

// RLTexture parameters: wrap mode
enum RLTextureWrap : CInt
{
	REPEAT,                    // Repeats texture in tiled mode
	CLAMP,                     // Clamps texture to edge pixel in tiled mode
	MIRROR_REPEAT,             // Mirrors and repeats the texture in tiled mode
	MIRROR_CLAMP               // Mirrors and clamps to border the texture in tiled mode
}

// Cubemap layouts
enum RLCubemapLayout : CInt
{
	AUTO_DETECT,             // Automatically detect layout type
	LINE_VERTICAL,           // Layout is defined by a vertical line with faces
	LINE_HORIZONTAL,         // Layout is defined by a horizontal line with faces
	CROSS_THREE_BY_FOUR,     // Layout is defined by a 3x4 cross with cubemap faces
	CROSS_FOUR_BY_THREE,     // Layout is defined by a 4x3 cross with cubemap faces
}

// RLFont type, defines generation method
enum RLFontType : CInt
{
	DEFAULT,                   // Default font generation, anti-aliased
	BITMAP,                    // Bitmap font generation, no anti-aliasing
	SDF,                       // SDF font generation, requires external shader
}

// RLColor blending modes (pre-defined)
enum RLBlendMode : CInt
{
	ALPHA,                    // Blend textures considering alpha (default)
	ADDITIVE,                 // Blend textures adding colors
	MULTIPLIED,               // Blend textures multiplying colors
	ADD_COLORS,               // Blend textures adding colors (alternative)
	SUBTRACT_COLORS,          // Blend textures subtracting colors (alternative)
	ALPHA_PREMULTIPLY,        // Blend premultiplied textures considering alpha
	CUSTOM,                   // Blend textures using custom src/dst factors (use setBlendFactors())
	CUSTOM_SEPARATE,          // Blend textures using custom rgb/alpha separate src/dst factors (use setBlendFactorsSeparate())
}

$assert(RLBlendMode.ALPHA.ordinal == 0);


// RLCamera system modes
enum RLCameraMode : CInt
{
	CUSTOM,                  // RLCamera custom, controlled by user (UpdateCamera() does nothing)
	FREE,                    // RLCamera free mode
	ORBITAL,                 // RLCamera orbital, around target, zoom supported
	FIRST_PERSON,            // RLCamera first person
	THIRD_PERSON,            // RLCamera third person
}

// RLCamera projection
enum RLCameraProjection : CInt
{
	PERSPECTIVE,             // Perspective projection
	ORTHOGRAPHIC,            // Orthographic projection
}

// N-patch layout
enum RLNPatchLayout : CInt
{
	NINE_PATCH,              // Npatch layout: 3x3 tiles
	THREE_PATCH_VERTICAL,    // Npatch layout: 1x3 tiles
	THREE_PATCH_HORIZONTAL   // Npatch layout: 3x1 tiles
}

// Callbacks to hook some internal functions
// WARNING: This callbacks are intended for advance users
alias RLTraceLogCallback @if($defined(CVaList)) = fn void(RLTraceLogLevel logLevel, ZString text, CVaList args);  // Logging: Redirect trace log messages
alias RLLoadFileDataCallback = fn char*(ZString file_name, CInt* data_size);             // FileIO: Load binary data
alias RLSaveFileDataCallback = fn bool(ZString file_name, void *data, CInt data_size);   // FileIO: Save binary data
alias RLLoadFileTextCallback = fn char*(ZString file_name);              // FileIO: Load text data
alias RLSaveFileTextCallback = fn bool(ZString file_name, ZString text); // FileIO: Save text data

// Window-related functions
fn void init_window(CInt width, CInt height, ZString title) @cname("InitWindow");        // Initialize window and OpenGL context
fn void close_window() @cname("CloseWindow");                                            // Close window and unload OpenGL context
fn bool window_should_close() @cname("WindowShouldClose");                                // Check if application should close (KEY_ESCAPE pressed or windows close icon clicked)
fn bool is_window_ready() @cname("IsWindowReady");                                        // Check if window has been initialized successfully
fn bool is_window_fullscreen() @cname("IsWindowFullscreen");                              // Check if window is currently fullscreen
fn bool is_window_hidden() @cname("IsWindowHidden");                                      // Check if window is currently hidden
fn bool is_window_minimized() @cname("IsWindowMinimized");                                // Check if window is currently minimized
fn bool is_window_maximized() @cname("IsWindowMaximized");                                // Check if window is currently maximized
fn bool is_window_focused() @cname("IsWindowFocused");                                    // Check if window is currently focused
fn bool is_window_resized() @cname("IsWindowResized");                                    // Check if window has been resized last frame
fn bool is_window_state(ConfigFlag flag) @cname("IsWindowState");                        // Check if one specific window flag is enabled
fn void set_window_state(ConfigFlag flags) @cname("SetWindowState");                     // Set window configuration state using flags
fn void clear_window_state(ConfigFlag flags) @cname("ClearWindowState");                 // Clear window configuration state flags
fn void toggle_fullscreen() @cname("ToggleFullscreen");                                  // Toggle window state: fullscreen/windowed, resizes monitor to match window resolution
fn void toggle_borderless_windowed() @cname("ToggleBorderlessWindowed");                  // Toggle window state: borderless windowed, resizes window to match monitor resolution
fn void maximize_window() @cname("MaximizeWindow");                                      // Set window state: maximized, if resizable
fn void minimize_window() @cname("MinimizeWindow");                                      // Set window state: minimized, if resizable
fn void restore_window() @cname("RestoreWindow");                                        // Set window state: not minimized/maximized
fn void set_window_icon(RLImage image) @cname("SetWindowIcon");                             // Set icon for window (single image, RGBA 32bit)
fn void set_window_icons(RLImage *images, CInt count) @cname("SetWindowIcons");             // Set icon for window (multiple images, RGBA 32bit)
fn void set_window_title(ZString title) @cname("SetWindowTitle");                         // Set title for window
fn void set_window_position(CInt x, CInt y) @cname("SetWindowPosition");                  // Set window position on screen
fn void set_window_monitor(CInt monitor) @cname("SetWindowMonitor");                      // Set monitor for the current window
fn void set_window_min_size(CInt width, CInt height) @cname("SetWindowMinSize");           // Set window minimum dimensions (for FLAG_WINDOW_RESIZABLE)
fn void set_window_max_size(CInt width, CInt height) @cname("SetWindowMaxSize");           // Set window maximum dimensions (for FLAG_WINDOW_RESIZABLE)
fn void set_window_size(CInt width, CInt height) @cname("SetWindowSize");                 // Set window dimensions
fn void set_window_opacity(float opacity) @cname("SetWindowOpacity");                     // Set window opacity [0.0f..1.0f]
fn void set_window_focused() @cname("SetWindowFocused");                                  // Set window focused
fn void *get_window_handle() @cname("GetWindowHandle");                                   // Get native window handle
fn int get_screen_width() @cname("GetScreenWidth");                                       // Get current screen width
fn CInt get_screen_height() @cname("GetScreenHeight");                                    // Get current screen height
fn CInt get_render_width() @cname("GetRenderWidth");                                      // Get current render width (it considers HiDPI)
fn CInt get_render_height() @cname("GetRenderHeight");                                    // Get current render height (it considers HiDPI)
fn CInt get_monitor_count() @cname("GetMonitorCount");                                    // Get number of connected monitors
fn CInt get_current_monitor() @cname("GetCurrentMonitor");                                // Get current monitor where window is placed
fn RLVector2 get_monitor_position(CInt monitor) @cname("GetMonitorPosition");               // Get specified monitor position
fn CInt get_monitor_width(CInt monitor) @cname("GetMonitorWidth");                        // Get specified monitor width (current video mode used by monitor)
fn CInt get_monitor_height(CInt monitor) @cname("GetMonitorHeight");                      // Get specified monitor height (current video mode used by monitor)
fn CInt get_monitor_physical_width(CInt monitor) @cname("GetMonitorPhysicalWidth");        // Get specified monitor physical width in millimetres
fn CInt get_monitor_physical_height(CInt monitor) @cname("GetMonitorPhysicalHeight");      // Get specified monitor physical height in millimetres
fn CInt get_monitor_refresh_rate(CInt monitor) @cname("GetMonitorRefreshRate");            // Get specified monitor refresh rate
fn RLVector2 get_window_position() @cname("GetWindowPosition");                             // Get window position XY on monitor
fn RLVector2 get_window_scale_d_p_i() @cname("GetWindowScaleDPI");                             // Get window scale DPI factor
fn ZString get_monitor_name(CInt monitor) @cname("GetMonitorName");                       // Get the human-readable, UTF-8 encoded name of the specified monitor
fn void set_clipboard_text(ZString text) @cname("SetClipboardText");                      // Set clipboard text content
fn ZString get_clipboard_text() @cname("GetClipboardText");                               // Get clipboard text content
fn RLImage get_clipboard_image() @cname("GetClipboardImage");                               // Get clipboard image content
fn void enable_event_waiting() @cname("EnableEventWaiting");                              // Enable waiting for events on EndDrawing(), no automatic event polling
fn void disable_event_waiting() @cname("DisableEventWaiting");                            // Disable waiting for events on EndDrawing(), automatic events polling

// Cursor-related functions
fn void show_cursor() @cname("ShowCursor");             // Shows cursor
fn void hide_cursor() @cname("HideCursor");             // Hides cursor
fn bool is_cursor_hidden() @cname("IsCursorHidden");     // Check if cursor is not visible
fn void enable_cursor() @cname("EnableCursor");         // Enables cursor (unlock cursor)
fn void disable_cursor() @cname("DisableCursor");       // Disables cursor (lock cursor)
fn bool is_cursor_on_screen() @cname("IsCursorOnScreen"); // Check if cursor is on the screen

// Drawing-related functions
fn void clear_background(RLColor color) @cname("ClearBackground");                               // Set background color (framebuffer clear color)
fn void begin_drawing() @cname("BeginDrawing");                                                // Setup canvas (framebuffer) to start drawing
fn void end_drawing() @cname("EndDrawing");                                                    // End canvas drawing and swap buffers (double buffering)
fn void begin_mode2d(RLCamera2D camera) @cname("BeginMode2D");                                   // Begin 2D mode with custom camera (2D)
fn void end_mode2d() @cname("EndMode2D");                                                      // Ends 2D mode with custom camera
fn void begin_mode3d(RLCamera3D camera) @cname("BeginMode3D");                                   // Begin 3D mode with custom camera (3D)
fn void end_mode3d() @cname("EndMode3D");                                                      // Ends 3D mode and returns to default 2D orthographic mode
fn void begin_texture_mode(RenderTexture2D target) @cname("BeginTextureMode");                  // Begin drawing to render texture
fn void end_texture_mode() @cname("EndTextureMode");                                            // Ends drawing to render texture
fn void begin_shader_mode(RLShader shader) @cname("BeginShaderMode");                             // Begin custom shader drawing
fn void end_shader_mode() @cname("EndShaderMode");                                              // End custom shader drawing (use default shader)
fn void begin_blend_mode(RLBlendMode mode) @cname("BeginBlendMode");                              // Begin blending mode (alpha, additive, multiplied, subtract, custom)
fn void end_blend_mode() @cname("EndBlendMode");                                                // End blending mode (reset to default: alpha blending)
fn void begin_scissor_mode(CInt x, CInt y, CInt width, CInt height) @cname("BeginScissorMode"); // Begin scissor mode (define screen area for following drawing)
fn void end_scissor_mode() @cname("EndScissorMode");                                            // End scissor mode
fn void begin_vr_stereo_mode(RLVrStereoConfig config) @cname("BeginVrStereoMode");                 // Begin stereo rendering (requires VR simulator)
fn void end_vr_stereo_mode() @cname("EndVrStereoMode");                                          // End stereo rendering (requires VR simulator)

// VR stereo config functions for VR simulator
fn RLVrStereoConfig load_vr_stereo_config(RLVrDeviceInfo device) @cname("LoadVrStereoConfig"); // Load VR stereo config for VR simulator device parameters
fn void unload_vr_stereo_config(RLVrStereoConfig config) @cname("UnloadVrStereoConfig");     // Unload VR stereo config

// Shader management functions
// NOTE: Shader functionality is not available on OpenGL 1.1
fn RLShader load_shader(ZString vs_file_name, ZString fs_file_name) @cname("LoadShader");                                                                            // Load shader from files and bind default locations
fn RLShader load_shader_from_memory(ZString vs_code, ZString fs_code) @cname("LoadShaderFromMemory");                                                                // Load shader from code strings and bind default locations
fn bool is_shader_valid(RLShader shader) @cname("IsShaderValid");                                                                                                 // Check if a shader is valid (loaded on GPU)
fn CInt get_shader_location(RLShader shader, ZString uniform_name) @cname("GetShaderLocation");                                                                    // Get shader uniform location
fn CInt get_shader_location_attrib(RLShader shader, ZString attrib_name) @cname("GetShaderLocationAttrib");                                                         // Get shader attribute location
fn void set_shader_value(RLShader shader, CInt loc_index, void* value, RLShaderUniformDataType uniform_type) @cname("SetShaderValue");               // Set shader uniform value
fn void set_shader_value_v(RLShader shader, CInt loc_index, void* value, RLShaderUniformDataType uniform_type, CInt count) @cname("SetShaderValueV"); // Set shader uniform value vector
fn void set_shader_value_matrix(RLShader shader, CInt loc_index, RLMatrix mat) @cname("SetShaderValueMatrix");                                         // Set shader uniform value (matrix 4x4)
fn void set_shader_value_texture(RLShader shader, CInt loc_index, RLTexture2D texture) @cname("SetShaderValueTexture");                                // Set shader uniform value for texture (sampler2d)
fn void unload_shader(RLShader shader) @cname("UnloadShader");                                                                                                   // Unload shader from GPU memory (VRAM)

// Screen-space-related functions
fn RLRay get_screen_to_world_ray(RLVector2 position, RLCamera camera) @cname("GetScreenToWorldRay");                              // Get a ray trace from screen position (i.e mouse)
fn RLRay get_screen_to_world_ray_ex(RLVector2 position, RLCamera camera, CInt width, CInt height) @cname("GetScreenToWorldRayEx"); // Get a ray trace from screen position (i.e mouse) in a viewport
fn RLVector2 get_world_to_screen(RLVector3 position, RLCamera camera) @cname("GetWorldToScreen");                                // Get the screen space position for a 3d world space position
fn RLVector2 get_world_to_screen_ex(RLVector3 position, RLCamera camera, CInt width, CInt height) @cname("GetWorldToScreenEx");   // Get size position for a 3d world space position
fn RLVector2 get_world_to_screen2d(RLVector2 position, RLCamera2D camera) @cname("GetWorldToScreen2D");                          // Get the screen space position for a 2d camera world space position
fn RLVector2 get_screen_to_world2d(RLVector2 position, RLCamera2D camera) @cname("GetScreenToWorld2D");                          // Get the world space position for a 2d camera screen space position
fn RLMatrix get_camera_matrix(RLCamera camera) @cname("GetCameraMatrix");                                                     // Get camera transform matrix (view matrix)
fn RLMatrix get_camera_matrix2d(RLCamera2D camera) @cname("GetCameraMatrix2D");                                               // Get camera 2d transform matrix

// Timing-related functions
fn void set_target_fps(CInt fps) @cname("SetTargetFPS"); // Set target FPS (maximum)
fn float get_frame_time() @cname("GetFrameTime");        // Get time in seconds for last frame drawn (delta time)
fn double get_time() @cname("GetTime");                 // Get elapsed time in seconds since InitWindow()
fn CInt get_fps() @cname("GetFPS");                     // Get current FPS

// Custom frame control functions
// NOTE: Those functions are intended for advanced users that want full control over the frame processing
// By default EndDrawing() does this job: draws everything + SwapScreenBuffer() + manage frame timing + PollInputEvents()
// To avoid that behaviour and control frame processes manually, enable in config.h: SUPPORT_CUSTOM_FRAME_CONTROL
fn void swap_screen_buffer() @cname("SwapScreenBuffer"); // Swap back buffer with front buffer (screen drawing)
fn void poll_input_events() @cname("PollInputEvents");   // Register all input events
fn void wait_time(double seconds) @cname("WaitTime");   // Wait for some time (halt program execution)

// Random values generation functions
fn void set_random_seed(CUInt seed) @cname("SetRandomSeed");                                 // Set the seed for the random number generator
fn CInt get_random_value(CInt min, CInt max) @cname("GetRandomValue");                       // Get a random value between min and max (both included)
fn CInt *load_random_sequence(CUInt count, CInt min, CInt max) @cname("LoadRandomSequence"); // Load random values sequence, no values repeated
fn void unload_random_sequence(CInt *sequence) @cname("UnloadRandomSequence");               // Unload random values sequence

// Misc. functions
fn void take_screenshot(ZString file_name) @cname("TakeScreenshot");  // Takes a screenshot of current screen (filename extension defines format)
fn void set_config_flags(ConfigFlag flags) @cname("SetConfigFlags"); // Setup init configuration flags (view FLAGS)
fn void open_u_r_l(ZString url) @cname("OpenURL");                     // Open URL with default system browser (if available)

// NOTE: Following functions implemented in module [utils]
//------------------------------------------------------------------
fn void trace_log(RLTraceLogLevel log_level, ZString text, ...) @cname("TraceLog"); // Show trace log messages (LOG_DEBUG, LOG_INFO, LOG_WARNING, LOG_ERROR...)
fn void set_trace_log_level(RLTraceLogLevel log_level) @cname("SetTraceLogLevel");    // Set the current threshold (minimum) log level
fn void *mem_alloc(CUInt size) @cname("MemAlloc");                               // Internal memory allocator
fn void *mem_realloc(void *ptr, CUInt size) @cname("MemRealloc");                // Internal memory reallocator
fn void mem_free(void *ptr) @cname("MemFree");                                   // Internal memory free

// Set custom callbacks
// WARNING: Callbacks setup is intended for advanced users
fn void set_trace_log_callback(RLTraceLogCallback callback) @cname("SetTraceLogCallback");             // Set custom trace log
fn void set_load_file_data_callback(RLLoadFileDataCallback callback) @cname("SetLoadFileDataCallback"); // Set custom file binary data loader
fn void set_save_file_data_callback(RLSaveFileDataCallback callback) @cname("SetSaveFileDataCallback"); // Set custom file binary data saver
fn void set_load_file_text_callback(RLLoadFileTextCallback callback) @cname("SetLoadFileTextCallback"); // Set custom file text data loader
fn void set_save_file_text_callback(RLSaveFileTextCallback callback) @cname("SetSaveFileTextCallback"); // Set custom file text data saver

// Files management functions
fn char* load_file_data(ZString file_name, CInt *data_size) @cname("LoadFileData");                   // Load file data as byte array (read)
fn void unload_file_data(char* data) @cname("UnloadFileData");                                      // Unload file data allocated by LoadFileData()
fn bool save_file_data(ZString file_name, void *data, CInt data_size) @cname("SaveFileData");         // Save data to file from byte array (write), returns true on success
fn bool export_data_as_code(char* data, CInt data_size, ZString file_name) @cname("ExportDataAsCode"); // Export data to code (.h), returns true on success
fn ZString load_file_text(ZString file_name) @cname("LoadFileText");                                 // Load text data from file (read), returns a '\0' terminated string
fn void unload_file_text(ZString file_name) @cname("UnloadFileText");                                        // Unload file text data allocated by LoadFileText()
fn bool save_file_text(ZString file_name, ZString text) @cname("SaveFileText");                      // Save text data to file (write), string must be '\0' terminated, returns true on success
//------------------------------------------------------------------

// File system functions
fn bool file_exists(ZString file_name) @cname("FileExists");                                                               // Check if file exists
fn bool directory_exists(ZString dir_path) @cname("DirectoryExists");                                                      // Check if a directory path exists
fn bool is_file_extension(ZString file_name, ZString ext) @cname("IsFileExtension");                                        // Check file extension (including point: .png, .wav)
fn CInt get_file_length(ZString file_name) @cname("GetFileLength");                                                         // Get file length in bytes (NOTE: GetFileSize() conflicts with windows.h)
fn ZString get_file_extension(ZString file_name) @cname("GetFileExtension");                                                // Get pointer to extension for a filename string (includes dot: '.png')
fn ZString get_file_name(ZString file_path) @cname("GetFileName");                                                          // Get pointer to filename for a path string
fn ZString get_file_name_without_ext(ZString file_path) @cname("GetFileNameWithoutExt");                                      // Get filename string without extension (uses static string)
fn ZString get_directory_path(ZString file_path) @cname("GetDirectoryPath");                                                // Get full path for a given file_name with path (uses static string)
fn ZString get_prev_directory_path(ZString dir_path) @cname("GetPrevDirectoryPath");                                         // Get previous directory path for a given path (uses static string)
fn ZString get_working_directory() @cname("GetWorkingDirectory");                                                          // Get current working directory (uses static string)
fn ZString get_application_directory() @cname("GetApplicationDirectory");                                                  // Get the directory of the running application (uses static string)
fn CInt make_directory(ZString dir_path) @cname("MakeDirectory");                                                          // Create directories (including full path requested), returns 0 on success
fn bool change_directory(ZString dir) @cname("ChangeDirectory");                                                          // Change working directory, return true on success
fn bool is_path_file(ZString path) @cname("IsPathFile");                                                                   // Check if a given path is a file or a directory
fn bool is_file_name_valid(ZString file_name) @cname("IsFileNameValid");                                                     // Check if file_name is valid for the platform/OS
fn RLFilePathList load_directory_files(ZString dir_path) @cname("LoadDirectoryFiles");                                        // Load directory filepaths
fn RLFilePathList load_directory_files_ex(ZString base_path, ZString filter, bool scan_subdirs) @cname("LoadDirectoryFilesEx"); // Load directory filepaths with extension filtering and recursive directory scan. Use 'DIR' in the filter string to include directories in the result
fn void unload_directory_files(RLFilePathList files) @cname("UnloadDirectoryFiles");                                         // Unload filepaths
fn bool is_file_dropped() @cname("IsFileDropped");                                                                         // Check if a file has been dropped into window
fn RLFilePathList load_dropped_files() @cname("LoadDroppedFiles");                                                           // Load dropped filepaths
fn void unload_dropped_files(RLFilePathList files) @cname("UnloadDroppedFiles");                                             // Unload dropped filepaths
fn long get_file_mod_time(ZString file_name) @cname("GetFileModTime");                                                       // Get file modification time (last write time)

// Compression/Encoding functionality
fn char* compress_data(char* data, CInt data_size, CInt *comp_data_size) @cname("CompressData");         // Compress data (DEFLATE algorithm), memory must be MemFree()
fn char* decompress_data(char* compData, CInt comp_data_size, CInt *data_size) @cname("DecompressData"); // Decompress data (DEFLATE algorithm), memory must be MemFree()
fn char* encode_data_base64(char* data, CInt data_size, CInt *output_size) @cname("EncodeDataBase64");   // Encode data to Base64 string, memory must be MemFree()
fn char* decode_data_base64(char* data, CInt *output_size) @cname("DecodeDataBase64");                  // Decode Base64 string data, memory must be MemFree()
fn CUInt compute_c_r_c32(char *data, CInt data_size) @cname("ComputeCRC32");                             // Compute CRC32 hash code
fn CUInt[4]* compute_m_d5(char *data, CInt data_size) @cname("ComputeMD5");                             // Compute MD5 hash code, returns static CUInt[4] (16 bytes)
fn CUInt[5]* compute_s_h_a1(char *data, CInt data_size) @cname("ComputeSHA1");                           // Compute SHA1 hash code, returns static CUInt[5] (20 bytes)


// Automation events functionality
fn RLAutomationEventList load_automation_event_list(ZString file_name) @cname("LoadAutomationEventList");                // Load automation events list from file, NULL for empty list, capacity = MAX_AUTOMATION_EVENTS
fn void unload_automation_event_list(RLAutomationEventList list) @cname("UnloadAutomationEventList");                   // Unload automation events list from file
fn bool export_automation_event_list(RLAutomationEventList list, ZString file_name) @cname("ExportAutomationEventList"); // Export automation events list as text file
fn void set_automation_event_list(RLAutomationEventList *list) @cname("SetAutomationEventList");                        // Set automation event list to record to
fn void set_automation_event_base_frame(CInt frame) @cname("SetAutomationEventBaseFrame");                             // Set automation event internal base frame to start recording
fn void start_automation_event_recording() @cname("StartAutomationEventRecording");                                   // Start recording automation events (RLAutomationEventList must be set)
fn void stop_automation_event_recording() @cname("StopAutomationEventRecording");                                     // Stop recording automation events
fn void play_automation_event(RLAutomationEvent event) @cname("PlayAutomationEvent");                                  // Play a recorded automation event

//------------------------------------------------------------------------------------
// Input Handling Functions (Module: core)
//------------------------------------------------------------------------------------

// Input-related functions: keyboard
fn bool is_key_pressed(KeyboardKey key) @cname("IsKeyPressed");             // Check if a key has been pressed once
fn bool is_key_pressed_repeat(KeyboardKey key) @cname("IsKeyPressedRepeat"); // Check if a key has been pressed again
fn bool is_key_down(KeyboardKey key) @cname("IsKeyDown");                   // Check if a key is being pressed
fn bool is_key_released(KeyboardKey key) @cname("IsKeyReleased");           // Check if a key has been released once
fn bool is_key_up(KeyboardKey key) @cname("IsKeyUp");                       // Check if a key is NOT being pressed
fn KeyboardKey get_key_pressed() @cname("GetKeyPressed");                   // Get key pressed (keycode), call it multiple times for keys queued, returns 0 when the queue is empty
fn CInt get_char_pressed() @cname("GetCharPressed");                        // Get char pressed (unicode), call it multiple times for chars queued, returns 0 when the queue is empty
fn void set_exit_key(KeyboardKey key) @cname("SetExitKey");                 // Set a custom key to exit program (default is ESC)

// Input-related functions: gamepads
fn bool is_gamepad_available(CInt gamepad) @cname("IsGamepadAvailable");                                                      // Check if a gamepad is available
fn ZString get_gamepad_name(CInt gamepad) @cname("GetGamepadName");                                                           // Get gamepad internal name id
fn bool is_gamepad_button_pressed(CInt gamepad, RLGamepadButton button) @cname("IsGamepadButtonPressed");                        // Check if a gamepad button has been pressed once
fn bool is_gamepad_button_down(CInt gamepad, RLGamepadButton button) @cname("IsGamepadButtonDown");                              // Check if a gamepad button is being pressed
fn bool is_gamepad_button_released(CInt gamepad, RLGamepadButton button) @cname("IsGamepadButtonReleased");                      // Check if a gamepad button has been released once
fn bool is_gamepad_button_up(CInt gamepad, RLGamepadButton button) @cname("IsGamepadButtonUp");                                  // Check if a gamepad button is NOT being pressed
fn RLGamepadButton get_gamepad_button_pressed() @cname("GetGamepadButtonPressed");                                               // Get the last gamepad button pressed
fn CInt get_gamepad_axis_count(CInt gamepad) @cname("GetGamepadAxisCount");                                                    // Get gamepad axis count for a gamepad
fn float get_gamepad_axis_movement(CInt gamepad, RLGamepadAxis axis) @cname("GetGamepadAxisMovement");                           // Get axis movement value for a gamepad axis
fn CInt set_gamepad_mappings(ZString mappings) @cname("SetGamepadMappings");                                                  // Set internal gamepad mappings (SDL_GameControllerDB)
fn void set_gamepad_vibration(CInt gamepad, float left_motor, float right_motor, float duration) @cname("SetGamepadVibration"); // Set gamepad vibration for both motors (duration in seconds)

// Input-related functions: mouse
fn bool is_mouse_button_pressed(RLMouseButton button) @cname("IsMouseButtonPressed");   // Check if a mouse button has been pressed once
fn bool is_mouse_button_down(RLMouseButton button) @cname("IsMouseButtonDown");         // Check if a mouse button is being pressed
fn bool is_mouse_button_released(RLMouseButton button) @cname("IsMouseButtonReleased"); // Check if a mouse button has been released once
fn bool is_mouse_button_up(RLMouseButton button) @cname("IsMouseButtonUp");             // Check if a mouse button is NOT being pressed
fn CInt get_mouse_x() @cname("GetMouseX");                                           // Get mouse position X
fn CInt get_mouse_y() @cname("GetMouseY");                                           // Get mouse position Y
fn RLVector2 get_mouse_position() @cname("GetMousePosition");                          // Get mouse position XY
fn RLVector2 get_mouse_delta() @cname("GetMouseDelta");                                // Get mouse delta between frames
fn void set_mouse_position(CInt x, CInt y) @cname("SetMousePosition");               // Set mouse position XY
fn void set_mouse_offset(CInt offset_x, CInt offset_y) @cname("SetMouseOffset");       // Set mouse offset
fn void set_mouse_scale(float scale_x, float scale_y) @cname("SetMouseScale");         // Set mouse scaling
fn float get_mouse_wheel_move() @cname("GetMouseWheelMove");                          // Get mouse wheel movement for X or Y, whichever is larger
fn RLVector2 get_mouse_wheel_move_v() @cname("GetMouseWheelMoveV");                      // Get mouse wheel movement for both X and Y
fn void set_mouse_cursor(RLMouseCursor cursor) @cname("SetMouseCursor");               // Set mouse cursor

// Input-related functions: touch
fn CInt get_touch_x() @cname("GetTouchX");                            // Get touch position X for touch point 0 (relative to screen size)
fn CInt get_touch_y() @cname("GetTouchY");                            // Get touch position Y for touch point 0 (relative to screen size)
fn RLVector2 get_touch_position(CInt index) @cname("GetTouchPosition"); // Get touch position XY for a touch point index (relative to screen size)
fn CInt get_touch_point_id(CInt index) @cname("GetTouchPointId");      // Get touch point identifier for given index
fn CInt get_touch_point_count() @cname("GetTouchPointCount");          // Get number of touch points

//------------------------------------------------------------------------------------
// Gestures and Touch Handling Functions (Module: rgestures)
//------------------------------------------------------------------------------------
fn void set_gestures_enabled(Gesture flags) @cname("SetGesturesEnabled"); // Enable a set of gestures using flags
fn bool is_gesture_detected(Gesture gesture) @cname("IsGestureDetected"); // Check if a gesture have been detected
fn Gesture get_gesture_detected() @cname("GetGestureDetected");           // Get latest detected gesture
fn float get_gesture_hold_duration() @cname("GetGestureHoldDuration");     // Get gesture hold time in seconds
fn RLVector2 get_gesture_drag_vector() @cname("GetGestureDragVector");       // Get gesture drag vector
fn float get_gesture_drag_angle() @cname("GetGestureDragAngle");           // Get gesture drag angle
fn RLVector2 get_gesture_pinch_vector() @cname("GetGesturePinchVector");     // Get gesture pinch delta
fn float get_gesture_pinch_angle() @cname("GetGesturePinchAngle");         // Get gesture pinch angle

//------------------------------------------------------------------------------------
// RLCamera System Functions (Module: rcamera)
//------------------------------------------------------------------------------------
fn void update_camera(RLCamera *camera, RLCameraMode mode) @cname("UpdateCamera");                                      // Update camera position for selected mode
fn void update_camera_pro(RLCamera *camera, RLVector3 movement, RLVector3 rotation, float zoom) @cname("UpdateCameraPro"); // Update camera movement/rotation

//------------------------------------------------------------------------------------
// Basic Shapes Drawing Functions (Module: shapes)
//------------------------------------------------------------------------------------
// Set texture and rectangle to be used on shapes drawing
// NOTE: It can be useful when using basic shapes and one single font,
// defining a font char white rectangle would allow drawing everything in a single draw call
fn void set_shapes_texture(RLTexture2D texture, RLRectangle source) @cname("SetShapesTexture"); // Set texture and rectangle to be used on shapes drawing
fn RLTexture2D get_shapes_texture() @cname("GetShapesTexture");                               // Get texture that is used for shapes drawing
fn RLRectangle get_shapes_texture_rectangle() @cname("GetShapesTextureRectangle");             // Get texture source rectangle that is used for shapes drawing

// Basic shapes drawing functions
fn void draw_pixel(CInt pos_x, CInt pos_y, RLColor color) @cname("DrawPixel");                                                                                          // Draw a pixel using geometry [Can be slow, use with care]
fn void draw_pixel_v(RLVector2 position, RLColor color) @cname("DrawPixelV");                                                                                            // Draw a pixel using geometry (Vector version) [Can be slow, use with care]
fn void draw_line(CInt start_pos_x, CInt start_pos_y, CInt end_pos_x, CInt end_pos_y, RLColor color) @cname("DrawLine");                                                      // Draw a line
fn void draw_line_v(RLVector2 start_pos, RLVector2 end_pos, RLColor color) @cname("DrawLineV");                                                                              // Draw a line (using gl lines)
fn void draw_line_ex(RLVector2 start_pos, RLVector2 end_pos, float thick, RLColor color) @cname("DrawLineEx");                                                               // Draw a line (using triangles/quads)
fn void draw_line_strip(RLVector2 *points, CInt point_count, RLColor color) @cname("DrawLineStrip");                                                                      // Draw lines sequence (using gl lines)
fn void draw_line_bezier(RLVector2 start_pos, RLVector2 end_pos, float thick, RLColor color) @cname("DrawLineBezier");                                                       // Draw line segment cubic-bezier in-out interpolation
fn void draw_circle(CInt center_x, CInt center_y, float radius, RLColor color) @cname("DrawCircle");                                                                    // Draw a color-filled circle
fn void draw_circle_sector(RLVector2 center, float radius, float start_angle, float end_angle, CInt segments, RLColor color) @cname("DrawCircleSector");                   // Draw a piece of a circle
fn void draw_circle_sector_lines(RLVector2 center, float radius, float start_angle, float end_angle, CInt segments, RLColor color) @cname("DrawCircleSectorLines");         // Draw circle sector outline
fn void draw_circle_gradient(CInt center_x, CInt center_y, float radius, RLColor inner, RLColor outer) @cname("DrawCircleGradient");                                       // Draw a gradient-filled circle
fn void draw_circle_v(RLVector2 center, float radius, RLColor color) @cname("DrawCircleV");                                                                              // Draw a color-filled circle (Vector version)
fn void draw_circle_lines(CInt center_x, CInt center_y, float radius, RLColor color) @cname("DrawCircleLines");                                                          // Draw circle outline
fn void draw_circle_lines_v(RLVector2 center, float radius, RLColor color) @cname("DrawCircleLinesV");                                                                    // Draw circle outline (Vector version)
fn void draw_ellipse(CInt center_x, CInt center_y, float radius_h, float radius_v, RLColor color) @cname("DrawEllipse");                                                  // Draw ellipse
fn void draw_ellipse_lines(CInt center_x, CInt center_y, float radius_h, float radius_v, RLColor color) @cname("DrawEllipseLines");                                        // Draw ellipse outline
fn void draw_ring(RLVector2 center, float inner_radius, float outer_radius, float start_angle, float end_angle, CInt segments, RLColor color) @cname("DrawRing");           // Draw ring
fn void draw_ring_lines(RLVector2 center, float inner_radius, float outer_radius, float start_angle, float end_angle, CInt segments, RLColor color) @cname("DrawRingLines"); // Draw ring outline
fn void draw_rectangle(CInt pos_x, CInt pos_y, CInt width, CInt height, RLColor color) @cname("DrawRectangle");                                                         // Draw a color-filled rectangle
fn void draw_rectangle_v(RLVector2 position, RLVector2 size, RLColor color) @cname("DrawRectangleV");                                                                      // Draw a color-filled rectangle (Vector version)
fn void draw_rectangle_rec(RLRectangle rec, RLColor color) @cname("DrawRectangleRec");                                                                                   // Draw a color-filled rectangle
fn void draw_rectangle_pro(RLRectangle rec, RLVector2 origin, float rotation, RLColor color) @cname("DrawRectanglePro");                                                   // Draw a color-filled rectangle with pro parameters
fn void draw_rectangle_gradient_v(CInt pos_x, CInt pos_y, CInt width, CInt height, RLColor top, RLColor bottom) @cname("DrawRectangleGradientV");                           // Draw a vertical-gradient-filled rectangle
fn void draw_rectangle_gradient_h(CInt pos_x, CInt pos_y, CInt width, CInt height, RLColor left, RLColor right) @cname("DrawRectangleGradientH");                           // Draw a horizontal-gradient-filled rectangle
fn void draw_rectangle_gradient_ex(RLRectangle rec, RLColor top_left, RLColor bottom_left, RLColor top_right, RLColor bottom_right) @cname("DrawRectangleGradientEx");              // Draw a gradient-filled rectangle with custom vertex colors
fn void draw_rectangle_lines(CInt pos_x, CInt pos_y, CInt width, CInt height, RLColor color) @cname("DrawRectangleLines");                                               // Draw rectangle outline
fn void draw_rectangle_lines_ex(RLRectangle rec, float line_thick, RLColor color) @cname("DrawRectangleLinesEx");                                                          // Draw rectangle outline with extended parameters
fn void draw_rectangle_rounded(RLRectangle rec, float roundness, CInt segments, RLColor color) @cname("DrawRectangleRounded");                                           // Draw rectangle with rounded edges
fn void draw_rectangle_rounded_lines(RLRectangle rec, float roundness, CInt segments, RLColor color) @cname("DrawRectangleRoundedLines");                                 // Draw rectangle lines with rounded edges
fn void draw_rectangle_rounded_lines_ex(RLRectangle rec, float roundness, CInt segments, float line_thick, RLColor color) @cname("DrawRectangleRoundedLinesEx");            // Draw rectangle with rounded edges outline
fn void draw_triangle(RLVector2 v1, RLVector2 v2, RLVector2 v3, RLColor color) @cname("DrawTriangle");                                                                      // Draw a color-filled triangle (vertex in counter-clockwise order!)
fn void draw_triangle_lines(RLVector2 v1, RLVector2 v2, RLVector2 v3, RLColor color) @cname("DrawTriangleLines");                                                            // Draw triangle outline (vertex in counter-clockwise order!)
fn void draw_triangle_fan(RLVector2 *points, int point_count, RLColor color) @cname("DrawTriangleFan");                                                                   // Draw a triangle fan defined by points (first vertex is the center)
fn void draw_triangle_strip(RLVector2 *points, int point_count, RLColor color) @cname("DrawTriangleStrip");                                                               // Draw a triangle strip defined by points
fn void draw_poly(RLVector2 center, CInt sides, float radius, float rotation, RLColor color) @cname("DrawPoly");                                                        // Draw a regular polygon (Vector version)
fn void draw_poly_lines(RLVector2 center, CInt sides, float radius, float rotation, RLColor color) @cname("DrawPolyLines");                                              // Draw a polygon outline of n sides
fn void draw_poly_lines_ex(RLVector2 center, CInt sides, float radius, float rotation, float line_thick, RLColor color) @cname("DrawPolyLinesEx");                         // Draw a polygon outline of n sides with extended parameters

// Splines drawing functions
fn void draw_spline_linear(RLVector2 *points, CInt point_count, float thick, RLColor color) @cname("DrawSplineLinear");                                       // Draw spline: Linear, minimum 2 points
fn void draw_spline_basis(RLVector2 *points, CInt point_count, float thick, RLColor color) @cname("DrawSplineBasis");                                         // Draw spline: B-Spline, minimum 4 points
fn void draw_spline_catmull_rom(RLVector2 *points, CInt point_count, float thick, RLColor color) @cname("DrawSplineCatmullRom");                               // Draw spline: Catmull-Rom, minimum 4 points
fn void draw_spline_bezier_quadratic(RLVector2 *points, CInt point_count, float thick, RLColor color) @cname("DrawSplineBezierQuadratic");                     // Draw spline: Quadratic Bezier, minimum 3 points (1 control point): [p1, c2, p3, c4...]
fn void draw_spline_bezier_cubic(RLVector2 *points, CInt point_count, float thick, RLColor color) @cname("DrawSplineBezierCubic");                             // Draw spline: Cubic Bezier, minimum 4 points (2 control points): [p1, c2, c3, p4, c5, c6...]
fn void draw_spline_segment_linear(RLVector2 p1, RLVector2 p2, float thick, RLColor color) @cname("DrawSplineSegmentLinear");                                   // Draw spline segment: Linear, 2 points
fn void draw_spline_segment_basis(RLVector2 p1, RLVector2 p2, RLVector2 p3, RLVector2 p4, float thick, RLColor color) @cname("DrawSplineSegmentBasis");             // Draw spline segment: B-Spline, 4 points
fn void draw_spline_segment_catmull_rom(RLVector2 p1, RLVector2 p2, RLVector2 p3, RLVector2 p4, float thick, RLColor color) @cname("DrawSplineSegmentCatmullRom");   // Draw spline segment: Catmull-Rom, 4 points
fn void draw_spline_segment_bezier_quadratic(RLVector2 p1, RLVector2 c2, RLVector2 p3, float thick, RLColor color) @cname("DrawSplineSegmentBezierQuadratic");     // Draw spline segment: Quadratic Bezier, 2 points, 1 control point
fn void draw_spline_segment_bezier_cubic(RLVector2 p1, RLVector2 c2, RLVector2 c3, RLVector2 p4, float thick, RLColor color) @cname("DrawSplineSegmentBezierCubic"); // Draw spline segment: Cubic Bezier, 2 points, 2 control points

// Spline segment point evaluation functions, for a given t [0.0f .. 1.0f]
fn RLVector2 get_spline_point_linear(RLVector2 start_pos, RLVector2 end_pos, float t) @cname("GetSplinePointLinear");                         // Get (evaluate) spline point: Linear
fn RLVector2 get_spline_point_basis(RLVector2 p1, RLVector2 p2, RLVector2 p3, RLVector2 p4, float t) @cname("GetSplinePointBasis");             // Get (evaluate) spline point: B-Spline
fn RLVector2 get_spline_point_catmull_rom(RLVector2 p1, RLVector2 p2, RLVector2 p3, RLVector2 p4, float t) @cname("GetSplinePointCatmullRom");   // Get (evaluate) spline point: Catmull-Rom
fn RLVector2 get_spline_point_bezier_quad(RLVector2 p1, RLVector2 c2, RLVector2 p3, float t) @cname("GetSplinePointBezierQuad");               // Get (evaluate) spline point: Quadratic Bezier
fn RLVector2 get_spline_point_bezier_cubic(RLVector2 p1, RLVector2 c2, RLVector2 c3, RLVector2 p4, float t) @cname("GetSplinePointBezierCubic"); // Get (evaluate) spline point: Cubic Bezier

// Basic shapes collision detection functions
fn bool check_collision_recs(RLRectangle rec1, RLRectangle rec2) @cname("CheckCollisionRecs");                                                                    // Check collision between two rectangles
fn bool check_collision_circles(RLVector2 center1, float radius1, RLVector2 center2, float radius2) @cname("CheckCollisionCircles");                              // Check collision between two circles
fn bool check_collision_circle_rec(RLVector2 center, float radius, RLRectangle rec) @cname("CheckCollisionCircleRec");                                             // Check collision between circle and rectangle
fn bool check_collision_circle_line(RLVector2 center, float radius, RLVector2 p1, RLVector2 p2) @cname("CheckCollisionCircleLine");                                  // Check if circle collides with a line created betweeen two points [p1] and [p2]
fn bool check_collision_point_rec(RLVector2 point, RLRectangle rec) @cname("CheckCollisionPointRec");                                                              // Check if point is inside rectangle
fn bool check_collision_point_circle(RLVector2 point, RLVector2 center, float radius) @cname("CheckCollisionPointCircle");                                         // Check if point is inside circle
fn bool check_collision_point_triangle(RLVector2 point, RLVector2 p1, RLVector2 p2, RLVector2 p3) @cname("CheckCollisionPointTriangle");                               // Check if point is inside a triangle
fn bool check_collision_point_line(RLVector2 point, RLVector2 p1, RLVector2 p2, CInt threshold) @cname("CheckCollisionPointLine");                                   // Check if point belongs to line created between two points [p1] and [p2] with defined margin in pixels [threshold]
fn bool check_collision_point_poly(RLVector2 point, RLVector2 *points, CInt point_count) @cname("CheckCollisionPointPoly");                                         // Check if point is within a polygon described by array of vertices
fn bool check_collision_lines(RLVector2 start_pos1, RLVector2 end_pos1, RLVector2 start_pos2, RLVector2 end_pos2, RLVector2 *collision_point) @cname("CheckCollisionLines"); // Check the collision between two lines defined by two points each, returns collision point by reference
fn RLRectangle get_collision_rec(RLRectangle rec1, RLRectangle rec2) @cname("GetCollisionRec");                                                                     // Get collision rectangle for two rectangles collision

//------------------------------------------------------------------------------------
// RLTexture Loading and Drawing Functions (Module: textures)
//------------------------------------------------------------------------------------

// RLImage loading functions
// NOTE: These functions do not require GPU access
fn RLImage load_image(ZString file_name) @cname("LoadImage");                                                                          // Load image from file into CPU memory (RAM)
fn RLImage load_image_raw(ZString file_name, CInt width, CInt height, CInt format, CInt headerSize) @cname("LoadImageRaw");             // Load image from RAW file data
fn RLImage load_image_anim(ZString file_name, CInt *frames) @cname("LoadImageAnim");                                                    // Load image sequence from file (frames appended to image.data)
fn RLImage load_image_anim_from_memory(ZString file_type, char* file_data, CInt data_size, CInt *frames) @cname("LoadImageAnimFromMemory"); // Load image sequence from memory buffer
fn RLImage load_image_from_memory(ZString file_type, char* file_data, CInt data_size) @cname("LoadImageFromMemory");                       // Load image from memory buffer, file_type refers to extension: i.e. '.png'
fn RLImage load_image_from_texture(RLTexture2D texture) @cname("LoadImageFromTexture");                                                   // Load image from GPU texture data
fn RLImage load_image_from_screen() @cname("LoadImageFromScreen");                                                                      // Load image from screen buffer and (screenshot)
fn bool is_image_valid(RLImage image) @cname("IsImageValid");                                                                          // Check if an image is valid (data and parameters)
fn void unload_image(RLImage image) @cname("UnloadImage");                                                                            // Unload image from CPU memory (RAM)
fn bool export_image(RLImage image, ZString file_name) @cname("ExportImage");                                                          // Export image data to file, returns true on success
fn char* export_image_to_memory(RLImage image, ZString file_type, CInt *file_size) @cname("ExportImageToMemory");                         // Export image to memory buffer
fn bool export_image_as_code(RLImage image, ZString file_name) @cname("ExportImageAsCode");                                              // Export image as code file defining an array of bytes, returns true on success

// RLImage generation functions
fn RLImage gen_image_color(CInt width, CInt height, RLColor color) @cname("GenImageColor");                                               // Generate image: plain color
fn RLImage gen_image_gradient_linear(CInt width, CInt height, CInt direction, RLColor start, RLColor end) @cname("GenImageGradientLinear");  // Generate image: linear gradient, direction in degrees [0..360], 0=Vertical gradient
fn RLImage gen_image_gradient_radial(CInt width, CInt height, float density, RLColor inner, RLColor outer) @cname("GenImageGradientRadial"); // Generate image: radial gradient
fn RLImage gen_image_gradient_square(CInt width, CInt height, float density, RLColor inner, RLColor outer) @cname("GenImageGradientSquare"); // Generate image: square gradient
fn RLImage gen_image_checked(CInt width, CInt height, CInt checksX, CInt checksY, RLColor col1, RLColor col2) @cname("GenImageChecked");    // Generate image: checked
fn RLImage gen_image_white_noise(CInt width, CInt height, float factor) @cname("GenImageWhiteNoise");                                    // Generate image: white noise
fn RLImage gen_image_perlin_noise(CInt width, CInt height, CInt offset_x, CInt offset_y, float scale) @cname("GenImagePerlinNoise");       // Generate image: perlin noise
fn RLImage gen_image_cellular(CInt width, CInt height, CInt tile_size) @cname("GenImageCellular");                                       // Generate image: cellular algorithm, bigger tile_size means bigger cells
fn RLImage gen_image_text(CInt width, CInt height, ZString text) @cname("GenImageText");                                                // Generate image: grayscale image from text data

// RLImage manipulation functions
fn RLImage image_copy(RLImage image) @cname("ImageCopy");                                                                                        // Create an image duplicate (useful for transformations)
fn RLImage image_from_image(RLImage image, RLRectangle rec) @cname("ImageFromImage");                                                               // Create an image from another image piece
fn RLImage image_from_channel(RLImage image, CInt selected_channel) @cname("ImageFromChannel");                                                    // Create an image from a selected channel of another image (GRAYSCALE)
fn RLImage image_text(ZString text, CInt font_size, RLColor color) @cname("ImageText");                                                           // Create an image from text (default font)
fn RLImage image_text_ex(RLFont font, ZString text, float font_size, float spacing, RLColor tint) @cname("ImageTextEx");                             // Create an image from text (custom sprite font)
fn void image_format(RLImage *image, RLPixelFormat newFormat) @cname("ImageFormat");                                                             // Convert image data to desired format
fn void image_to_pot(RLImage *image, RLColor fill) @cname("ImageToPOT");                                                                          // Convert image to POT (power-of-two)
fn void image_crop(RLImage *image, RLRectangle crop) @cname("ImageCrop");                                                                        // Crop an image to a defined rectangle
fn void image_alpha_crop(RLImage *image, float threshold) @cname("ImageAlphaCrop");                                                             // Crop image depending on alpha value
fn void image_alpha_clear(RLImage *image, RLColor color, float threshold) @cname("ImageAlphaClear");                                              // Clear alpha channel to desired color
fn void image_alpha_mask(RLImage *image, RLImage alpha_mask) @cname("ImageAlphaMask");                                                             // Apply alpha mask to image
fn void image_alpha_premultiply(RLImage *image) @cname("ImageAlphaPremultiply");                                                                // Premultiply alpha channel
fn void image_blur_gaussian(RLImage *image, CInt blur_size) @cname("ImageBlurGaussian");                                                         // Apply Gaussian blur using a box blur approximation
fn void image_kernel_convolution(RLImage *image, float *kernel, CInt kernel_size) @cname("ImageKernelConvolution");                              // Apply custom square convolution kernel to image
fn void image_resize(RLImage *image, CInt new_width, CInt new_height) @cname("ImageResize");                                                     // Resize image (Bicubic scaling algorithm)
fn void image_resize_nn(RLImage *image, CInt new_width,CInt new_height) @cname("ImageResizeNN");                                                  // Resize image (Nearest-Neighbor scaling algorithm)
fn void image_resize_canvas(RLImage *image, CInt new_width, CInt new_height, CInt offset_x, CInt offset_y, RLColor fill) @cname("ImageResizeCanvas"); // Resize canvas and fill with color
fn void image_mipmaps(RLImage *image) @cname("ImageMipmaps");                                                                                  // Compute all mipmap levels for a provided image
fn void image_dither(RLImage *image, CInt rBpp, CInt gBpp, CInt bBpp, CInt aBpp) @cname("ImageDither");                                        // Dither image data to 16bpp or lower (Floyd-Steinberg dithering)
fn void image_flip_vertical(RLImage *image) @cname("ImageFlipVertical");                                                                        // Flip image vertically
fn void image_flip_horizontal(RLImage *image) @cname("ImageFlipHorizontal");                                                                    // Flip image horizontally
fn void image_rotate(RLImage *image, CInt degrees) @cname("ImageRotate");                                                                      // Rotate image by input angle in degrees (-359 to 359)
fn void image_rotate_cw(RLImage *image) @cname("ImageRotateCW");                                                                                // Rotate image clockwise 90deg
fn void image_rotate_ccw(RLImage *image) @cname("ImageRotateCCW");                                                                              // Rotate image counter-clockwise 90deg
fn void image_color_tint(RLImage *image, RLColor color) @cname("ImageColorTint");                                                                 // Modify image color: tint
fn void image_color_invert(RLImage *image) @cname("ImageColorInvert");                                                                          // Modify image color: invert
fn void image_color_grayscale(RLImage *image) @cname("ImageColorGrayscale");                                                                    // Modify image color: grayscale
fn void image_color_contrast(RLImage *image, float contrast) @cname("ImageColorContrast");                                                      // Modify image color: contrast (-100 to 100)
fn void image_color_brightness(RLImage *image, CInt brightness) @cname("ImageColorBrightness");                                                 // Modify image color: brightness (-255 to 255)
fn void image_color_replace(RLImage *image, RLColor color, RLColor replace) @cname("ImageColorReplace");                                            // Modify image color: replace color
fn RLColor *load_image_colors(RLImage image) @cname("LoadImageColors");                                                                           // Load color data from image as a RLColor array (RGBA - 32bit)
fn RLColor *load_image_palette(RLImage image, CInt max_palette_size, CInt *color_count) @cname("LoadImagePalette");                                  // Load colors palette from image as a RLColor array (RGBA - 32bit)
fn void unload_image_colors(RLColor *colors) @cname("UnloadImageColors");                                                                       // Unload color data loaded with LoadImageColors()
fn void unload_image_palette(RLColor *colors) @cname("UnloadImagePalette");                                                                     // Unload colors palette loaded with LoadImagePalette()
fn RLRectangle get_image_alpha_border(RLImage image, float threshold) @cname("GetImageAlphaBorder");                                               // Get image alpha border rectangle
fn RLColor get_image_color(RLImage image, CInt x, CInt y) @cname("GetImageColor");                                                                // Get image pixel color at (x, y) position

// RLImage drawing functions
// NOTE: RLImage software-rendering functions (CPU)
fn void image_clear_background(RLImage *dst, RLColor color) @cname("ImageClearBackground");                                                                // Clear image background with given color
fn void image_draw_pixel(RLImage *dst, CInt pos_x, CInt pos_y, RLColor color) @cname("ImageDrawPixel");                                                      // Draw pixel within an image
fn void image_draw_pixel_v(RLImage *dst, RLVector2 position, RLColor color) @cname("ImageDrawPixelV");                                                        // Draw pixel within an image (Vector version)
fn void image_draw_line(RLImage *dst, CInt start_pos_x, CInt start_pos_y, CInt end_pos_x, CInt end_pos_y, RLColor color) @cname("ImageDrawLine");                  // Draw line within an image
fn void image_draw_line_v(RLImage *dst, RLVector2 start, RLVector2 end, RLColor color) @cname("ImageDrawLineV");                                                // Draw line within an image (Vector version)
fn void image_draw_line_ex(RLImage *dst, RLVector2 start, RLVector2 end, CInt thick, RLColor color) @cname("ImageDrawLineEx");                                  // Draw a line defining thickness within an image
fn void image_draw_circle(RLImage *dst, CInt center_x, CInt center_y, CInt radius, RLColor color) @cname("ImageDrawCircle");                                 // Draw a filled circle within an image
fn void image_draw_circle_v(RLImage *dst, RLVector2 center, CInt radius, RLColor color) @cname("ImageDrawCircleV");                                           // Draw a filled circle within an image (Vector version)
fn void image_draw_circle_lines(RLImage *dst, CInt center_x, CInt center_y, CInt radius, RLColor color) @cname("ImageDrawCircleLines");                       // Draw circle outline within an image
fn void image_draw_circle_lines_v(RLImage *dst, RLVector2 center, CInt radius, RLColor color) @cname("ImageDrawCircleLinesV");                                 // Draw circle outline within an image (Vector version)
fn void image_draw_rectangle(RLImage *dst, CInt pos_x, CInt pos_y, CInt width, CInt height, RLColor color) @cname("ImageDrawRectangle");                     // Draw rectangle within an image
fn void image_draw_rectangle_v(RLImage *dst, RLVector2 position, RLVector2 size, RLColor color) @cname("ImageDrawRectangleV");                                  // Draw rectangle within an image (Vector version)
fn void image_draw_rectangle_rec(RLImage *dst, RLRectangle rec, RLColor color) @cname("ImageDrawRectangleRec");                                               // Draw rectangle within an image
fn void image_draw_rectangle_lines(RLImage *dst, RLRectangle rec, CInt thick, RLColor color) @cname("ImageDrawRectangleLines");                               // Draw rectangle lines within an image
fn void image_draw_triangle(RLImage *dst, RLVector2 v1, RLVector2 v2, RLVector2 v3, RLColor color) @cname("ImageDrawTriangle");                                  // Draw triangle within an image
fn void image_draw_triangle_ex(RLImage *dst, RLVector2 v1, RLVector2 v2, RLVector2 v3, RLColor c1, RLColor c2, RLColor c3) @cname("ImageDrawTriangleEx");             // Draw triangle with interpolated colors within an image
fn void image_draw_triangle_lines(RLImage *dst, RLVector2 v1, RLVector2 v2, RLVector2 v3, RLColor color) @cname("ImageDrawTriangleLines");                        // Draw triangle outline within an image
fn void image_draw_triangle_fan(RLImage *dst, RLVector2 *points, CInt point_count, RLColor color) @cname("ImageDrawTriangleFan");                              // Draw a triangle fan defined by points within an image (first vertex is the center)
fn void image_draw_triangle_strip(RLImage *dst, RLVector2 *points, CInt point_count, RLColor color) @cname("ImageDrawTriangleStrip");                          // Draw a triangle strip defined by points within an image
fn void image_draw(RLImage *dst, RLImage src, RLRectangle srcRec, RLRectangle dstRec, RLColor tint) @cname("ImageDraw");                                        // Draw a source image within a destination image (tint applied to source)
fn void image_draw_text(RLImage *dst, ZString text, CInt pos_x, CInt pos_y, CInt font_size, RLColor color) @cname("ImageDrawText");                           // Draw text (using default font) within an image (destination)
fn void image_draw_text_ex(RLImage *dst, RLFont font, ZString text, RLVector2 position, float font_size, float spacing, RLColor tint) @cname("ImageDrawTextEx"); // Draw text (custom sprite font) within an image (destination)

// RLTexture loading functions
// NOTE: These functions require GPU access
fn RLTexture2D load_texture(ZString file_name) @cname("LoadTexture");                                     // Load texture from file into GPU memory (VRAM)
fn RLTexture2D load_texture_from_image(RLImage image) @cname("LoadTextureFromImage");                        // Load texture from image data
fn RLTextureCubemap load_texture_cubemap(RLImage image, RLCubemapLayout layout) @cname("LoadTextureCubemap"); // Load cubemap from image, multiple image cubemap layouts supported
fn RenderTexture2D load_render_texture(CInt width, CInt height) @cname("LoadRenderTexture");            // Load texture for rendering (framebuffer)
fn bool is_texture_valid(RLTexture2D texture) @cname("IsTextureValid");                                   // Check if a texture is valid (loaded in GPU)
fn void unload_texture(RLTexture2D texture) @cname("UnloadTexture");                                     // Unload texture from GPU memory (VRAM)
fn bool is_render_texture_valid(RenderTexture2D target) @cname("IsRenderTextureValid");                  // Check if a render texture is valid (loaded in GPU)
fn void unload_render_texture(RenderTexture2D target) @cname("UnloadRenderTexture");                    // Unload render texture from GPU memory (VRAM)
fn void update_texture(RLTexture2D texture, void *pixels) @cname("UpdateTexture");                       // Update GPU texture with new data
fn void update_texture_rec(RLTexture2D texture, RLRectangle rec, void *pixels) @cname("UpdateTextureRec");  // Update GPU texture rectangle with new data

// RLTexture configuration functions
fn void gen_texture_mipmaps(RLTexture2D *texture) @cname("GenTextureMipmaps");                    // Generate GPU mipmaps for a texture
fn void set_texture_filter(RLTexture2D texture, RLTextureFilter filter) @cname("SetTextureFilter"); // Set texture scaling filter mode
fn void set_texture_wrap(RLTexture2D texture, RLTextureWrap wrap) @cname("SetTextureWrap");         // Set texture wrapping mode

// RLTexture drawing functions
fn void draw_texture(RLTexture2D texture, CInt pos_x, CInt pos_y, RLColor tint) @cname("DrawTexture");                                                              // Draw a RLTexture2D
fn void draw_texture_v(RLTexture2D texture, RLVector2 position, RLColor tint) @cname("DrawTextureV");                                                                // Draw a RLTexture2D with position defined as RLVector2
fn void draw_texture_ex(RLTexture2D texture, RLVector2 position, float rotation, float scale, RLColor tint) @cname("DrawTextureEx");                                 // Draw a RLTexture2D with extended parameters
fn void draw_texture_rec(RLTexture2D texture, RLRectangle source, RLVector2 position, RLColor tint) @cname("DrawTextureRec");                                          // Draw a part of a texture defined by a rectangle
fn void draw_texture_pro(RLTexture2D texture, RLRectangle source, RLRectangle dest, RLVector2 origin, float rotation, RLColor tint) @cname("DrawTexturePro");            // Draw a part of a texture defined by a rectangle with 'pro' parameters
fn void draw_texture_n_patch(RLTexture2D texture, RLNPatchInfo n_patch_info, RLRectangle dest, RLVector2 origin, float rotation, RLColor tint) @cname("DrawTextureNPatch"); // Draws a texture (or part of it) that stretches or shrinks nicely

// RLColor/pixel related functions
fn bool color_is_equal(RLColor col1, RLColor col2) @cname("ColorIsEqual");                              // Check if two colors are equal
fn RLColor fade(RLColor color, float alpha) @cname("Fade");                                           // Get color with alpha applied, alpha goes from 0.0f to 1.0f
fn CInt color_to_int(RLColor color) @cname("ColorToInt");                                             // Get hexadecimal value for a RLColor (0xRRGGBBAA)
fn RLVector4 color_normalize(RLColor color) @cname("ColorNormalize");                                  // Get RLColor normalized as float [0..1]
fn RLColor color_from_normalized(RLVector4 normalized) @cname("ColorFromNormalized");                   // Get RLColor from normalized values [0..1]
fn RLVector3 color_to_h_s_v(RLColor color) @cname("ColorToHSV");                                          // Get HSV values for a RLColor, hue [0..360], saturation/value [0..1]
fn RLColor color_from_h_s_v(float hue, float saturation, float value) @cname("ColorFromHSV");           // Get a RLColor from HSV values, hue [0..360], saturation/value [0..1]
fn RLColor color_tint(RLColor color, RLColor tint) @cname("ColorTint");                                  // Get color multiplied with another color
fn RLColor color_brightness(RLColor color, float factor) @cname("ColorBrightness");                    // Get color with brightness correction, brightness factor goes from -1.0f to 1.0f
fn RLColor color_contrast(RLColor color, float contrast) @cname("ColorContrast");                      // Get color with contrast correction, contrast values between -1.0f and 1.0f
fn RLColor color_alpha(RLColor color, float alpha) @cname("ColorAlpha");                               // Get color with alpha applied, alpha goes from 0.0f to 1.0f
fn RLColor color_alpha_blend(RLColor dst, RLColor src, RLColor tint) @cname("ColorAlphaBlend");             // Get src alpha-blended into dst color with tint
fn RLColor color_lerp(RLColor color1, RLColor color2, float factor) @cname("ColorLerp");                 // Get color lerp interpolation between two colors, factor [0.0f..1.0f]
fn RLColor get_color(CUInt hex_value) @cname("GetColor");                                             // Get RLColor structure from hexadecimal value
fn RLColor get_pixel_color(void *src_ptr, RLPixelFormat format) @cname("GetPixelColor");                 // Get RLColor from a source pixel pointer of certain format
fn void set_pixel_color(void *dst_ptr, RLColor color, RLPixelFormat format) @cname("SetPixelColor");     // Set color formatted into destination pixel pointer
fn CInt get_pixel_data_size(CInt width, CInt height, RLPixelFormat format) @cname("GetPixelDataSize"); // Get pixel data size in bytes for certain format

//------------------------------------------------------------------------------------
// RLFont Loading and Text Drawing Functions (Module: text)
//------------------------------------------------------------------------------------

// RLFont loading/unloading functions
fn RLFont get_font_default() @cname("GetFontDefault");                                                                                                               // Get the default RLFont
fn RLFont load_font(ZString file_name) @cname("LoadFont");                                                                                                           // Load font from file into GPU memory (VRAM)
fn RLFont load_font_ex(ZString file_name, CInt font_size, CInt *codepoints, CInt codepoint_count) @cname("LoadFontEx");                                                 // Load font from file with extended parameters, use NULL for codepoints and 0 for codepoint_count to load the default character set, font size is provided in pixels height
fn RLFont load_font_from_image(RLImage image, RLColor key, CInt firstChar) @cname("LoadFontFromImage");                                                                   // Load font from RLImage (XNA style)
fn RLFont load_font_from_memory(ZString file_type, char* file_data, CInt data_size, CInt font_size, CInt *codepoints, CInt codepoint_count) @cname("LoadFontFromMemory");  // Load font from memory buffer, file_type refers to extension: i.e. '.ttf'
fn bool is_font_valid(RLFont font) @cname("IsFontValid");                                                                                                            // Check if a font is valid (font data loaded, WARNING: GPU texture not checked)
fn RLGlyphInfo *load_font_data(char* file_data, CInt data_size, CInt font_size, CInt *codepoints, CInt codepoint_count, RLFontType type) @cname("LoadFontData");           // Load font data for further use
fn RLImage gen_image_font_atlas(RLGlyphInfo *glyphs, RLRectangle **glyphRecs, CInt glyph_count, CInt font_size, CInt padding, CInt pack_method) @cname("GenImageFontAtlas"); // Generate image font atlas using chars info
fn void unload_font_data(RLGlyphInfo *glyphs, CInt glyph_count) @cname("UnloadFontData");                                                                             // Unload font chars info data (RAM)
fn void unload_font(RLFont font) @cname("UnloadFont");                                                                                                              // Unload font from GPU memory (VRAM)
fn bool export_font_as_code(RLFont font, ZString file_name) @cname("ExportFontAsCode");                                                                                // Export font as code file, returns true on success

// Text drawing functions
fn void draw_fps(CInt pos_x, CInt pos_y) @cname("DrawFPS");                                                                                                                // Draw current FPS
fn void draw_text(ZString text, CInt pos_x, CInt pos_y, CInt font_size, RLColor color) @cname("DrawText");                                                                    // Draw text (using default font)
fn void draw_text_ex(RLFont font, ZString text, RLVector2 position, float font_size, float spacing, RLColor tint) @cname("DrawTextEx");                                          // Draw text using font and additional parameters
fn void draw_text_pro(RLFont font, ZString text, RLVector2 position, RLVector2 origin, float rotation, float font_size, float spacing, RLColor tint) @cname("DrawTextPro");        // Draw text using RLFont and pro parameters (rotation)
fn void draw_text_codepoint(RLFont font, CInt codepoint, RLVector2 position, float font_size, RLColor tint) @cname("DrawTextCodepoint");                                         // Draw one character (codepoint)
fn void draw_text_codepoints(RLFont font, CInt *codepoints, CInt codepoint_count, RLVector2 position, float font_size, float spacing, RLColor tint) @cname("DrawTextCodepoints"); // Draw multiple character (codepoint)

// Text font info functions
fn void set_text_line_spacing(CInt spacing) @cname("SetTextLineSpacing");                                    // Set vertical line spacing when drawing with line-breaks
fn CInt measure_text(ZString text, CInt font_size) @cname("MeasureText");                                   // Measure string width for default font
fn RLVector2 measure_text_ex(RLFont font, ZString text, float font_size, float spacing) @cname("MeasureTextEx"); // Measure string size for RLFont
fn CInt get_glyph_index(RLFont font, CInt codepoint) @cname("GetGlyphIndex");                                 // Get glyph index position in font for a codepoint (unicode character), fallback to '?' if not found
fn RLGlyphInfo get_glyph_info(RLFont font, CInt codepoint) @cname("GetGlyphInfo");                              // Get glyph font info data for a codepoint (unicode character), fallback to '?' if not found
fn RLRectangle get_glyph_atlas_rec(RLFont font, CInt codepoint) @cname("GetGlyphAtlasRec");                      // Get glyph rectangle in font atlas for a codepoint (unicode character), fallback to '?' if not found

// Text codepoints management functions (unicode characters)
fn char *load_utf8(CInt *codepoints, CInt length) @cname("LoadUTF8");                            // Load UTF-8 text encoded from codepoints array
fn void unload_utf8(char *text) @cname("UnloadUTF8");                                            // Unload UTF-8 text encoded from codepoints array
fn CInt *load_codepoints(ZString text, CInt *count) @cname("LoadCodepoints");                    // Load all codepoints from a UTF-8 text string, codepoints count returned by parameter
fn void unload_codepoints(CInt *codepoints) @cname("UnloadCodepoints");                          // Unload codepoints data from memory
fn CInt get_codepoint_count(ZString text) @cname("GetCodepointCount");                            // Get total number of codepoints in a UTF-8 encoded string
fn CInt get_codepoint(ZString text, CInt *codepoint_size) @cname("GetCodepoint");                 // Get next codepoint in a UTF-8 encoded string, 0x3f('?') is returned on failure
fn CInt get_codepoint_next(ZString text, CInt *codepoint_size) @cname("GetCodepointNext");         // Get next codepoint in a UTF-8 encoded string, 0x3f('?') is returned on failure
fn CInt get_codepoint_previous(ZString text, CInt *codepoint_size) @cname("GetCodepointPrevious"); // Get previous codepoint in a UTF-8 encoded string, 0x3f('?') is returned on failure
fn ZString codepoint_to_utf8(CInt codepoint, CInt *utf8_size) @cname("CodepointToUTF8");           // Encode one codepoint into UTF-8 byte array (array length returned as parameter)

// Text strings management functions (no UTF-8 strings, only byte chars)
// NOTE: Some strings allocate memory internally for returned strings, just be careful!
fn CInt text_copy(ZString dst, ZString src) @cname("TextCopy");                            // Copy one string to another, returns bytes copied
fn bool text_is_equal(ZString text1, ZString text2) @cname("TextIsEqual");                  // Check if two text string are equal
fn CUInt text_length(ZString text) @cname("TextLength");                                   // Get text length, checks for '\0' ending
fn ZString text_format(ZString text, ...) @cname("TextFormat");                            // Text formatting with variables (sprCIntf() style)
fn ZString text_subtext(ZString text, CInt position, CInt length) @cname("TextSubtext");   // Get a piece of a text string
fn char *text_replace(ZString text, ZString replace, ZString by) @cname("TextReplace");    // Replace text string (WARNING: memory must be freed!)
fn char *text_insert(ZString text, ZString insert, CInt position) @cname("TextInsert");    // Insert text in a position (WARNING: memory must be freed!)
fn ZString text_join(ZString *textList, CInt count, ZString delimiter) @cname("TextJoin"); // Join text strings with delimiter
fn ZString *text_split(ZString text, char delimiter, CInt *count) @cname("TextSplit");     // Split text CInto multiple strings
fn void text_append(char *text, ZString append, CInt *position) @cname("TextAppend");      // Append text at specific position and move cursor!
fn CInt text_find_index(ZString text, ZString find) @cname("TextFindIndex");                // Find first text occurrence within a string
fn ZString text_to_upper(ZString text) @cname("TextToUpper");                               // Get upper case version of provided string
fn ZString text_to_lower(ZString text) @cname("TextToLower");                               // Get lower case version of provided string
fn ZString text_to_pascal(ZString text) @cname("TextToPascal");                             // Get Pascal case notation version of provided string
fn ZString text_to_snake(ZString text) @cname("TextToSnake");                               // Get Snake case notation version of provided string
fn ZString text_to_camel(ZString text) @cname("TextToCamel");                               // Get Camel case notation version of provided string

fn CInt text_to_integer(ZString text) @cname("TextToInteger");                              // Get integer value from text (negative values not supported)
fn float text_to_float(ZString text) @cname("TextToFloat");                                 // Get float value from text (negative values not supported)

//------------------------------------------------------------------------------------
// Basic 3d Shapes Drawing Functions (Module: models)
//------------------------------------------------------------------------------------

// Basic geometric 3D shapes drawing functions
fn void draw_line3d(RLVector3 start_pos, RLVector3 end_pos, RLColor color) @cname("DrawLine3D");                                                                   // Draw a line in 3D world space
fn void draw_point3d(RLVector3 position, RLColor color) @cname("DrawPoint3D");                                                                                 // Draw a point in 3D space, actually a small line
fn void draw_circle3d(RLVector3 center, float radius, RLVector3 rotation_axis, float rotation_angle, RLColor color) @cname("DrawCircle3D");                        // Draw a circle in 3D world space
fn void draw_triangle3d(RLVector3 v1, RLVector3 v2, RLVector3 v3, RLColor color) @cname("DrawTriangle3D");                                                         // Draw a color-filled triangle (vertex in counter-clockwise order!)
fn void draw_triangle_strip3d(RLVector3 *points, CInt point_count, RLColor color) @cname("DrawTriangleStrip3D");                                                 // Draw a triangle strip defined by points
fn void draw_cube(RLVector3 position, float width, float height, float length, RLColor color) @cname("DrawCube");                                              // Draw cube
fn void draw_cube_v(RLVector3 position, RLVector3 size, RLColor color) @cname("DrawCubeV");                                                                       // Draw cube (Vector version)
fn void draw_cube_wires(RLVector3 position, float width, float height, float length, RLColor color) @cname("DrawCubeWires");                                    // Draw cube wires
fn void draw_cube_wires_v(RLVector3 position, RLVector3 size, RLColor color) @cname("DrawCubeWiresV");                                                             // Draw cube wires (Vector version)
fn void draw_sphere(RLVector3 centerPos, float radius, RLColor color) @cname("DrawSphere");                                                                    // Draw sphere
fn void draw_sphere_ex(RLVector3 centerPos, float radius, CInt rings, CInt slices, RLColor color) @cname("DrawSphereEx");                                       // Draw sphere with extended parameters
fn void draw_sphere_wires(RLVector3 centerPos, float radius, CInt rings, CInt slices, RLColor color) @cname("DrawSphereWires");                                 // Draw sphere wires
fn void draw_cylinder(RLVector3 position, float radius_top, float radius_bottom, float height, CInt slices, RLColor color) @cname("DrawCylinder");               // Draw a cylinder/cone
fn void draw_cylinder_ex(RLVector3 start_pos, RLVector3 end_pos, float start_radius, float end_radius, CInt sides, RLColor color) @cname("DrawCylinderEx");           // Draw a cylinder with base at start_pos and top at end_pos
fn void draw_cylinder_wires(RLVector3 position, float radius_top, float radius_bottom, float height, CInt slices, RLColor color) @cname("DrawCylinderWires");     // Draw a cylinder/cone wires
fn void draw_cylinder_wires_ex(RLVector3 start_pos, RLVector3 end_pos, float start_radius, float end_radius, CInt sides, RLColor color) @cname("DrawCylinderWiresEx"); // Draw a cylinder wires with base at start_pos and top at end_pos
fn void draw_capsule(RLVector3 start_pos, RLVector3 end_pos, float radius, CInt slices, CInt rings, RLColor color) @cname("DrawCapsule");                          // Draw a capsule with the center of its sphere caps at start_pos and end_pos
fn void draw_capsule_wires(RLVector3 start_pos, RLVector3 end_pos, float radius, CInt slices, CInt rings, RLColor color) @cname("DrawCapsuleWires");                // Draw capsule wireframe with the center of its sphere caps at start_pos and end_pos
fn void draw_plane(RLVector3 centerPos, RLVector2 size, RLColor color) @cname("DrawPlane");                                                                      // Draw a plane XZ
fn void draw_ray(RLRay ray, RLColor color) @cname("DrawRay");                                                                                                  // Draw a ray line
fn void draw_grid(CInt slices, float spacing) @cname("DrawGrid");                                                                                          // Draw a grid (centered at (0, 0, 0))

//------------------------------------------------------------------------------------
// RLModel 3d Loading and Drawing Functions (Module: models)
//------------------------------------------------------------------------------------

// RLModel management functions
fn RLModel load_model(ZString file_name) @cname("LoadModel");                      // Load model from files (meshes and materials)
fn RLModel load_model_from_mesh(RLMesh mesh) @cname("LoadModelFromMesh");             // Load model from generated mesh (default material)
fn bool is_model_valid(RLModel model) @cname("IsModelValid");                      // Check if a model is valid (loaded in GPU, VAO/VBOs)
fn void unload_model(RLModel model) @cname("UnloadModel");                        // Unload model (including meshes) from memory (RAM and/or VRAM)
fn RLBoundingBox get_model_bounding_box(RLModel model) @cname("GetModelBoundingBox"); // Compute model bounding box limits (considers all meshes)

// RLModel drawing functions
fn void draw_model(RLModel model, RLVector3 position, float scale, RLColor tint) @cname("DrawModel");                                                                                                   // Draw a model (with texture if set)
fn void draw_model_ex(RLModel model, RLVector3 position, RLVector3 rotation_axis, float rotation_angle, RLVector3 scale, RLColor tint) @cname("DrawModelEx");                                                  // Draw a model with extended parameters
fn void draw_model_wires(RLModel model, RLVector3 position, float scale, RLColor tint) @cname("DrawModelWires");                                                                                         // Draw a model wires (with texture if set)
fn void draw_model_wires_ex(RLModel model, RLVector3 position, RLVector3 rotation_axis, float rotation_angle, RLVector3 scale, RLColor tint) @cname("DrawModelWiresEx");                                        // Draw a model wires (with texture if set) with extended parameters
fn void draw_model_points(RLModel model, RLVector3 position, float scale, RLColor tint) @cname("DrawModelPoints");                                                                                       // Draw a model as points
fn void draw_model_points_ex(RLModel model, RLVector3 position, RLVector3 rotation_axis, float rotation_angle, RLVector3 scale, RLColor tint) @cname("DrawModelPointsEx");                                      // Draw a model as points with extended parameters
fn void draw_bounding_box(RLBoundingBox box, RLColor color) @cname("DrawBoundingBox");                                                                                                                 // Draw bounding box (wires)
fn void draw_billboard(RLCamera camera, RLTexture2D texture, RLVector3 position, float scale, RLColor tint) @cname("DrawBillboard");                                                                      // Draw a billboard texture
fn void draw_billboard_rec(RLCamera camera, RLTexture2D texture, RLRectangle source, RLVector3 position, RLVector2 size, RLColor tint) @cname("DrawBillboardRec");                                             // Draw a billboard texture defined by source
fn void draw_billboard_pro(RLCamera camera, RLTexture2D texture, RLRectangle source, RLVector3 position, RLVector3 up, RLVector2 size, RLVector2 origin, float rotation, RLColor tint) @cname("DrawBillboardPro"); // Draw a billboard texture defined by source and rotation

// RLMesh management functions
fn void upload_mesh(RLMesh *mesh, bool dynamic) @cname("UploadMesh");                                                       // Upload mesh vertex data in GPU and provide VAO/VBO ids
fn void update_mesh_buffer(RLMesh mesh, CInt index, void *data, CInt data_size, CInt offset) @cname("UpdateMeshBuffer");      // Update mesh vertex data in GPU for a specific buffer index
fn void unload_mesh(RLMesh mesh) @cname("UnloadMesh");                                                                      // Unload mesh data from CPU and GPU
fn void draw_mesh(RLMesh mesh, RLMaterial material, RLMatrix transform) @cname("DrawMesh");                                     // Draw a 3d mesh with material and transform
fn void draw_mesh_instanced(RLMesh mesh, RLMaterial material, RLMatrix *transforms, CInt instances) @cname("DrawMeshInstanced"); // Draw multiple mesh instances with material and different transforms
fn RLBoundingBox get_mesh_bounding_box(RLMesh mesh) @cname("GetMeshBoundingBox");                                               // Compute mesh bounding box limits
fn void gen_mesh_tangents(RLMesh *mesh) @cname("GenMeshTangents");                                                           // Compute mesh tangents
fn bool export_mesh(RLMesh mesh, ZString file_name) @cname("ExportMesh");                                                    // Export mesh data to file, returns true on success
fn bool export_mesh_as_code(RLMesh mesh, ZString file_name) @cname("ExportMeshAsCode");                                        // Export mesh as code file (.h) defining multiple arrays of vertex attributes

// RLMesh generation functions
fn RLMesh gen_mesh_poly(CInt sides, float radius) @cname("GenMeshPoly");                            // Generate polygonal mesh
fn RLMesh gen_mesh_plane(float width, float length, CInt res_x, CInt res_z) @cname("GenMeshPlane");   // Generate plane mesh (with subdivisions)
fn RLMesh gen_mesh_cube(float width, float height, float length) @cname("GenMeshCube");             // Generate cuboid mesh
fn RLMesh gen_mesh_sphere(float radius, CInt rings, CInt slices) @cname("GenMeshSphere");           // Generate sphere mesh (standard sphere)
fn RLMesh gen_mesh_hemi_sphere(float radius, CInt rings, CInt slices) @cname("GenMeshHemiSphere");   // Generate half-sphere mesh (no bottom cap)
fn RLMesh gen_mesh_cylinder(float radius, float height, CInt slices) @cname("GenMeshCylinder");     // Generate cylinder mesh
fn RLMesh gen_mesh_cone(float radius, float height, CInt slices) @cname("GenMeshCone");             // Generate cone/pyramid mesh
fn RLMesh gen_mesh_torus(float radius, float size, CInt rad_seg, CInt sides) @cname("GenMeshTorus"); // Generate torus mesh
fn RLMesh gen_mesh_knot(float radius, float size, CInt rad_seg, CInt sides) @cname("GenMeshKnot");   // Generate trefoil knot mesh
fn RLMesh gen_mesh_heightmap(RLImage heightmap, RLVector3 size) @cname("GenMeshHeightmap");             // Generate heightmap mesh from image data
fn RLMesh gen_mesh_cubicmap(RLImage cubicmap, RLVector3 cube_size) @cname("GenMeshCubicmap");            // Generate cubes-based map mesh from image data

// RLMaterial loading/unloading functions
fn RLMaterial *load_materials(ZString file_name, CInt *materialCount) @cname("LoadMaterials");                                // Load materials from model file
fn RLMaterial load_material_default() @cname("LoadMaterialDefault");                                                          // Load default material (Supports: DIFFUSE, SPECULAR, NORMAL maps)
fn bool is_material_valid(RLMaterial material) @cname("IsMaterialValid");                                                     // Check if a material is valid (shader assigned, map textures loaded in GPU)
fn void unload_material(RLMaterial material) @cname("UnloadMaterial");                                                       // Unload material from GPU memory (VRAM)
fn void set_material_texture(RLMaterial *material, RLMaterialMapIndex mapType, RLTexture2D texture) @cname("SetMaterialTexture"); // Set texture for a material map type (MATERIAL_MAP_DIFFUSE, MATERIAL_MAP_SPECULAR...)
fn void set_model_mesh_material(RLModel *model, CInt meshId, CInt materialId) @cname("SetModelMeshMaterial");                  // Set material for a mesh

// RLModel animations loading/unloading functions
fn RLModelAnimation *load_model_animations(ZString file_name, CInt *anim_count) @cname("LoadModelAnimations");             // Load model animations from file
fn void update_model_animation(RLModel model, RLModelAnimation anim, CInt frame) @cname("UpdateModelAnimation");           // Update model animation pose (CPU)
fn void update_model_animation_bones(RLModel model, RLModelAnimation anim, CInt frame) @cname("UpdateModelAnimationBones"); // Update model animation mesh bone matrices (GPU skinning)
fn void unload_model_animation(RLModelAnimation anim) @cname("UnloadModelAnimation");                                    // Unload animation data
fn void unload_model_animations(RLModelAnimation *animations, CInt anim_count) @cname("UnloadModelAnimations");           // Unload animation array data
fn bool is_model_animation_valid(RLModel model, RLModelAnimation anim) @cname("IsModelAnimationValid");                     // Check model animation skeleton match

// Collision detection functions
fn bool check_collision_spheres(RLVector3 center1, float radius1, RLVector3 center2, float radius2) @cname("CheckCollisionSpheres"); // Check collision between two spheres
fn bool check_collision_boxes(RLBoundingBox box1, RLBoundingBox box2) @cname("CheckCollisionBoxes");                                 // Check collision between two bounding boxes
fn bool check_collision_box_sphere(RLBoundingBox box, RLVector3 center, float radius) @cname("CheckCollisionBoxSphere");              // Check collision between box and sphere
fn RLRayCollision get_ray_collision_sphere(RLRay ray, RLVector3 center, float radius) @cname("GetRayCollisionSphere");                  // Get collision info between ray and sphere
fn RLRayCollision get_ray_collision_box(RLRay ray, RLBoundingBox box) @cname("GetRayCollisionBox");                                     // Get collision info between ray and box
fn RLRayCollision get_ray_collision_mesh(RLRay ray, RLMesh mesh, RLMatrix transform) @cname("GetRayCollisionMesh");                       // Get collision info between ray and mesh
fn RLRayCollision get_ray_collision_triangle(RLRay ray, RLVector3 p1, RLVector3 p2, RLVector3 p3) @cname("GetRayCollisionTriangle");        // Get collision info between ray and triangle
fn RLRayCollision get_ray_collision_quad(RLRay ray, RLVector3 p1, RLVector3 p2, RLVector3 p3, RLVector3 p4) @cname("GetRayCollisionQuad");    // Get collision info between ray and quad

//------------------------------------------------------------------------------------
// Audio Loading and Playing Functions (Module: audio)
//------------------------------------------------------------------------------------
alias AudioCallback = fn void(void *bufferData, CUInt frames);

// Audio device management functions
fn void init_audio_device() @cname("InitAudioDevice");             // Initialize audio device and context
fn void close_audio_device() @cname("CloseAudioDevice");           // Close the audio device and context
fn bool is_audio_device_ready() @cname("IsAudioDeviceReady");       // Check if audio device has been initialized successfully
fn void set_master_volume(float volume) @cname("SetMasterVolume"); // Set master volume (listener)
fn float get_master_volume() @cname("GetMasterVolume");            // Get master volume (listener)

// Wave/Sound loading/unloading functions
fn RLWave load_wave(ZString file_name) @cname("LoadWave");                                                    // Load wave data from file
fn RLWave load_wave_from_memory(ZString file_type, char* file_data, CInt data_size) @cname("LoadWaveFromMemory"); // Load wave from memory buffer, file_type refers to extension: i.e. '.wav'
fn bool is_wave_valid(RLWave wave) @cname("IsWaveValid");                                                     // Checks if wave data is valid (data loaded and parameters)
fn RLSound load_sound(ZString file_name) @cname("LoadSound");                                                 // Load sound from file
fn RLSound load_sound_from_wave(RLWave wave) @cname("LoadSoundFromWave");                                        // Load sound from wave data
fn RLSound load_sound_alias(RLSound source) @cname("LoadSoundAlias");                                           // Create a new sound that shares the same sample data as the source sound, does not own the sound data
fn bool is_sound_valid(RLSound sound) @cname("IsSoundValid");                                                 // Checks if a sound is valid (data loaded and buffers initialized)
fn void update_sound(RLSound sound, void *data, CInt sampleCount) @cname("UpdateSound");                     // Update sound buffer with new data
fn void unload_wave(RLWave wave) @cname("UnloadWave");                                                       // Unload wave data
fn void unload_sound(RLSound sound) @cname("UnloadSound");                                                   // Unload sound
fn void unload_sound_alias(RLSound alias_) @cname("UnloadSoundAlias");                                        // Unload a sound alias (does not deallocate sample data)
fn bool export_wave(RLWave wave, ZString file_name) @cname("ExportWave");                                     // Export wave data to file, returns true on success
fn bool export_wave_as_code(RLWave wave, ZString file_name) @cname("ExportWaveAsCode");                         // Export wave sample data to code (.h), returns true on success

// Wave/Sound management functions
fn void play_sound(RLSound sound) @cname("PlaySound");                                                   // Play a sound
fn void stop_sound(RLSound sound) @cname("StopSound");                                                   // Stop playing a sound
fn void pause_sound(RLSound sound) @cname("PauseSound");                                                 // Pause a sound
fn void resume_sound(RLSound sound) @cname("ResumeSound");                                               // Resume a paused sound
fn bool is_sound_playing(RLSound sound) @cname("IsSoundPlaying");                                         // Check if a sound is currently playing
fn void set_sound_volume(RLSound sound, float volume) @cname("SetSoundVolume");                           // Set volume for a sound (1.0 is max level)
fn void set_sound_pitch(RLSound sound, float pitch) @cname("SetSoundPitch");                              // Set pitch for a sound (1.0 is base level)
fn void set_sound_pan(RLSound sound, float pan) @cname("SetSoundPan");                                    // Set pan for a sound (0.5 is center)
fn RLWave wave_copy(RLWave wave) @cname("WaveCopy");                                                       // Copy a wave to a new wave
fn void wave_crop(RLWave *wave, CInt initFrame, CInt finalFrame) @cname("WaveCrop");                     // Crop a wave to defined frames range
fn void wave_format(RLWave *wave, CInt sample_rate, CInt sample_size, CInt channels) @cname("WaveFormat"); // Convert wave data to desired format
fn float *load_wave_samples(RLWave wave) @cname("LoadWaveSamples");                                       // Load samples data from wave as a 32bit float data array
fn void unload_wave_samples(float *samples) @cname("UnloadWaveSamples");                                // Unload samples data loaded with LoadWaveSamples()

// Music management functions
fn RLMusic load_music_stream(ZString file_name) @cname("LoadMusicStream");                                                // Load music stream from file
fn RLMusic load_music_stream_from_memory(ZString file_type, char* data, CInt data_size) @cname("LoadMusicStreamFromMemory"); // Load music stream from data
fn bool is_music_valid(RLMusic music) @cname("IsMusicValid");                                                            // Checks if a music stream is valid (context and buffers initialized)
fn void unload_music_stream(RLMusic music) @cname("UnloadMusicStream");                                                  // Unload music stream
fn void play_music_stream(RLMusic music) @cname("PlayMusicStream");                                                      // Start music playing
fn bool is_music_stream_playing(RLMusic music) @cname("IsMusicStreamPlaying");                                            // Check if music is playing
fn void update_music_stream(RLMusic music) @cname("UpdateMusicStream");                                                  // Updates buffers for music streaming
fn void stop_music_stream(RLMusic music) @cname("StopMusicStream");                                                      // Stop music playing
fn void pause_music_stream(RLMusic music) @cname("PauseMusicStream");                                                    // Pause music playing
fn void resume_music_stream(RLMusic music) @cname("ResumeMusicStream");                                                  // Resume playing paused music
fn void seek_music_stream(RLMusic music, float position) @cname("SeekMusicStream");                                      // Seek music to a position (in seconds)
fn void set_music_volume(RLMusic music, float volume) @cname("SetMusicVolume");                                          // Set volume for music (1.0 is max level)
fn void set_music_pitch(RLMusic music, float pitch) @cname("SetMusicPitch");                                             // Set pitch for a music (1.0 is base level)
fn void set_music_pan(RLMusic music, float pan) @cname("SetMusicPan");                                                   // Set pan for a music (0.5 is center)
fn float get_music_time_length(RLMusic music) @cname("GetMusicTimeLength");                                               // Get music time length (in seconds)
fn float get_music_time_played(RLMusic music) @cname("GetMusicTimePlayed");                                               // Get current music time played (in seconds)

// AudioStream management functions
fn RLAudioStream load_audio_stream(CUInt sample_rate, CUInt sample_size, CUInt channels) @cname("LoadAudioStream"); // Load audio stream (to stream raw audio pcm data)
fn bool is_audio_stream_valid(RLAudioStream stream) @cname("IsAudioStreamValid");                                  // Checks if an audio stream is valid (buffers initialized)
fn void unload_audio_stream(RLAudioStream stream) @cname("UnloadAudioStream");                                    // Unload audio stream and free memory
fn void update_audio_stream(RLAudioStream stream, void *data, CInt frameCount) @cname("UpdateAudioStream");       // Update audio stream buffers with data
fn bool is_audio_stream_processed(RLAudioStream stream) @cname("IsAudioStreamProcessed");                          // Check if any audio stream buffers requires refill
fn void play_audio_stream(RLAudioStream stream) @cname("PlayAudioStream");                                        // Play audio stream
fn void pause_audio_stream(RLAudioStream stream) @cname("PauseAudioStream");                                      // Pause audio stream
fn void resume_audio_stream(RLAudioStream stream) @cname("ResumeAudioStream");                                    // Resume audio stream
fn bool is_audio_stream_playing(RLAudioStream stream) @cname("IsAudioStreamPlaying");                              // Check if audio stream is playing
fn void stop_audio_stream(RLAudioStream stream) @cname("StopAudioStream");                                        // Stop audio stream
fn void set_audio_stream_volume(RLAudioStream stream, float volume) @cname("SetAudioStreamVolume");                // Set volume for audio stream (1.0 is max level)
fn void set_audio_stream_pitch(RLAudioStream stream, float pitch) @cname("SetAudioStreamPitch");                   // Set pitch for audio stream (1.0 is base level)
fn void set_audio_stream_pan(RLAudioStream stream, float pan) @cname("SetAudioStreamPan");                         // Set pan for audio stream (0.5 is centered)
fn void set_audio_stream_buffer_size_default(CInt size) @cname("SetAudioStreamBufferSizeDefault");                 // Default size for new audio streams
fn void set_audio_stream_callback(RLAudioStream stream, AudioCallback callback) @cname("SetAudioStreamCallback");  // Audio thread callback to request new data

fn void attach_audio_stream_processor(RLAudioStream stream, AudioCallback processor) @cname("AttachAudioStreamProcessor"); // Attach audio stream processor to stream, receives the samples as 'float'
fn void detach_audio_stream_processor(RLAudioStream stream, AudioCallback processor) @cname("DetachAudioStreamProcessor"); // Detach audio stream processor from stream

fn void attach_audio_mixed_processor(AudioCallback processor) @cname("AttachAudioMixedProcessor"); // Attach audio stream processor to the entire audio pipeline, receives the samples as 'float'
fn void detach_audio_mixed_processor(AudioCallback processor) @cname("DetachAudioMixedProcessor"); // Detach audio stream processor from the entire audio pipeline


//----------------------------------------------------------------------------------
// Additional Raylib.c3 Mode helper macros
//----------------------------------------------------------------------------------

<*
 Setup canvas (framebuffer) to start drawing, then calls [block].
 Drawing will end after [block] has finished.
*>
macro void @drawing(;@body)
{
	begin_drawing();
	defer end_drawing();
	@body();
}

<*
 Setup 2D mode with custom camera to start 2D Mode, then calls [block].
 Mode2D will end after [block] has finished.
*>
macro void @mode2d(RLCamera2D camera ;@body)
{
	begin_mode2d(camera);
	defer end_mode2d();
	@body();
}

<*
 Setup 3D mode with custom camera to start 2D Mode, then calls [block].
 Mode2D will end after [block] has finished.
*>
macro void @mode3d(RLCamera3D camera ;@body)
{
	begin_mode3d(camera);
	defer end_mode3d();
	@body();
}

<*
 Setup texture mode to draw to render texture, then calls [block].
 texture mode will end after [block] has finished.
*>
macro void @texture_mode(RenderTexture2D texture ;@body)
{
	begin_texture_mode(texture);
	defer end_texture_mode();
	@body();
}


<*
 Setup custom shqder mode then calls [block].
 shader mode will end after [block] has finished.
*>
macro void @shader_mode(RLShader shader ;@body)
{
	begin_shader_mode(shader);
	defer end_shader_mode();
	@body();
}

<*
 Setup blending mode, then calls [block].
 blend mode will end after [block] has finished.
*>
macro void @blend_mode(RLBlendMode mode ;@body)
{
	begin_blend_mode(mode);
	defer end_blend_mode();
	@body();
}

<*
 Setup scissor mode then calls [block].
 scissor mode will end after [block] has finished.
*>
macro void @scissor_mode(CInt x, CInt y, CInt width, CInt height ;@body)
{
	begin_scissor_mode(x, y, width, height);
	defer end_scissor_mode();
	@body();
}

<*
 Setup stereo rendering mode, then calls [block].
 stereo rendering mode will end after [block] has finished.
*>
macro void @vr_mode(RLVrStereoConfig config ;@body)
{
	begin_vr_stereo_mode(config);
	defer end_vr_stereo_mode();
	@body();
}


<*
 Setup rl drawing mode, then calls [block].
 rl_begin will end after [block] has finished.
*>
macro void @rl_mode(CInt mode ;@body)
{
	rl_begin(mode);
	defer rl_end();
	@body();
}

//----------------------------------------------------------------------------------
// Enumerators Definition
//----------------------------------------------------------------------------------
// System/Window config flags
// NOTE: Every bit registers one state (use it with bit masks)
// By default all flags are set to 0

enum ConfigFlag : const uint
{
	VSYNC_HINT         = 0x00000040,   // Set to try enabling V-Sync on GPU
	FULLSCREEN_MODE    = 0x00000002,   // Set to run program in fullscreen
	WINDOW_RESIZABLE   = 0x00000004,   // Set to allow resizable window
	WINDOW_UNDECORATED = 0x00000008,   // Set to disable window decoration (frame and buttons)
	WINDOW_HIDDEN      = 0x00000080,   // Set to hide window
	WINDOW_MINIMIZED   = 0x00000200,   // Set to minimize window (iconify)
	WINDOW_MAXIMIZED   = 0x00000400,   // Set to maximize window (expanded to monitor)
	WINDOW_UNFOCUSED   = 0x00000800,   // Set to window non focused
	WINDOW_TOPMOST     = 0x00001000,   // Set to window always on top
	WINDOW_ALWAYS_RUN  = 0x00000100,   // Set to allow windows running while minimized
	WINDOW_TRANSPARENT = 0x00000010,   // Set to allow transparent framebuffer
	WINDOW_HIGHDPI     = 0x00002000,   // Set to support HighDPI
	MSAA_4X_HINT       = 0x00000020,   // Set to try enabling MSAA 4X
	INTERLACED_HINT    = 0x00010000,   // Set to try enabling interlaced video format (for V3D)
}

// Keyboard keys (US keyboard layout)
// NOTE: Use GetKeyPressed() to allow redefining
// required keys for alternative layouts

enum KeyboardKey : const int
{
	NULL            = 0,        // Key: NULL; used for no key pressed
				// Alphanumeric keys
	APOSTROPHE      = 39,       // Key: '
	COMMA           = 44,       // Key: ;
	MINUS           = 45,       // Key: -
	PERIOD          = 46,       // Key: .
	SLASH           = 47,       // Key: /
	ZERO            = 48,       // Key: 0
	ONE             = 49,       // Key: 1
	TWO             = 50,       // Key: 2
	THREE           = 51,       // Key: 3
	FOUR            = 52,       // Key: 4
	FIVE            = 53,       // Key: 5
	SIX             = 54,       // Key: 6
	SEVEN           = 55,       // Key: 7
	EIGHT           = 56,       // Key: 8
	NINE            = 57,       // Key: 9
	SEMICOLON       = 59,       // Key: ,
	EQUAL           = 61,       // Key: =
	A               = 65,       // Key: A | a
	B               = 66,       // Key: B | b
	C               = 67,       // Key: C | c
	D               = 68,       // Key: D | d
	E               = 69,       // Key: E | e
	F               = 70,       // Key: F | f
	G               = 71,       // Key: G | g
	H               = 72,       // Key: H | h
	I               = 73,       // Key: I | i
	J               = 74,       // Key: J | j
	K               = 75,       // Key: K | k
	L               = 76,       // Key: L | l
	M               = 77,       // Key: M | m
	N               = 78,       // Key: N | n
	O               = 79,       // Key: O | o
	P               = 80,       // Key: P | p
	Q               = 81,       // Key: Q | q
	R               = 82,       // Key: R | r
	S               = 83,       // Key: S | s
	T               = 84,       // Key: T | t
	U               = 85,       // Key: U | u
	V               = 86,       // Key: V | v
	W               = 87,       // Key: W | w
	X               = 88,       // Key: X | x
	Y               = 89,       // Key: Y | y
	Z               = 90,       // Key: Z | z
	LEFT_BRACKET    = 91,       // Key: [
	BACKSLASH       = 92,       // Key: '\'
	RIGHT_BRACKET   = 93,       // Key: ]
	GRAVE           = 96,       // Key: `
	// Function keys
	SPACE           = 32,       // Key: Space
	ESCAPE          = 256,      // Key: Esc
	ENTER           = 257,      // Key: Enter
	TAB             = 258,      // Key: Tab
	BACKSPACE       = 259,      // Key: Backspace
	INSERT          = 260,      // Key: Ins
	DELETE          = 261,      // Key: Del
	RIGHT           = 262,      // Key: Cursor right
	LEFT            = 263,      // Key: Cursor left
	DOWN            = 264,      // Key: Cursor down
	UP              = 265,      // Key: Cursor up
	PAGE_UP         = 266,      // Key: Page up
	PAGE_DOWN       = 267,      // Key: Page down
	HOME            = 268,      // Key: Home
	END             = 269,      // Key: End
	CAPS_LOCK       = 280,      // Key: Caps lock
	SCROLL_LOCK     = 281,      // Key: Scroll down
	NUM_LOCK        = 282,      // Key: Num lock
	PRINT_SCREEN    = 283,      // Key: Print screen
	PAUSE           = 284,      // Key: Pause
	F1              = 290,      // Key: F1
	F2              = 291,      // Key: F2
	F3              = 292,      // Key: F3
	F4              = 293,      // Key: F4
	F5              = 294,      // Key: F5
	F6              = 295,      // Key: F6
	F7              = 296,      // Key: F7
	F8              = 297,      // Key: F8
	F9              = 298,      // Key: F9
	F10             = 299,      // Key: F10
	F11             = 300,      // Key: F11
	F12             = 301,      // Key: F12
	LEFT_SHIFT      = 340,      // Key: Shift left
	LEFT_CONTROL    = 341,      // Key: Control left
	LEFT_ALT        = 342,      // Key: Alt left
	LEFT_SUPER      = 343,      // Key: Super left
	RIGHT_SHIFT     = 344,      // Key: Shift right
	RIGHT_CONTROL   = 345,      // Key: Control right
	RIGHT_ALT       = 346,      // Key: Alt right
	RIGHT_SUPER     = 347,      // Key: Super right
	KB_MENU         = 348,      // Key: KB menu
	// Keypad keys
	KP_0            = 320,      // Key: Keypad 0
	KP_1            = 321,      // Key: Keypad 1
	KP_2            = 322,      // Key: Keypad 2
	KP_3            = 323,      // Key: Keypad 3
	KP_4            = 324,      // Key: Keypad 4
	KP_5            = 325,      // Key: Keypad 5
	KP_6            = 326,      // Key: Keypad 6
	KP_7            = 327,      // Key: Keypad 7
	KP_8            = 328,      // Key: Keypad 8
	KP_9            = 329,      // Key: Keypad 9
	KP_DECIMAL      = 330,      // Key: Keypad .
	KP_DIVIDE       = 331,      // Key: Keypad /
	KP_MULTIPLY     = 332,      // Key: Keypad *
	KP_SUBTRACT     = 333,      // Key: Keypad -
	KP_ADD          = 334,      // Key: Keypad +
	KP_ENTER        = 335,      // Key: Keypad Enter
	KP_EQUAL        = 336,      // Key: Keypad =
	// Android key buttons
	BACK            = 4,        // Key: Android back button
	MENU            = 82,       // Key: Android menu button
	VOLUME_UP       = 24,       // Key: Android volume up button
	VOLUME_DOWN     = 25,       // Key: Android volume down button
}

// Gesture
// NOTE: It could be used as flags to enable only some gestures
enum Gesture : const int
{
	NONE        = 0,      // No gesture
	TAP         = 1,        // Tap gesture
	DOUBLETAP   = 2,        // Double tap gesture
	HOLD        = 4,        // Hold gesture
	DRAG        = 8,        // Drag gesture
	SWIPE_RIGHT = 16,       // Swipe right gesture
	SWIPE_LEFT  = 32,       // Swipe left gesture
	SWIPE_UP    = 64,       // Swipe up gesture
	SWIPE_DOWN  = 128,      // Swipe down gesture
	PINCH_IN    = 256,      // Pinch in gesture
	PINCH_OUT   = 512,      // Pinch out gesture
}

// rlgl.h
typedef FramebufferAttachType = int;

const FramebufferAttachType RL_ATTACHMENT_COLOR_CHANNEL0 = 0;       // Framebuffer attachment type: color 0
const FramebufferAttachType RL_ATTACHMENT_COLOR_CHANNEL1 = 1;       // Framebuffer attachment type: color 1
const FramebufferAttachType RL_ATTACHMENT_COLOR_CHANNEL2 = 2;       // Framebuffer attachment type: color 2
const FramebufferAttachType RL_ATTACHMENT_COLOR_CHANNEL3 = 3;       // Framebuffer attachment type: color 3
const FramebufferAttachType RL_ATTACHMENT_COLOR_CHANNEL4 = 4;       // Framebuffer attachment type: color 4
const FramebufferAttachType RL_ATTACHMENT_COLOR_CHANNEL5 = 5;       // Framebuffer attachment type: color 5
const FramebufferAttachType RL_ATTACHMENT_COLOR_CHANNEL6 = 6;       // Framebuffer attachment type: color 6
const FramebufferAttachType RL_ATTACHMENT_COLOR_CHANNEL7 = 7;       // Framebuffer attachment type: color 7
const FramebufferAttachType RL_ATTACHMENT_DEPTH = 100;              // Framebuffer attachment type: depth
const FramebufferAttachType RL_ATTACHMENT_STENCIL = 200;            // Framebuffer attachment type: stencil

typedef FramebufferAttachTextureType = int;

const FramebufferAttachTextureType RL_ATTACHMENT_CUBEMAP_POSITIVE_X = 0;   // Framebuffer texture attachment type: cubemap, +X side
const FramebufferAttachTextureType RL_ATTACHMENT_CUBEMAP_NEGATIVE_X = 1;   // Framebuffer texture attachment type: cubemap, -X side
const FramebufferAttachTextureType RL_ATTACHMENT_CUBEMAP_POSITIVE_Y = 2;   // Framebuffer texture attachment type: cubemap, +Y side
const FramebufferAttachTextureType RL_ATTACHMENT_CUBEMAP_NEGATIVE_Y = 3;   // Framebuffer texture attachment type: cubemap, -Y side
const FramebufferAttachTextureType RL_ATTACHMENT_CUBEMAP_POSITIVE_Z = 4;   // Framebuffer texture attachment type: cubemap, +Z side
const FramebufferAttachTextureType RL_ATTACHMENT_CUBEMAP_NEGATIVE_Z = 5;   // Framebuffer texture attachment type: cubemap, -Z side
const FramebufferAttachTextureType RL_ATTACHMENT_TEXTURE2D = 100;          // Framebuffer texture attachment type: texture2d
const FramebufferAttachTextureType RL_ATTACHMENT_RENDERBUFFER = 200;       // Framebuffer texture attachment type: renderbuffer

const RL_LINES = 0x0001;        // GL_LINES
const RL_TRIANGLES = 0x0004;    // GL_TRIANGLES
const RL_QUADS = 0x0007;        // GL_QUADS

//------------------------------------------------------------------------------------
// Functions Declaration - RLMatrix operations
//------------------------------------------------------------------------------------
fn void rl_matrix_mode(CInt mode) @cname("rlMatrixMode");                      // Choose the current matrix to be transformed
fn void rl_push_matrix() @cname("rlPushMatrix");                          // Push the current matrix to stack
fn void rl_pop_matrix() @cname("rlPopMatrix");                           // Pop latest inserted matrix from stack
fn void rl_load_identity() @cname("rlLoadIdentity");                        // Reset current matrix to identity matrix
fn void rl_translatef(float x, float y, float z) @cname("rlTranslatef");     // Multiply the current matrix by a translation matrix
fn void rl_rotatef(float angle, float x, float y, float z) @cname("rlRotatef"); // Multiply the current matrix by a rotation matrix
fn void rl_scalef(float x, float y, float z) @cname("rlScalef");         // Multiply the current matrix by a scaling matrix
fn void rl_mult_matrixf(float *matf) @cname("rlMultMatrixf");            // Multiply the current matrix by another matrix
fn void rl_frustum(double left, double right, double bottom, double top, double znear, double zfar);
fn void rl_ortho(double left, double right, double bottom, double top, double znear, double zfar);
fn void rl_viewport(CInt x, CInt y, CInt width, CInt height) @cname("rlFrustum"); // Set the viewport area
fn void rl_set_clip_planes(double near_plane, double far_plane) @cname("rlOrtho");    // Set clip planes distances
fn double rl_get_cull_distance_near() @cname("rlViewport");               // Get cull plane distance near
fn double rl_get_cull_distance_far() @cname("rlSetClipPlanes");                // Get cull plane distance far

//------------------------------------------------------------------------------------
// Functions Declaration - Vertex level operations
//------------------------------------------------------------------------------------
fn void rl_begin(CInt mode) @cname("rlGetCullDistanceNear");                           // Initialize drawing mode (how to organize vertex)
fn void rl_end() @cname("rlGetCullDistanceFar");                                 // Finish vertex providing
fn void rl_vertex2i(CInt x, CInt y) @cname("rlBegin");                    // Define one vertex (position) - 2 CInt
fn void rl_vertex2f(float x, float y) @cname("rlEnd");                // Define one vertex (position) - 2 float
fn void rl_vertex3f(float x, float y, float z) @cname("rlVertex2i");       // Define one vertex (position) - 3 float
fn void rl_tex_coord2f(float x, float y) @cname("rlVertex2f");              // Define one vertex (texture coordinate) - 2 float
fn void rl_normal3f(float x, float y, float z) @cname("rlVertex3f");       // Define one vertex (normal) - 3 float
fn void rl_color4ub(char r, char g, char b, char a) @cname("rlTexCoord2f"); // Define one vertex (color) - 4 byte
fn void rl_color3f(float x, float y, float z) @cname("rlNormal3f");        // Define one vertex (color) - 3 float
fn void rl_color4f(float x, float y, float z, float w) @cname("rlColor4ub"); // Define one vertex (color) - 4 float

//------------------------------------------------------------------------------------
// Functions Declaration - OpenGL style functions (common to 1.1, 3.3+, ES2)
// NOTE: This functions are used to completely abstract raylib code from OpenGL layer,
// some of them are direct wrappers over OpenGL calls, some others are custom
//------------------------------------------------------------------------------------

// Vertex buffers state
fn bool rl_enable_vertex_array(CUInt vaoId) @cname("rlColor3f");     // Enable vertex array (VAO, if supported)
fn void rl_disable_vertex_array() @cname("rlColor4f");                  // Disable vertex array (VAO, if supported)
fn void rl_enable_vertex_buffer(CUInt id) @cname("rlEnableVertexArray");       // Enable vertex buffer (VBO)
fn void rl_disable_vertex_buffer() @cname("rlDisableVertexArray");                 // Disable vertex buffer (VBO)
fn void rl_enable_vertex_buffer_element(CUInt id) @cname("rlEnableVertexBuffer"); // Enable vertex buffer element (VBO element)
fn void rl_disable_vertex_buffer_element() @cname("rlDisableVertexBuffer");          // Disable vertex buffer element (VBO element)
fn void rl_enable_vertex_attribute(CUInt index) @cname("rlEnableVertexBufferElement"); // Enable vertex attribute index
fn void rl_disable_vertex_attribute(CUInt index) @cname("rlDisableVertexBufferElement"); // Disable vertex attribute index
fn void rl_enable_state_pointer(RLShaderAttributeDataType vertex_attrib_type, void *buffer) @cname("rlEnableVertexAttribute"); // Enable attribute state pointer
fn void rl_disable_state_pointer(RLShaderAttributeDataType vertex_attrib_type) @cname("rlDisableVertexAttribute"); // Disable attribute state pointer

// Textures state
fn void rl_active_texture_slot(CInt slot) @cname("rlEnableStatePointer");               // Select and active a texture slot
fn void rl_enable_texture(CUInt id) @cname("rlDisableStatePointer");            // Enable texture
fn void rl_disable_texture() @cname("rlActiveTextureSlot");                      // Disable texture
fn void rl_enable_texture_cubemap(CUInt id) @cname("rlEnableTexture");     // Enable texture cubemap
fn void rl_disable_texture_cubemap() @cname("rlDisableTexture");               // Disable texture cubemap
fn void rl_texture_parameters(CUInt id, CInt param, CInt value) @cname("rlEnableTextureCubemap"); // Set texture parameters (filter, wrap)
fn void rl_cubemap_parameters(CUInt id, CInt param, CInt value) @cname("rlDisableTextureCubemap"); // Set cubemap parameters (filter, wrap)

// RLShader state
fn void rl_enable_shader(CUInt id) @cname("rlTextureParameters");             // Enable shader program
fn void rl_disable_shader() @cname("rlCubemapParameters");                       // Disable shader program

// Framebuffer state
fn void rl_enable_framebuffer(CUInt id) @cname("rlEnableShader");        // Enable render texture (fbo)
fn void rl_disable_framebuffer() @cname("rlDisableShader");                  // Disable render texture (fbo), return to default framebuffer
fn CUInt rl_get_active_framebuffer() @cname("rlEnableFramebuffer");        // Get the currently active render texture (fbo), 0 for default framebuffer
fn void rl_active_draw_buffers(CInt count) @cname("rlDisableFramebuffer");              // Activate multiple draw color buffers
fn void rl_blit_framebuffer(CInt src_x, CInt src_y, CInt src_width, CInt src_height, CInt dst_x, CInt dst_y, CInt dst_width, CInt dst_height, CInt buffer_mask) @cname("rlGetActiveFramebuffer"); // Blit active framebuffer to main framebuffer
fn void rl_bind_framebuffer(CUInt target, CUInt framebuffer) @cname("rlActiveDrawBuffers"); // Bind framebuffer (FBO)

// General render state
fn void rl_enable_color_blend() @cname("rlBlitFramebuffer");                    // Enable color blending
fn void rl_disable_color_blend() @cname("rlBindFramebuffer");                   // Disable color blending
fn void rl_enable_depth_test() @cname("rlEnableColorBlend");                     // Enable depth test
fn void rl_disable_depth_test() @cname("rlDisableColorBlend");                    // Disable depth test
fn void rl_enable_depth_mask() @cname("rlEnableDepthTest");                     // Enable depth write
fn void rl_disable_depth_mask() @cname("rlDisableDepthTest");                    // Disable depth write
fn void rl_enable_backface_culling() @cname("rlEnableDepthMask");               // Enable backface culling
fn void rl_disable_backface_culling() @cname("rlDisableDepthMask");              // Disable backface culling
fn void rl_color_mask(bool r, bool g, bool b, bool a) @cname("rlEnableBackfaceCulling"); // RLColor mask control
fn void rl_set_cull_face(CInt mode) @cname("rlDisableBackfaceCulling");                     // Set face culling mode
fn void rl_enable_scissor_test() @cname("rlColorMask");                   // Enable scissor test
fn void rl_disable_scissor_test() @cname("rlSetCullFace");                  // Disable scissor test
fn void rl_scissor(CInt x, CInt y, CInt width, CInt height) @cname("rlEnableScissorTest"); // Scissor test
fn void rl_enable_point_mode() @cname("rlDisableScissorTest");                     // Enable point mode
fn void rl_disable_point_mode() @cname("rlScissor");                    // Disable point mode
fn void rl_set_point_size(float size) @cname("rlEnablePointMode");                  // Set the point drawing size
fn float rl_get_point_size() @cname("rlDisablePointMode");                       // Get the point drawing size
fn void rl_enable_wire_mode() @cname("rlSetPointSize");                      // Enable wire mode
fn void rl_disable_wire_mode() @cname("rlGetPointSize");                     // Disable wire mode
fn void rl_set_line_width(float width) @cname("rlEnableWireMode");                 // Set the line drawing width
fn float rl_get_line_width() @cname("rlDisableWireMode");                       // Get the line drawing width
fn void rl_enable_smooth_lines() @cname("rlSetLineWidth");                   // Enable line aliasing
fn void rl_disable_smooth_lines() @cname("rlGetLineWidth");                  // Disable line aliasing
fn void rl_enable_stereo_render() @cname("rlEnableSmoothLines");                  // Enable stereo rendering
fn void rl_disable_stereo_render() @cname("rlDisableSmoothLines");                 // Disable stereo rendering
fn bool rl_is_stereo_render_enabled() @cname("rlEnableStereoRender");               // Check if stereo render is enabled

fn void rl_clear_color(char r, char g, char b, char a) @cname("rlDisableStereoRender"); // Clear color buffer with color
fn void rl_clear_screen_buffers() @cname("rlIsStereoRenderEnabled");                  // Clear used screen buffers (color and depth)
fn void rl_check_errors() @cname("rlClearColor");                         // Check and log OpenGL error codes
fn void rl_set_blend_mode(RLBlendMode mode) @cname("rlClearScreenBuffers");                    // Set blending mode
fn void rl_set_blend_factors(CInt gl_src_factor, CInt gl_dst_factor, CInt gl_equation) @cname("rlCheckErrors"); // Set blending mode factor and equation (using OpenGL factors)
fn void rl_set_blend_factors_separate(CInt gl_src_rgb, CInt gl_dst_rgb, CInt gl_src_alpha, CInt gl_dst_alpha, CInt gl_eq_rgb, CInt gl_eq_alpha) @cname("rlSetBlendMode"); // Set blending mode factors and equations separately (using OpenGL factors)


//------------------------------------------------------------------------------------
// Functions Declaration - rlgl functionality
//------------------------------------------------------------------------------------
// rlgl initialization functions
fn void rlgl_init(CInt width, CInt height) @cname("rlSetBlendFactors");             // Initialize rlgl (buffers, shaders, textures, states)
fn void rlgl_close() @cname("rlSetBlendFactorsSeparate");                             // De-initialize rlgl (buffers, shaders, textures)
fn void rl_load_extensions(void *loader) @cname("rlglInit");              // Load OpenGL extensions (loader function required)
fn void *rl_get_proc_address(ZString proc_name) @cname("rlglClose");     // Get OpenGL procedure address
fn CInt rl_get_version() @cname("rlLoadExtensions");                           // Get current OpenGL version
fn void rl_set_framebuffer_width(CInt width) @cname("rlGetProcAddress");            // Set current framebuffer width
fn CInt rl_get_framebuffer_width() @cname("rlGetVersion");                  // Get default framebuffer width
fn void rl_set_framebuffer_height(CInt height) @cname("rlSetFramebufferWidth");          // Set current framebuffer height
fn CInt rl_get_framebuffer_height() @cname("rlGetFramebufferWidth");                 // Get default framebuffer height

fn CUInt rl_get_texture_id_default() @cname("rlSetFramebufferHeight");         // Get default texture id
fn CUInt rl_get_shader_id_default() @cname("rlGetFramebufferHeight");          // Get default shader id
fn CInt *rl_get_shader_locs_default() @cname("rlGetTextureIdDefault");                // Get default shader locations

// Render batch management
// NOTE: rlgl provides a default render batch to behave like OpenGL 1.1 immediate mode
// but this render batch API is exposed in case of custom batches are required
fn void rl_set_texture(CUInt id) @cname("rlGetShaderIdDefault");               // Set current texture for render batch and check buffers limits


// raymath.h
// Add two vectors (v1 + v2)
fn RLVector2 vector2_add(RLVector2 v1, RLVector2 v2) @cname("Vector2Add");
// Add vector and float value
fn RLVector2 vector2_add_value(RLVector2 v, float add) @cname("Vector2AddValue");
// Calculate the signed angle from v1 to v2, relative to the origin (0, 0)
// NOTE: Coordinate system convention: positive X right, positive Y down,
// positive angles appear clockwise, and negative angles appear counterclockwise
fn float vector2_angle(RLVector2 v1, RLVector2 v2) @cname("Vector2Angle");
// Clamp the components of the vector between
// min and max values specified by the given vectors
fn RLVector2 vector2_clamp(RLVector2 v, RLVector2 min, RLVector2 max) @cname("Vector2Clamp");
// Clamp the magnitude of the vector between two min and max values
fn RLVector2 vector2_clamp_value(RLVector2 v, float min, float max) @cname("Vector2ClampValue");
// Calculate two vectors cross product
fn float vector2_cross_product(RLVector2 v1, RLVector2 v2) @cname("Vector2CrossProduct");
// Calculate distance between two vectors
fn float vector2_distance(RLVector2 v1, RLVector2 v2) @cname("Vector2Distance");
// Calculate square distance between two vectors
fn float vector2_distance_sqr(RLVector2 v1, RLVector2 v2) @cname("Vector2DistanceSqr");
// Divide vector by vector
fn RLVector2 vector2_divide(RLVector2 v1, RLVector2 v2) @cname("Vector2Divide");
// Calculate two vectors dot product
fn float vector2_dot_product(RLVector2 v1, RLVector2 v2) @cname("Vector2DotProduct");
// Check whether two given vectors are almost equal
fn int vector2_equals(RLVector2 p, RLVector2 q) @cname("Vector2Equals");
// Invert the given vector
fn RLVector2 vector2_invert(RLVector2 v) @cname("Vector2Invert");
// Calculate vector length
fn float vector2_length(RLVector2 v) @cname("Vector2Length");
// Calculate vector square length
fn float vector2_length_sqr(RLVector2 v) @cname("Vector2LengthSqr");
// Calculate linear interpolation between two vectors
fn RLVector2 vector2_lerp(RLVector2 v1, RLVector2 v2, float amount) @cname("Vector2Lerp");
// Calculate angle defined by a two vectors line
// NOTE: Parameters need to be normalized
// Current implementation should be aligned with glm::angle
fn float vector2_line_angle(RLVector2 start, RLVector2 end) @cname("Vector2LineAngle");
// Get max value for each pair of components
fn RLVector2 vector2_max(RLVector2 v1, RLVector2 v2) @cname("Vector2Max");
// Get min value for each pair of components
fn RLVector2 vector2_min(RLVector2 v1, RLVector2 v2) @cname("Vector2Min");
// Move Vector towards target
fn RLVector2 vector2_move_towards(RLVector2 v, RLVector2 target, float max_distance) @cname("Vector2MoveTowards");
// Multiply vector by vector
fn RLVector2 vector2_multiply(RLVector2 v1, RLVector2 v2) @cname("Vector2Multiply");
// Negate vector
fn RLVector2 vector2_negate(RLVector2 v) @cname("Vector2Negate");
// Normalize provided vector
fn RLVector2 vector2_normalize(RLVector2 v) @cname("Vector2Normalize");
// Vector with components value 1.0f
fn RLVector2 vector2_one() @cname("Vector2One");
// Calculate reflected vector to normal
fn RLVector2 vector2_reflect(RLVector2 v, RLVector2 normal) @cname("Vector2Reflect");
// Compute the direction of a refracted ray
// v: normalized direction of the incoming ray
// n: normalized normal vector of the interface of two optical media
// r: ratio of the refractive index of the medium from where the ray comes
//    to the refractive index of the medium on the other side of the surface
fn RLVector2 vector2_refract(RLVector2 v, RLVector2 n, float r) @cname("Vector2Refract");
// Rotate vector by angle
fn RLVector2 vector2_rotate(RLVector2 v, float angle) @cname("Vector2Rotate");
// Scale vector (multiply by value)
fn RLVector2 vector2_scale(RLVector2 v, float scale) @cname("Vector2Scale");
// Subtract two vectors (v1 - v2)
fn RLVector2 vector2_subtract(RLVector2 v1, RLVector2 v2) @cname("Vector2Subtract");
// Subtract vector by float value
fn RLVector2 vector2_subtract_value(RLVector2 v, float sub) @cname("Vector2SubtractValue");
// Transforms a RLVector2 by a given RLMatrix
fn RLVector2 vector2_transform(RLVector2 v, RLMatrix mat) @cname("Vector2Transform");
// Vector with components value 0.0f
fn RLVector2 vector2_zero() @cname("Vector2Zero");

// Add two vectors
fn RLVector3 vector3_add(RLVector3 v1, RLVector3 v2) @cname("Vector3Add");
// Add vector and float value
fn RLVector3 vector3_add_value(RLVector3 v, float add) @cname("Vector3AddValue");
// Calculate angle between two vectors
fn float vector3_angle(RLVector3 v1, RLVector3 v2) @cname("Vector3Angle");
// Compute barycenter coordinates (u, v, w) for point p with respect to triangle (a, b, c)
// NOTE: Assumes P is on the plane of the triangle
fn RLVector3 vector3_barycenter(RLVector3 p, RLVector3 a, RLVector3 b, RLVector3 c) @cname("Vector3Barycenter");
// Clamp the components of the vector between
// min and max values specified by the given vectors
fn RLVector3 vector3_clamp(RLVector3 v, RLVector3 min, RLVector3 max) @cname("Vector3Clamp");
// Clamp the magnitude of the vector between two values
fn RLVector3 vector3_clamp_value(RLVector3 v, float min, float max) @cname("Vector3ClampValue");
// Calculate two vectors cross product
fn RLVector3 vector3_cross_product(RLVector3 v1, RLVector3 v2) @cname("Vector3CrossProduct");
// Calculate cubic hermite interpolation between two vectors and their tangents
// as described in the GLTF 2.0 specification: https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#interpolation-cubic
fn RLVector3 vector3_cubic_hermite(RLVector3 v1, RLVector3 tangent1, RLVector3 v2, RLVector3 tangent2, float amount) @cname("Vector3CubicHermite");
// Calculate square distance between two vectors
fn float vector3_distance(RLVector3 v1, RLVector3 v2) @cname("Vector3Distance");
// Calculate square distance between two vectors
fn float vector3_distance_sqr(RLVector3 v1, RLVector3 v2) @cname("Vector3DistanceSqr");
// Divide vector by vector
fn RLVector3 vector3_divide(RLVector3 v1, RLVector3 v2) @cname("Vector3Divide");
// Calculate two vectors dot product
fn float vector3_dot_product(RLVector3 v1, RLVector3 v2) @cname("Vector3DotProduct");
// Check whether two given vectors are almost equal
fn int vector3_equals(RLVector3 p, RLVector3 q) @cname("Vector3Equals");
// Invert the given vector
fn RLVector3 vector3_invert(RLVector3 v) @cname("Vector3Invert");
// Calculate vector length
fn float vector3_length(RLVector3 v) @cname("Vector3Length");
// Calculate vector square length
fn float vector3_length_sqr(RLVector3 v) @cname("Vector3LengthSqr");
// Calculate linear interpolation between two vectors
fn RLVector3 vector3_lerp(RLVector3 v1, RLVector3 v2, float amount) @cname("Vector3Lerp");
// Get max value for each pair of components
fn RLVector3 vector3_max(RLVector3 v1, RLVector3 v2) @cname("Vector3Max");
// Get min value for each pair of components
fn RLVector3 vector3_min(RLVector3 v1, RLVector3 v2) @cname("Vector3Min");
// Move Vector towards target
fn RLVector3 vector3_move_towards(RLVector3 v, RLVector3 target, float max_distance) @cname("Vector3MoveTowards");
// Multiply vector by vector
fn RLVector3 vector3_multiply(RLVector3 v1, RLVector3 v2) @cname("Vector3Multiply");
// Negate provided vector (invert direction)
fn RLVector3 vector3_negate(RLVector3 v) @cname("Vector3Negate");
// Normalize provided vector
fn RLVector3 vector3_normalize(RLVector3 v) @cname("Vector3Normalize");
// Vector with components value 1.0f
fn RLVector3 vector3_one() @cname("Vector3One");
// Orthonormalize provided vectors
// Makes vectors normalized and orthogonal to each other
// Gram-Schmidt function implementation
fn void vector3_ortho_normalize(RLVector3 *v1, RLVector3 *v2) @cname("Vector3OrthoNormalize");
// Calculate one vector perpendicular vector
fn RLVector3 vector3_perpendicular(RLVector3 v) @cname("Vector3Perpendicular");
//Calculate the projection of the vector v1 on to v2
fn RLVector3 vector3_project(RLVector3 v1, RLVector3 v2) @cname("Vector3Project");
// Calculate reflected vector to normal
fn RLVector3 vector3_reflect(RLVector3 v, RLVector3 normal) @cname("Vector3Reflect");
// Compute the direction of a refracted ray
// v: normalized direction of the incoming ray
// n: normalized normal vector of the interface of two optical media
// r: ratio of the refractive index of the medium from where the ray comes
//    to the refractive index of the medium on the other side of the surface
fn RLVector3 vector3_refract(RLVector3 v, RLVector3 n, float r) @cname("Vector3Refract");
//Calculate the rejection of the vector v1 on to v2
fn RLVector3 vector3_reject(RLVector3 v1, RLVector3 v2) @cname("Vector3Reject");
// Rotates a vector around an axis
fn RLVector3 vector3_rotate_by_axis_angle(RLVector3 v, RLVector3 axis, float angle) @cname("Vector3RotateByAxisAngle");
// RLTransform a vector by quaternion rotation
fn RLVector3 vector3_rotate_by_quaternion(RLVector3 v, RLQuaternion q) @cname("Vector3RotateByQuaternion");
// Multiply vector by scalar
fn RLVector3 vector3_scale(RLVector3 v, float scalar) @cname("Vector3Scale");
// Subtract two vectors
fn RLVector3 vector3_subtract(RLVector3 v1, RLVector3 v2) @cname("Vector3Subtract");
// Subtract vector by float value
fn RLVector3 vector3_subtract_value(RLVector3 v, float sub) @cname("Vector3SubtractValue");

// Get RLVector3 as float array
// fn float3 vector3ToFloatV(RLVector3 v) @cname("Vector3ToFloatV"); // ? float3 == float[<3>]

// Transforms a RLVector3 by a given RLMatrix
fn RLVector3 vector3_transform(RLVector3 v, RLMatrix mat) @cname("Vector3Transform");
// Projects a RLVector3 from screen space into object space
// NOTE: We are avoiding calling other raymath functions despite available
fn RLVector3 vector3_unproject(RLVector3 source, RLMatrix projection, RLMatrix view) @cname("Vector3Unproject");
// Vector with components value 0.0f
fn RLVector3 vector3_zero() @cname("Vector3Zero");

fn RLVector4 vector4_add(RLVector4 v1, RLVector4 v2) @cname("Vector4Add");
fn RLVector4 vector4_add_value(RLVector4 v, float add) @cname("Vector4AddValue");
// Calculate distance between two vectors
fn float vector4_distance(RLVector4 v1, RLVector4 v2) @cname("Vector4Distance");
// Calculate square distance between two vectors
fn float vector4_distance_sqr(RLVector4 v1, RLVector4 v2) @cname("Vector4DistanceSqr");
// Divide vector by vector
fn RLVector4 vector4_divide(RLVector4 v1, RLVector4 v2) @cname("Vector4Divide");
fn float vector4_dot_product(RLVector4 v1, RLVector4 v2) @cname("Vector4DotProduct");
// Check whether two given vectors are almost equal
fn int vector4_equals(RLVector4 p, RLVector4 q) @cname("Vector4Equals");
// Invert the given vector
fn RLVector4 vector4_invert(RLVector4 v) @cname("Vector4Invert");
fn float vector4_length(RLVector4 v) @cname("Vector4Length");
fn float vector4_length_sqr(RLVector4 v) @cname("Vector4LengthSqr");
// Calculate linear interpolation between two vectors
fn RLVector4 vector4_lerp(RLVector4 v1, RLVector4 v2, float amount) @cname("Vector4Lerp");
// Get max value for each pair of components
fn RLVector4 vector4_max(RLVector4 v1, RLVector4 v2) @cname("Vector4Max");
// Get min value for each pair of components
fn RLVector4 vector4_min(RLVector4 v1, RLVector4 v2) @cname("Vector4Min");
// Move Vector towards target
fn RLVector4 vector4_move_towards(RLVector4 v, RLVector4 target, float max_distance) @cname("Vector4MoveTowards");
// Multiply vector by vector
fn RLVector4 vector4_multiply(RLVector4 v1, RLVector4 v2) @cname("Vector4Multiply");
// Negate vector
fn RLVector4 vector4_negate(RLVector4 v) @cname("Vector4Negate");
// Normalize provided vector
fn RLVector4 vector4_normalize(RLVector4 v) @cname("Vector4Normalize");
fn RLVector4 vector4_one() @cname("Vector4One");
fn RLVector4 vector4_scale(RLVector4 v, float scale) @cname("Vector4Scale");
fn RLVector4 vector4_subtract(RLVector4 v1, RLVector4 v2) @cname("Vector4Subtract");
fn RLVector4 vector4_subtract_value(RLVector4 v, float add) @cname("Vector4SubtractValue");
fn RLVector4 vector4_zero() @cname("Vector4Zero");

// Add two matrices
fn RLMatrix matrix_add(RLMatrix left, RLMatrix right) @cname("MatrixAdd");
// Decompose a transformation matrix into its rotational, translational and scaling components
fn void matrix_decompose(RLMatrix mat, RLVector3 *translation, RLQuaternion *rotation, RLVector3 *scale) @cname("MatrixDecompose");
// Compute matrix determinant
fn float matrix_determinant(RLMatrix mat) @cname("MatrixDeterminant");
// Get perspective projection matrix
fn RLMatrix matrix_frustum(double left, double right, double bottom, double top, double near_plane, double far_plane) @cname("MatrixFrustum");
// Get identity matrix
fn RLMatrix matrix_identity() @cname("MatrixIdentity");
// Invert provided matrix
fn  RLMatrix matrix_invert(RLMatrix mat) @cname("MatrixInvert");
// Get camera look-at matrix (view matrix)
fn RLMatrix matrix_look_at(RLVector3 eye, RLVector3 target, RLVector3 up) @cname("MatrixLookAt");
// Get two matrix multiplication
// NOTE: When multiplying matrices... the order matters!
fn RLMatrix matrix_multiply(RLMatrix left, RLMatrix right) @cname("MatrixMultiply");
// Get orthographic projection matrix
fn RLMatrix matrix_ortho(double left, double right, double bottom, double top, double near_plane, double far_plane) @cname("MatrixOrtho");
// Get perspective projection matrix
// NOTE: Fovy angle must be provided in radians
fn RLMatrix matrix_perspective(double fovY, double aspect, double near_plane, double far_plane) @cname("MatrixPerspective");
// Create rotation matrix from axis and angle
// NOTE: Angle should be provided in radians
fn RLMatrix matrix_rotate(RLVector3 axis, float angle) @cname("MatrixRotate");
// Get x-rotation matrix
// NOTE: Angle must be provided in radians
fn RLMatrix matrix_rotate_x(float angle) @cname("MatrixRotateX");
// Get zyx-rotation matrix
// NOTE: Angle must be provided in radians
fn RLMatrix matrix_rotate_x_y_z(RLVector3 angle) @cname("MatrixRotateXYZ");
// Get y-rotation matrix
// NOTE: Angle must be provided in radians
fn RLMatrix matrix_rotate_y(float angle) @cname("MatrixRotateY");
// Get z-rotation matrix
// NOTE: Angle must be provided in radians
fn RLMatrix matrix_rotate_z(float angle) @cname("MatrixRotateZ");
// Get zyx-rotation matrix
// NOTE: Angle must be provided in radians
fn RLMatrix matrix_rotate_z_y_x(RLVector3 angle) @cname("MatrixRotateZYX");
// Get scaling matrix
fn RLMatrix matrix_scale(float x, float y, float z) @cname("MatrixScale");
// Subtract two matrices (left - right)
fn RLMatrix matrix_subtract(RLMatrix left, RLMatrix right) @cname("MatrixSubtract");

// Get float array of matrix data
// fn float16 matrixToFloatV(RLMatrix mat) @cname("MatrixToFloatV"); // float16 == float[<16>] ??

// Get the trace of the matrix (sum of the values along the diagonal)
fn float matrix_trace(RLMatrix mat) @cname("MatrixTrace");
// Get translation matrix
fn  RLMatrix matrix_translate(float x, float y, float z) @cname("MatrixTranslate");
// Transposes provided matrix
fn RLMatrix matrix_transpose(RLMatrix mat) @cname("MatrixTranspose");

// Add two quaternions
fn RLQuaternion quaternion_add(RLQuaternion q1, RLQuaternion q2) @cname("QuaternionAdd");
// Add quaternion and float value
fn RLQuaternion quaternion_add_value(RLQuaternion q, float add) @cname("QuaternionAddValue");
// Calculate quaternion cubic spline interpolation using Cubic Hermite Spline algorithm
// as described in the GLTF 2.0 specification: https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#interpolation-cubic
fn RLQuaternion quaternion_cubic_hermite_spline(RLQuaternion q1, RLQuaternion out_tangent1, RLQuaternion q2, RLQuaternion in_tangent2, float t) @cname("QuaternionCubicHermiteSpline");
// Divide two quaternions
fn RLQuaternion quaternion_divide(RLQuaternion q1, RLQuaternion q2) @cname("QuaternionDivide");
// Check whether two given quaternions are almost equal
fn int quaternion_equals(RLQuaternion p, RLQuaternion q) @cname("QuaternionEquals");
// Get rotation quaternion for an angle and axis
// NOTE: Angle must be provided in radians
fn RLQuaternion quaternion_from_axis_angle(RLVector3 axis, float angle) @cname("QuaternionFromAxisAngle");
// Get the quaternion equivalent to Euler angles
// NOTE: Rotation order is ZYX
fn RLQuaternion quaternion_from_euler(float pitch, float yaw, float roll) @cname("QuaternionFromEuler");
// Get a quaternion for a given rotation matrix
fn RLQuaternion quaternion_from_matrix(RLMatrix mat) @cname("QuaternionFromMatrix");
// Calculate quaternion based on the rotation from one vector to another
fn RLQuaternion quaternion_from_vector3_to_vector3(RLVector3 from, RLVector3 to) @cname("QuaternionFromVector3ToVector3");
// Get identity quaternion
fn RLQuaternion quaternion_identity() @cname("QuaternionIdentity");
// Invert provided quaternion
fn RLQuaternion quaternion_invert(RLQuaternion q) @cname("QuaternionInvert");
// Computes the length of a quaternion
fn float quaternion_length(RLQuaternion q) @cname("QuaternionLength");
// Calculate linear interpolation between two quaternions
fn RLQuaternion quaternion_lerp(RLQuaternion q1, RLQuaternion q2, float amount) @cname("QuaternionLerp");
// Calculate two quaternion multiplication
fn RLQuaternion quaternion_multiply(RLQuaternion q1, RLQuaternion q2) @cname("QuaternionMultiply");
// Calculate slerp-optimized interpolation between two quaternions
fn RLQuaternion quaternion_nlerp(RLQuaternion q1, RLQuaternion q2, float amount) @cname("QuaternionNlerp");
// Normalize provided quaternion
fn RLQuaternion quaternion_normalize(RLQuaternion q) @cname("QuaternionNormalize");
// Scale quaternion by float value
fn RLQuaternion quaternion_scale(RLQuaternion q, float mul) @cname("QuaternionScale");
// Calculates spherical linear interpolation between two quaternions
fn RLQuaternion quaternion_slerp(RLQuaternion q1, RLQuaternion q2, float amount) @cname("QuaternionSlerp");
// Subtract two quaternions
fn RLQuaternion quaternion_subtract(RLQuaternion q1, RLQuaternion q2) @cname("QuaternionSubtract");
// Subtract quaternion and float value
fn RLQuaternion quaternion_subtract_value(RLQuaternion q, float sub) @cname("QuaternionSubtractValue");
// Get the rotation angle and axis for a given quaternion
fn void quaternion_to_axis_angle(RLQuaternion q, RLVector3 *out_axis, float *out_angle) @cname("QuaternionToAxisAngle");
// Get the Euler angles equivalent to quaternion (roll, pitch, yaw)
// NOTE: Angles are returned in a RLVector3 struct in radians
fn RLVector3 quaternion_to_euler(RLQuaternion q) @cname("QuaternionToEuler");
// Get a matrix for a given quaternion
fn RLMatrix quaternion_to_matrix(RLQuaternion q) @cname("QuaternionToMatrix");
// RLTransform a quaternion given a transformation matrix
fn RLQuaternion quaternion_transform(RLQuaternion q, RLMatrix mat) @cname("QuaternionTransform");


// rcamera.h
// Moves the camera in its forward direction
fn void camera_move_forward(RLCamera *camera, float distance, bool move_in_world_plane) @cname("CameraMoveForward");
// Moves the camera target in its current right direction
fn void camera_move_right(RLCamera *camera, float distance, bool move_in_world_plane) @cname("CameraMoveRight");
// Moves the camera position closer/farther to/from the camera target
fn void camera_move_to_target(RLCamera *camera, float delta) @cname("CameraMoveToTarget");
// Moves the camera in its up direction
fn void camera_move_up(RLCamera *camera, float distance) @cname("CameraMoveUp");
// Rotates the camera around its right vector, pitch is "looking up and down"
//  - lockView prevents camera overrotation (aka "somersaults")
//  - rotate_around_target defines if rotation is around target or around its position
//  - rotateUp rotates the up direction as well (typically only usefull in CAMERA_FREE)
// NOTE: angle must be provided in radians
fn void camera_pitch(RLCamera *camera, float angle, bool lockView, bool rotate_around_target, bool rotate_up) @cname("CameraPitch");
// Rotates the camera around its forward vector
// Roll is "turning your head sideways to the left or right"
// Note: angle must be provided in radians
fn void camera_roll(RLCamera *camera, float angle) @cname("CameraRoll");
// Rotates the camera around its up vector
// Yaw is "looking left and right"
// If rotate_around_target is false, the camera rotates around its position
// Note: angle must be provided in radians
fn void camera_yaw(RLCamera *camera, float angle, bool rotate_around_target) @cname("CameraYaw");