module opengl::gl @if(internal::gl_version() == 43);
import opengl;

//Adapted from the glad loader generator at: https://gen.glad.sh.
//License/ Information:
/**
 * Loader generated by glad 2.0.6 on Sat Aug 17 20:26:04 2024
 *
 * SPDX-License-Identifier: (WTFPL OR CC0-1.0) AND Apache-2.0
 *
 * Generator: C/C++
 * Specification: gl
 * Extensions: 0
 *
 * APIs:
 *  - gl:compatibility=4.3
 *
 * Options:
 *  - ALIAS = False
 *  - DEBUG = False
 *  - HEADER_ONLY = False
 *  - LOADER = False
 *  - MX = False
 *  - ON_DEMAND = False
 *
 * Commandline:
 *    --api='gl:compatibility=4.3' --extensions='' c
 *
 * Online:
 *    http://glad.sh/#api=gl%3Acompatibility%3D4.3&extensions=&generator=c&options=
 *
 */


//Constants

const GL_2D = 0x0600;
const GL_2_BYTES = 0x1407;
const GL_3D = 0x0601;
const GL_3D_COLOR = 0x0602;
const GL_3D_COLOR_TEXTURE = 0x0603;
const GL_3_BYTES = 0x1408;
const GL_4D_COLOR_TEXTURE = 0x0604;
const GL_4_BYTES = 0x1409;
const GL_ACCUM = 0x0100;
const GL_ACCUM_ALPHA_BITS = 0x0D5B;
const GL_ACCUM_BLUE_BITS = 0x0D5A;
const GL_ACCUM_BUFFER_BIT = 0x00000200;
const GL_ACCUM_CLEAR_VALUE = 0x0B80;
const GL_ACCUM_GREEN_BITS = 0x0D59;
const GL_ACCUM_RED_BITS = 0x0D58;
const GL_ACTIVE_ATOMIC_COUNTER_BUFFERS = 0x92D9;
const GL_ACTIVE_ATTRIBUTES = 0x8B89;
const GL_ACTIVE_ATTRIBUTE_MAX_LENGTH = 0x8B8A;
const GL_ACTIVE_PROGRAM = 0x8259;
const GL_ACTIVE_RESOURCES = 0x92F5;
const GL_ACTIVE_SUBROUTINES = 0x8DE5;
const GL_ACTIVE_SUBROUTINE_MAX_LENGTH = 0x8E48;
const GL_ACTIVE_SUBROUTINE_UNIFORMS = 0x8DE6;
const GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS = 0x8E47;
const GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH = 0x8E49;
const GL_ACTIVE_TEXTURE = 0x84E0;
const GL_ACTIVE_UNIFORMS = 0x8B86;
const GL_ACTIVE_UNIFORM_BLOCKS = 0x8A36;
const GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH = 0x8A35;
const GL_ACTIVE_UNIFORM_MAX_LENGTH = 0x8B87;
const GL_ACTIVE_VARIABLES = 0x9305;
const GL_ADD = 0x0104;
const GL_ADD_SIGNED = 0x8574;
const GL_ALIASED_LINE_WIDTH_RANGE = 0x846E;
const GL_ALIASED_POINT_SIZE_RANGE = 0x846D;
const GL_ALL_ATTRIB_BITS = 0xFFFFFFFF;
const GL_ALL_BARRIER_BITS = 0xFFFFFFFF;
const GL_ALL_SHADER_BITS = 0xFFFFFFFF;
const GL_ALPHA = 0x1906;
const GL_ALPHA12 = 0x803D;
const GL_ALPHA16 = 0x803E;
const GL_ALPHA4 = 0x803B;
const GL_ALPHA8 = 0x803C;
const GL_ALPHA_BIAS = 0x0D1D;
const GL_ALPHA_BITS = 0x0D55;
const GL_ALPHA_INTEGER = 0x8D97;
const GL_ALPHA_SCALE = 0x0D1C;
const GL_ALPHA_TEST = 0x0BC0;
const GL_ALPHA_TEST_FUNC = 0x0BC1;
const GL_ALPHA_TEST_REF = 0x0BC2;
const GL_ALREADY_SIGNALED = 0x911A;
const GL_ALWAYS = 0x0207;
const GL_AMBIENT = 0x1200;
const GL_AMBIENT_AND_DIFFUSE = 0x1602;
const GL_AND = 0x1501;
const GL_AND_INVERTED = 0x1504;
const GL_AND_REVERSE = 0x1502;
const GL_ANY_SAMPLES_PASSED = 0x8C2F;
const GL_ANY_SAMPLES_PASSED_CONSERVATIVE = 0x8D6A;
const GL_ARRAY_BUFFER = 0x8892;
const GL_ARRAY_BUFFER_BINDING = 0x8894;
const GL_ARRAY_SIZE = 0x92FB;
const GL_ARRAY_STRIDE = 0x92FE;
const GL_ATOMIC_COUNTER_BARRIER_BIT = 0x00001000;
const GL_ATOMIC_COUNTER_BUFFER = 0x92C0;
const GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTERS = 0x92C5;
const GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTER_INDICES = 0x92C6;
const GL_ATOMIC_COUNTER_BUFFER_BINDING = 0x92C1;
const GL_ATOMIC_COUNTER_BUFFER_DATA_SIZE = 0x92C4;
const GL_ATOMIC_COUNTER_BUFFER_INDEX = 0x9301;
const GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_COMPUTE_SHADER = 0x90ED;
const GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_FRAGMENT_SHADER = 0x92CB;
const GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_GEOMETRY_SHADER = 0x92CA;
const GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_CONTROL_SHADER = 0x92C8;
const GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_EVALUATION_SHADER = 0x92C9;
const GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_VERTEX_SHADER = 0x92C7;
const GL_ATOMIC_COUNTER_BUFFER_SIZE = 0x92C3;
const GL_ATOMIC_COUNTER_BUFFER_START = 0x92C2;
const GL_ATTACHED_SHADERS = 0x8B85;
const GL_ATTRIB_STACK_DEPTH = 0x0BB0;
const GL_AUTO_GENERATE_MIPMAP = 0x8295;
const GL_AUTO_NORMAL = 0x0D80;
const GL_AUX0 = 0x0409;
const GL_AUX1 = 0x040A;
const GL_AUX2 = 0x040B;
const GL_AUX3 = 0x040C;
const GL_AUX_BUFFERS = 0x0C00;
const GL_BACK = 0x0405;
const GL_BACK_LEFT = 0x0402;
const GL_BACK_RIGHT = 0x0403;
const GL_BGR = 0x80E0;
const GL_BGRA = 0x80E1;
const GL_BGRA_INTEGER = 0x8D9B;
const GL_BGR_INTEGER = 0x8D9A;
const GL_BITMAP = 0x1A00;
const GL_BITMAP_TOKEN = 0x0704;
const GL_BLEND = 0x0BE2;
const GL_BLEND_COLOR = 0x8005;
const GL_BLEND_DST = 0x0BE0;
const GL_BLEND_DST_ALPHA = 0x80CA;
const GL_BLEND_DST_RGB = 0x80C8;
const GL_BLEND_EQUATION = 0x8009;
const GL_BLEND_EQUATION_ALPHA = 0x883D;
const GL_BLEND_EQUATION_RGB = 0x8009;
const GL_BLEND_SRC = 0x0BE1;
const GL_BLEND_SRC_ALPHA = 0x80CB;
const GL_BLEND_SRC_RGB = 0x80C9;
const GL_BLOCK_INDEX = 0x92FD;
const GL_BLUE = 0x1905;
const GL_BLUE_BIAS = 0x0D1B;
const GL_BLUE_BITS = 0x0D54;
const GL_BLUE_INTEGER = 0x8D96;
const GL_BLUE_SCALE = 0x0D1A;
const GL_BOOL = 0x8B56;
const GL_BOOL_VEC2 = 0x8B57;
const GL_BOOL_VEC3 = 0x8B58;
const GL_BOOL_VEC4 = 0x8B59;
const GL_BUFFER = 0x82E0;
const GL_BUFFER_ACCESS = 0x88BB;
const GL_BUFFER_ACCESS_FLAGS = 0x911F;
const GL_BUFFER_BINDING = 0x9302;
const GL_BUFFER_DATA_SIZE = 0x9303;
const GL_BUFFER_MAPPED = 0x88BC;
const GL_BUFFER_MAP_LENGTH = 0x9120;
const GL_BUFFER_MAP_OFFSET = 0x9121;
const GL_BUFFER_MAP_POINTER = 0x88BD;
const GL_BUFFER_SIZE = 0x8764;
const GL_BUFFER_UPDATE_BARRIER_BIT = 0x00000200;
const GL_BUFFER_USAGE = 0x8765;
const GL_BUFFER_VARIABLE = 0x92E5;
const GL_BYTE = 0x1400;
const GL_C3F_V3F = 0x2A24;
const GL_C4F_N3F_V3F = 0x2A26;
const GL_C4UB_V2F = 0x2A22;
const GL_C4UB_V3F = 0x2A23;
const GL_CAVEAT_SUPPORT = 0x82B8;
const GL_CCW = 0x0901;
const GL_CLAMP = 0x2900;
const GL_CLAMP_FRAGMENT_COLOR = 0x891B;
const GL_CLAMP_READ_COLOR = 0x891C;
const GL_CLAMP_TO_BORDER = 0x812D;
const GL_CLAMP_TO_EDGE = 0x812F;
const GL_CLAMP_VERTEX_COLOR = 0x891A;
const GL_CLEAR = 0x1500;
const GL_CLEAR_BUFFER = 0x82B4;
const GL_CLIENT_ACTIVE_TEXTURE = 0x84E1;
const GL_CLIENT_ALL_ATTRIB_BITS = 0xFFFFFFFF;
const GL_CLIENT_ATTRIB_STACK_DEPTH = 0x0BB1;
const GL_CLIENT_PIXEL_STORE_BIT = 0x00000001;
const GL_CLIENT_VERTEX_ARRAY_BIT = 0x00000002;
const GL_CLIP_DISTANCE0 = 0x3000;
const GL_CLIP_DISTANCE1 = 0x3001;
const GL_CLIP_DISTANCE2 = 0x3002;
const GL_CLIP_DISTANCE3 = 0x3003;
const GL_CLIP_DISTANCE4 = 0x3004;
const GL_CLIP_DISTANCE5 = 0x3005;
const GL_CLIP_DISTANCE6 = 0x3006;
const GL_CLIP_DISTANCE7 = 0x3007;
const GL_CLIP_PLANE0 = 0x3000;
const GL_CLIP_PLANE1 = 0x3001;
const GL_CLIP_PLANE2 = 0x3002;
const GL_CLIP_PLANE3 = 0x3003;
const GL_CLIP_PLANE4 = 0x3004;
const GL_CLIP_PLANE5 = 0x3005;
const GL_COEFF = 0x0A00;
const GL_COLOR = 0x1800;
const GL_COLOR_ARRAY = 0x8076;
const GL_COLOR_ARRAY_BUFFER_BINDING = 0x8898;
const GL_COLOR_ARRAY_POINTER = 0x8090;
const GL_COLOR_ARRAY_SIZE = 0x8081;
const GL_COLOR_ARRAY_STRIDE = 0x8083;
const GL_COLOR_ARRAY_TYPE = 0x8082;
const GL_COLOR_ATTACHMENT0 = 0x8CE0;
const GL_COLOR_ATTACHMENT1 = 0x8CE1;
const GL_COLOR_ATTACHMENT10 = 0x8CEA;
const GL_COLOR_ATTACHMENT11 = 0x8CEB;
const GL_COLOR_ATTACHMENT12 = 0x8CEC;
const GL_COLOR_ATTACHMENT13 = 0x8CED;
const GL_COLOR_ATTACHMENT14 = 0x8CEE;
const GL_COLOR_ATTACHMENT15 = 0x8CEF;
const GL_COLOR_ATTACHMENT16 = 0x8CF0;
const GL_COLOR_ATTACHMENT17 = 0x8CF1;
const GL_COLOR_ATTACHMENT18 = 0x8CF2;
const GL_COLOR_ATTACHMENT19 = 0x8CF3;
const GL_COLOR_ATTACHMENT2 = 0x8CE2;
const GL_COLOR_ATTACHMENT20 = 0x8CF4;
const GL_COLOR_ATTACHMENT21 = 0x8CF5;
const GL_COLOR_ATTACHMENT22 = 0x8CF6;
const GL_COLOR_ATTACHMENT23 = 0x8CF7;
const GL_COLOR_ATTACHMENT24 = 0x8CF8;
const GL_COLOR_ATTACHMENT25 = 0x8CF9;
const GL_COLOR_ATTACHMENT26 = 0x8CFA;
const GL_COLOR_ATTACHMENT27 = 0x8CFB;
const GL_COLOR_ATTACHMENT28 = 0x8CFC;
const GL_COLOR_ATTACHMENT29 = 0x8CFD;
const GL_COLOR_ATTACHMENT3 = 0x8CE3;
const GL_COLOR_ATTACHMENT30 = 0x8CFE;
const GL_COLOR_ATTACHMENT31 = 0x8CFF;
const GL_COLOR_ATTACHMENT4 = 0x8CE4;
const GL_COLOR_ATTACHMENT5 = 0x8CE5;
const GL_COLOR_ATTACHMENT6 = 0x8CE6;
const GL_COLOR_ATTACHMENT7 = 0x8CE7;
const GL_COLOR_ATTACHMENT8 = 0x8CE8;
const GL_COLOR_ATTACHMENT9 = 0x8CE9;
const GL_COLOR_BUFFER_BIT = 0x00004000;
const GL_COLOR_CLEAR_VALUE = 0x0C22;
const GL_COLOR_COMPONENTS = 0x8283;
const GL_COLOR_ENCODING = 0x8296;
const GL_COLOR_INDEX = 0x1900;
const GL_COLOR_INDEXES = 0x1603;
const GL_COLOR_LOGIC_OP = 0x0BF2;
const GL_COLOR_MATERIAL = 0x0B57;
const GL_COLOR_MATERIAL_FACE = 0x0B55;
const GL_COLOR_MATERIAL_PARAMETER = 0x0B56;
const GL_COLOR_RENDERABLE = 0x8286;
const GL_COLOR_SUM = 0x8458;
const GL_COLOR_WRITEMASK = 0x0C23;
const GL_COMBINE = 0x8570;
const GL_COMBINE_ALPHA = 0x8572;
const GL_COMBINE_RGB = 0x8571;
const GL_COMMAND_BARRIER_BIT = 0x00000040;
const GL_COMPARE_REF_TO_TEXTURE = 0x884E;
const GL_COMPARE_R_TO_TEXTURE = 0x884E;
const GL_COMPATIBLE_SUBROUTINES = 0x8E4B;
const GL_COMPILE = 0x1300;
const GL_COMPILE_AND_EXECUTE = 0x1301;
const GL_COMPILE_STATUS = 0x8B81;
const GL_COMPRESSED_ALPHA = 0x84E9;
const GL_COMPRESSED_INTENSITY = 0x84EC;
const GL_COMPRESSED_LUMINANCE = 0x84EA;
const GL_COMPRESSED_LUMINANCE_ALPHA = 0x84EB;
const GL_COMPRESSED_R11_EAC = 0x9270;
const GL_COMPRESSED_RED = 0x8225;
const GL_COMPRESSED_RED_RGTC1 = 0x8DBB;
const GL_COMPRESSED_RG = 0x8226;
const GL_COMPRESSED_RG11_EAC = 0x9272;
const GL_COMPRESSED_RGB = 0x84ED;
const GL_COMPRESSED_RGB8_ETC2 = 0x9274;
const GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 0x9276;
const GL_COMPRESSED_RGBA = 0x84EE;
const GL_COMPRESSED_RGBA8_ETC2_EAC = 0x9278;
const GL_COMPRESSED_RGBA_BPTC_UNORM = 0x8E8C;
const GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT = 0x8E8E;
const GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT = 0x8E8F;
const GL_COMPRESSED_RG_RGTC2 = 0x8DBD;
const GL_COMPRESSED_SIGNED_R11_EAC = 0x9271;
const GL_COMPRESSED_SIGNED_RED_RGTC1 = 0x8DBC;
const GL_COMPRESSED_SIGNED_RG11_EAC = 0x9273;
const GL_COMPRESSED_SIGNED_RG_RGTC2 = 0x8DBE;
const GL_COMPRESSED_SLUMINANCE = 0x8C4A;
const GL_COMPRESSED_SLUMINANCE_ALPHA = 0x8C4B;
const GL_COMPRESSED_SRGB = 0x8C48;
const GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 0x9279;
const GL_COMPRESSED_SRGB8_ETC2 = 0x9275;
const GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 0x9277;
const GL_COMPRESSED_SRGB_ALPHA = 0x8C49;
const GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM = 0x8E8D;
const GL_COMPRESSED_TEXTURE_FORMATS = 0x86A3;
const GL_COMPUTE_SHADER = 0x91B9;
const GL_COMPUTE_SHADER_BIT = 0x00000020;
const GL_COMPUTE_SUBROUTINE = 0x92ED;
const GL_COMPUTE_SUBROUTINE_UNIFORM = 0x92F3;
const GL_COMPUTE_TEXTURE = 0x82A0;
const GL_COMPUTE_WORK_GROUP_SIZE = 0x8267;
const GL_CONDITION_SATISFIED = 0x911C;
const GL_CONSTANT = 0x8576;
const GL_CONSTANT_ALPHA = 0x8003;
const GL_CONSTANT_ATTENUATION = 0x1207;
const GL_CONSTANT_COLOR = 0x8001;
const GL_CONTEXT_COMPATIBILITY_PROFILE_BIT = 0x00000002;
const GL_CONTEXT_CORE_PROFILE_BIT = 0x00000001;
const GL_CONTEXT_FLAGS = 0x821E;
const GL_CONTEXT_FLAG_DEBUG_BIT = 0x00000002;
const GL_CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT = 0x00000001;
const GL_CONTEXT_PROFILE_MASK = 0x9126;
const GL_COORD_REPLACE = 0x8862;
const GL_COPY = 0x1503;
const GL_COPY_INVERTED = 0x150C;
const GL_COPY_PIXEL_TOKEN = 0x0706;
const GL_COPY_READ_BUFFER = 0x8F36;
const GL_COPY_READ_BUFFER_BINDING = 0x8F36;
const GL_COPY_WRITE_BUFFER = 0x8F37;
const GL_COPY_WRITE_BUFFER_BINDING = 0x8F37;
const GL_CULL_FACE = 0x0B44;
const GL_CULL_FACE_MODE = 0x0B45;
const GL_CURRENT_BIT = 0x00000001;
const GL_CURRENT_COLOR = 0x0B00;
const GL_CURRENT_FOG_COORD = 0x8453;
const GL_CURRENT_FOG_COORDINATE = 0x8453;
const GL_CURRENT_INDEX = 0x0B01;
const GL_CURRENT_NORMAL = 0x0B02;
const GL_CURRENT_PROGRAM = 0x8B8D;
const GL_CURRENT_QUERY = 0x8865;
const GL_CURRENT_RASTER_COLOR = 0x0B04;
const GL_CURRENT_RASTER_DISTANCE = 0x0B09;
const GL_CURRENT_RASTER_INDEX = 0x0B05;
const GL_CURRENT_RASTER_POSITION = 0x0B07;
const GL_CURRENT_RASTER_POSITION_VALID = 0x0B08;
const GL_CURRENT_RASTER_SECONDARY_COLOR = 0x845F;
const GL_CURRENT_RASTER_TEXTURE_COORDS = 0x0B06;
const GL_CURRENT_SECONDARY_COLOR = 0x8459;
const GL_CURRENT_TEXTURE_COORDS = 0x0B03;
const GL_CURRENT_VERTEX_ATTRIB = 0x8626;
const GL_CW = 0x0900;
const GL_DEBUG_CALLBACK_FUNCTION = 0x8244;
const GL_DEBUG_CALLBACK_USER_PARAM = 0x8245;
const GL_DEBUG_GROUP_STACK_DEPTH = 0x826D;
const GL_DEBUG_LOGGED_MESSAGES = 0x9145;
const GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH = 0x8243;
const GL_DEBUG_OUTPUT = 0x92E0;
const GL_DEBUG_OUTPUT_SYNCHRONOUS = 0x8242;
const GL_DEBUG_SEVERITY_HIGH = 0x9146;
const GL_DEBUG_SEVERITY_LOW = 0x9148;
const GL_DEBUG_SEVERITY_MEDIUM = 0x9147;
const GL_DEBUG_SEVERITY_NOTIFICATION = 0x826B;
const GL_DEBUG_SOURCE_API = 0x8246;
const GL_DEBUG_SOURCE_APPLICATION = 0x824A;
const GL_DEBUG_SOURCE_OTHER = 0x824B;
const GL_DEBUG_SOURCE_SHADER_COMPILER = 0x8248;
const GL_DEBUG_SOURCE_THIRD_PARTY = 0x8249;
const GL_DEBUG_SOURCE_WINDOW_SYSTEM = 0x8247;
const GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR = 0x824D;
const GL_DEBUG_TYPE_ERROR = 0x824C;
const GL_DEBUG_TYPE_MARKER = 0x8268;
const GL_DEBUG_TYPE_OTHER = 0x8251;
const GL_DEBUG_TYPE_PERFORMANCE = 0x8250;
const GL_DEBUG_TYPE_POP_GROUP = 0x826A;
const GL_DEBUG_TYPE_PORTABILITY = 0x824F;
const GL_DEBUG_TYPE_PUSH_GROUP = 0x8269;
const GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR = 0x824E;
const GL_DECAL = 0x2101;
const GL_DECR = 0x1E03;
const GL_DECR_WRAP = 0x8508;
const GL_DELETE_STATUS = 0x8B80;
const GL_DEPTH = 0x1801;
const GL_DEPTH24_STENCIL8 = 0x88F0;
const GL_DEPTH32F_STENCIL8 = 0x8CAD;
const GL_DEPTH_ATTACHMENT = 0x8D00;
const GL_DEPTH_BIAS = 0x0D1F;
const GL_DEPTH_BITS = 0x0D56;
const GL_DEPTH_BUFFER_BIT = 0x00000100;
const GL_DEPTH_CLAMP = 0x864F;
const GL_DEPTH_CLEAR_VALUE = 0x0B73;
const GL_DEPTH_COMPONENT = 0x1902;
const GL_DEPTH_COMPONENT16 = 0x81A5;
const GL_DEPTH_COMPONENT24 = 0x81A6;
const GL_DEPTH_COMPONENT32 = 0x81A7;
const GL_DEPTH_COMPONENT32F = 0x8CAC;
const GL_DEPTH_COMPONENTS = 0x8284;
const GL_DEPTH_FUNC = 0x0B74;
const GL_DEPTH_RANGE = 0x0B70;
const GL_DEPTH_RENDERABLE = 0x8287;
const GL_DEPTH_SCALE = 0x0D1E;
const GL_DEPTH_STENCIL = 0x84F9;
const GL_DEPTH_STENCIL_ATTACHMENT = 0x821A;
const GL_DEPTH_STENCIL_TEXTURE_MODE = 0x90EA;
const GL_DEPTH_TEST = 0x0B71;
const GL_DEPTH_TEXTURE_MODE = 0x884B;
const GL_DEPTH_WRITEMASK = 0x0B72;
const GL_DIFFUSE = 0x1201;
const GL_DISPATCH_INDIRECT_BUFFER = 0x90EE;
const GL_DISPATCH_INDIRECT_BUFFER_BINDING = 0x90EF;
const GL_DISPLAY_LIST = 0x82E7;
const GL_DITHER = 0x0BD0;
const GL_DOMAIN = 0x0A02;
const GL_DONT_CARE = 0x1100;
const GL_DOT3_RGB = 0x86AE;
const GL_DOT3_RGBA = 0x86AF;
const GL_DOUBLE = 0x140A;
const GL_DOUBLEBUFFER = 0x0C32;
const GL_DOUBLE_MAT2 = 0x8F46;
const GL_DOUBLE_MAT2X3 = 0x8F49;
const GL_DOUBLE_MAT2X4 = 0x8F4A;
const GL_DOUBLE_MAT3 = 0x8F47;
const GL_DOUBLE_MAT3X2 = 0x8F4B;
const GL_DOUBLE_MAT3X4 = 0x8F4C;
const GL_DOUBLE_MAT4 = 0x8F48;
const GL_DOUBLE_MAT4X2 = 0x8F4D;
const GL_DOUBLE_MAT4X3 = 0x8F4E;
const GL_DOUBLE_VEC2 = 0x8FFC;
const GL_DOUBLE_VEC3 = 0x8FFD;
const GL_DOUBLE_VEC4 = 0x8FFE;
const GL_DRAW_BUFFER = 0x0C01;
const GL_DRAW_BUFFER0 = 0x8825;
const GL_DRAW_BUFFER1 = 0x8826;
const GL_DRAW_BUFFER10 = 0x882F;
const GL_DRAW_BUFFER11 = 0x8830;
const GL_DRAW_BUFFER12 = 0x8831;
const GL_DRAW_BUFFER13 = 0x8832;
const GL_DRAW_BUFFER14 = 0x8833;
const GL_DRAW_BUFFER15 = 0x8834;
const GL_DRAW_BUFFER2 = 0x8827;
const GL_DRAW_BUFFER3 = 0x8828;
const GL_DRAW_BUFFER4 = 0x8829;
const GL_DRAW_BUFFER5 = 0x882A;
const GL_DRAW_BUFFER6 = 0x882B;
const GL_DRAW_BUFFER7 = 0x882C;
const GL_DRAW_BUFFER8 = 0x882D;
const GL_DRAW_BUFFER9 = 0x882E;
const GL_DRAW_FRAMEBUFFER = 0x8CA9;
const GL_DRAW_FRAMEBUFFER_BINDING = 0x8CA6;
const GL_DRAW_INDIRECT_BUFFER = 0x8F3F;
const GL_DRAW_INDIRECT_BUFFER_BINDING = 0x8F43;
const GL_DRAW_PIXEL_TOKEN = 0x0705;
const GL_DST_ALPHA = 0x0304;
const GL_DST_COLOR = 0x0306;
const GL_DYNAMIC_COPY = 0x88EA;
const GL_DYNAMIC_DRAW = 0x88E8;
const GL_DYNAMIC_READ = 0x88E9;
const GL_EDGE_FLAG = 0x0B43;
const GL_EDGE_FLAG_ARRAY = 0x8079;
const GL_EDGE_FLAG_ARRAY_BUFFER_BINDING = 0x889B;
const GL_EDGE_FLAG_ARRAY_POINTER = 0x8093;
const GL_EDGE_FLAG_ARRAY_STRIDE = 0x808C;
const GL_ELEMENT_ARRAY_BARRIER_BIT = 0x00000002;
const GL_ELEMENT_ARRAY_BUFFER = 0x8893;
const GL_ELEMENT_ARRAY_BUFFER_BINDING = 0x8895;
const GL_EMISSION = 0x1600;
const GL_ENABLE_BIT = 0x00002000;
const GL_EQUAL = 0x0202;
const GL_EQUIV = 0x1509;
const GL_EVAL_BIT = 0x00010000;
const GL_EXP = 0x0800;
const GL_EXP2 = 0x0801;
const GL_EXTENSIONS = 0x1F03;
const GL_EYE_LINEAR = 0x2400;
const GL_EYE_PLANE = 0x2502;
const GL_FALSE = 0;
const GL_FASTEST = 0x1101;
const GL_FEEDBACK = 0x1C01;
const GL_FEEDBACK_BUFFER_POINTER = 0x0DF0;
const GL_FEEDBACK_BUFFER_SIZE = 0x0DF1;
const GL_FEEDBACK_BUFFER_TYPE = 0x0DF2;
const GL_FILL = 0x1B02;
const GL_FILTER = 0x829A;
const GL_FIRST_VERTEX_CONVENTION = 0x8E4D;
const GL_FIXED = 0x140C;
const GL_FIXED_ONLY = 0x891D;
const GL_FLAT = 0x1D00;
const GL_FLOAT = 0x1406;
const GL_FLOAT_32_UNSIGNED_INT_24_8_REV = 0x8DAD;
const GL_FLOAT_MAT2 = 0x8B5A;
const GL_FLOAT_MAT2X3 = 0x8B65;
const GL_FLOAT_MAT2X4 = 0x8B66;
const GL_FLOAT_MAT3 = 0x8B5B;
const GL_FLOAT_MAT3X2 = 0x8B67;
const GL_FLOAT_MAT3X4 = 0x8B68;
const GL_FLOAT_MAT4 = 0x8B5C;
const GL_FLOAT_MAT4X2 = 0x8B69;
const GL_FLOAT_MAT4X3 = 0x8B6A;
const GL_FLOAT_VEC2 = 0x8B50;
const GL_FLOAT_VEC3 = 0x8B51;
const GL_FLOAT_VEC4 = 0x8B52;
const GL_FOG = 0x0B60;
const GL_FOG_BIT = 0x00000080;
const GL_FOG_COLOR = 0x0B66;
const GL_FOG_COORD = 0x8451;
const GL_FOG_COORDINATE = 0x8451;
const GL_FOG_COORDINATE_ARRAY = 0x8457;
const GL_FOG_COORDINATE_ARRAY_BUFFER_BINDING = 0x889D;
const GL_FOG_COORDINATE_ARRAY_POINTER = 0x8456;
const GL_FOG_COORDINATE_ARRAY_STRIDE = 0x8455;
const GL_FOG_COORDINATE_ARRAY_TYPE = 0x8454;
const GL_FOG_COORDINATE_SOURCE = 0x8450;
const GL_FOG_COORD_ARRAY = 0x8457;
const GL_FOG_COORD_ARRAY_BUFFER_BINDING = 0x889D;
const GL_FOG_COORD_ARRAY_POINTER = 0x8456;
const GL_FOG_COORD_ARRAY_STRIDE = 0x8455;
const GL_FOG_COORD_ARRAY_TYPE = 0x8454;
const GL_FOG_COORD_SRC = 0x8450;
const GL_FOG_DENSITY = 0x0B62;
const GL_FOG_END = 0x0B64;
const GL_FOG_HINT = 0x0C54;
const GL_FOG_INDEX = 0x0B61;
const GL_FOG_MODE = 0x0B65;
const GL_FOG_START = 0x0B63;
const GL_FRACTIONAL_EVEN = 0x8E7C;
const GL_FRACTIONAL_ODD = 0x8E7B;
const GL_FRAGMENT_DEPTH = 0x8452;
const GL_FRAGMENT_INTERPOLATION_OFFSET_BITS = 0x8E5D;
const GL_FRAGMENT_SHADER = 0x8B30;
const GL_FRAGMENT_SHADER_BIT = 0x00000002;
const GL_FRAGMENT_SHADER_DERIVATIVE_HINT = 0x8B8B;
const GL_FRAGMENT_SUBROUTINE = 0x92EC;
const GL_FRAGMENT_SUBROUTINE_UNIFORM = 0x92F2;
const GL_FRAGMENT_TEXTURE = 0x829F;
const GL_FRAMEBUFFER = 0x8D40;
const GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE = 0x8215;
const GL_FRAMEBUFFER_ATTACHMENT_BLUE_SIZE = 0x8214;
const GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING = 0x8210;
const GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE = 0x8211;
const GL_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE = 0x8216;
const GL_FRAMEBUFFER_ATTACHMENT_GREEN_SIZE = 0x8213;
const GL_FRAMEBUFFER_ATTACHMENT_LAYERED = 0x8DA7;
const GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME = 0x8CD1;
const GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE = 0x8CD0;
const GL_FRAMEBUFFER_ATTACHMENT_RED_SIZE = 0x8212;
const GL_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE = 0x8217;
const GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = 0x8CD3;
const GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER = 0x8CD4;
const GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL = 0x8CD2;
const GL_FRAMEBUFFER_BARRIER_BIT = 0x00000400;
const GL_FRAMEBUFFER_BINDING = 0x8CA6;
const GL_FRAMEBUFFER_BLEND = 0x828B;
const GL_FRAMEBUFFER_COMPLETE = 0x8CD5;
const GL_FRAMEBUFFER_DEFAULT = 0x8218;
const GL_FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS = 0x9314;
const GL_FRAMEBUFFER_DEFAULT_HEIGHT = 0x9311;
const GL_FRAMEBUFFER_DEFAULT_LAYERS = 0x9312;
const GL_FRAMEBUFFER_DEFAULT_SAMPLES = 0x9313;
const GL_FRAMEBUFFER_DEFAULT_WIDTH = 0x9310;
const GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT = 0x8CD6;
const GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER = 0x8CDB;
const GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS = 0x8DA8;
const GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 0x8CD7;
const GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE = 0x8D56;
const GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER = 0x8CDC;
const GL_FRAMEBUFFER_RENDERABLE = 0x8289;
const GL_FRAMEBUFFER_RENDERABLE_LAYERED = 0x828A;
const GL_FRAMEBUFFER_SRGB = 0x8DB9;
const GL_FRAMEBUFFER_UNDEFINED = 0x8219;
const GL_FRAMEBUFFER_UNSUPPORTED = 0x8CDD;
const GL_FRONT = 0x0404;
const GL_FRONT_AND_BACK = 0x0408;
const GL_FRONT_FACE = 0x0B46;
const GL_FRONT_LEFT = 0x0400;
const GL_FRONT_RIGHT = 0x0401;
const GL_FULL_SUPPORT = 0x82B7;
const GL_FUNC_ADD = 0x8006;
const GL_FUNC_REVERSE_SUBTRACT = 0x800B;
const GL_FUNC_SUBTRACT = 0x800A;
const GL_GENERATE_MIPMAP = 0x8191;
const GL_GENERATE_MIPMAP_HINT = 0x8192;
const GL_GEOMETRY_INPUT_TYPE = 0x8917;
const GL_GEOMETRY_OUTPUT_TYPE = 0x8918;
const GL_GEOMETRY_SHADER = 0x8DD9;
const GL_GEOMETRY_SHADER_BIT = 0x00000004;
const GL_GEOMETRY_SHADER_INVOCATIONS = 0x887F;
const GL_GEOMETRY_SUBROUTINE = 0x92EB;
const GL_GEOMETRY_SUBROUTINE_UNIFORM = 0x92F1;
const GL_GEOMETRY_TEXTURE = 0x829E;
const GL_GEOMETRY_VERTICES_OUT = 0x8916;
const GL_GEQUAL = 0x0206;
const GL_GET_TEXTURE_IMAGE_FORMAT = 0x8291;
const GL_GET_TEXTURE_IMAGE_TYPE = 0x8292;
const GL_GREATER = 0x0204;
const GL_GREEN = 0x1904;
const GL_GREEN_BIAS = 0x0D19;
const GL_GREEN_BITS = 0x0D53;
const GL_GREEN_INTEGER = 0x8D95;
const GL_GREEN_SCALE = 0x0D18;
const GL_HALF_FLOAT = 0x140B;
const GL_HIGH_FLOAT = 0x8DF2;
const GL_HIGH_INT = 0x8DF5;
const GL_HINT_BIT = 0x00008000;
const GL_IMAGE_1D = 0x904C;
const GL_IMAGE_1D_ARRAY = 0x9052;
const GL_IMAGE_2D = 0x904D;
const GL_IMAGE_2D_ARRAY = 0x9053;
const GL_IMAGE_2D_MULTISAMPLE = 0x9055;
const GL_IMAGE_2D_MULTISAMPLE_ARRAY = 0x9056;
const GL_IMAGE_2D_RECT = 0x904F;
const GL_IMAGE_3D = 0x904E;
const GL_IMAGE_BINDING_ACCESS = 0x8F3E;
const GL_IMAGE_BINDING_FORMAT = 0x906E;
const GL_IMAGE_BINDING_LAYER = 0x8F3D;
const GL_IMAGE_BINDING_LAYERED = 0x8F3C;
const GL_IMAGE_BINDING_LEVEL = 0x8F3B;
const GL_IMAGE_BINDING_NAME = 0x8F3A;
const GL_IMAGE_BUFFER = 0x9051;
const GL_IMAGE_CLASS_10_10_10_2 = 0x82C3;
const GL_IMAGE_CLASS_11_11_10 = 0x82C2;
const GL_IMAGE_CLASS_1_X_16 = 0x82BE;
const GL_IMAGE_CLASS_1_X_32 = 0x82BB;
const GL_IMAGE_CLASS_1_X_8 = 0x82C1;
const GL_IMAGE_CLASS_2_X_16 = 0x82BD;
const GL_IMAGE_CLASS_2_X_32 = 0x82BA;
const GL_IMAGE_CLASS_2_X_8 = 0x82C0;
const GL_IMAGE_CLASS_4_X_16 = 0x82BC;
const GL_IMAGE_CLASS_4_X_32 = 0x82B9;
const GL_IMAGE_CLASS_4_X_8 = 0x82BF;
const GL_IMAGE_COMPATIBILITY_CLASS = 0x82A8;
const GL_IMAGE_CUBE = 0x9050;
const GL_IMAGE_CUBE_MAP_ARRAY = 0x9054;
const GL_IMAGE_FORMAT_COMPATIBILITY_BY_CLASS = 0x90C9;
const GL_IMAGE_FORMAT_COMPATIBILITY_BY_SIZE = 0x90C8;
const GL_IMAGE_FORMAT_COMPATIBILITY_TYPE = 0x90C7;
const GL_IMAGE_PIXEL_FORMAT = 0x82A9;
const GL_IMAGE_PIXEL_TYPE = 0x82AA;
const GL_IMAGE_TEXEL_SIZE = 0x82A7;
const GL_IMPLEMENTATION_COLOR_READ_FORMAT = 0x8B9B;
const GL_IMPLEMENTATION_COLOR_READ_TYPE = 0x8B9A;
const GL_INCR = 0x1E02;
const GL_INCR_WRAP = 0x8507;
const GL_INDEX = 0x8222;
const GL_INDEX_ARRAY = 0x8077;
const GL_INDEX_ARRAY_BUFFER_BINDING = 0x8899;
const GL_INDEX_ARRAY_POINTER = 0x8091;
const GL_INDEX_ARRAY_STRIDE = 0x8086;
const GL_INDEX_ARRAY_TYPE = 0x8085;
const GL_INDEX_BITS = 0x0D51;
const GL_INDEX_CLEAR_VALUE = 0x0C20;
const GL_INDEX_LOGIC_OP = 0x0BF1;
const GL_INDEX_MODE = 0x0C30;
const GL_INDEX_OFFSET = 0x0D13;
const GL_INDEX_SHIFT = 0x0D12;
const GL_INDEX_WRITEMASK = 0x0C21;
const GL_INFO_LOG_LENGTH = 0x8B84;
const GL_INT = 0x1404;
const GL_INTENSITY = 0x8049;
const GL_INTENSITY12 = 0x804C;
const GL_INTENSITY16 = 0x804D;
const GL_INTENSITY4 = 0x804A;
const GL_INTENSITY8 = 0x804B;
const GL_INTERLEAVED_ATTRIBS = 0x8C8C;
const GL_INTERNALFORMAT_ALPHA_SIZE = 0x8274;
const GL_INTERNALFORMAT_ALPHA_TYPE = 0x827B;
const GL_INTERNALFORMAT_BLUE_SIZE = 0x8273;
const GL_INTERNALFORMAT_BLUE_TYPE = 0x827A;
const GL_INTERNALFORMAT_DEPTH_SIZE = 0x8275;
const GL_INTERNALFORMAT_DEPTH_TYPE = 0x827C;
const GL_INTERNALFORMAT_GREEN_SIZE = 0x8272;
const GL_INTERNALFORMAT_GREEN_TYPE = 0x8279;
const GL_INTERNALFORMAT_PREFERRED = 0x8270;
const GL_INTERNALFORMAT_RED_SIZE = 0x8271;
const GL_INTERNALFORMAT_RED_TYPE = 0x8278;
const GL_INTERNALFORMAT_SHARED_SIZE = 0x8277;
const GL_INTERNALFORMAT_STENCIL_SIZE = 0x8276;
const GL_INTERNALFORMAT_STENCIL_TYPE = 0x827D;
const GL_INTERNALFORMAT_SUPPORTED = 0x826F;
const GL_INTERPOLATE = 0x8575;
const GL_INT_2_10_10_10_REV = 0x8D9F;
const GL_INT_IMAGE_1D = 0x9057;
const GL_INT_IMAGE_1D_ARRAY = 0x905D;
const GL_INT_IMAGE_2D = 0x9058;
const GL_INT_IMAGE_2D_ARRAY = 0x905E;
const GL_INT_IMAGE_2D_MULTISAMPLE = 0x9060;
const GL_INT_IMAGE_2D_MULTISAMPLE_ARRAY = 0x9061;
const GL_INT_IMAGE_2D_RECT = 0x905A;
const GL_INT_IMAGE_3D = 0x9059;
const GL_INT_IMAGE_BUFFER = 0x905C;
const GL_INT_IMAGE_CUBE = 0x905B;
const GL_INT_IMAGE_CUBE_MAP_ARRAY = 0x905F;
const GL_INT_SAMPLER_1D = 0x8DC9;
const GL_INT_SAMPLER_1D_ARRAY = 0x8DCE;
const GL_INT_SAMPLER_2D = 0x8DCA;
const GL_INT_SAMPLER_2D_ARRAY = 0x8DCF;
const GL_INT_SAMPLER_2D_MULTISAMPLE = 0x9109;
const GL_INT_SAMPLER_2D_MULTISAMPLE_ARRAY = 0x910C;
const GL_INT_SAMPLER_2D_RECT = 0x8DCD;
const GL_INT_SAMPLER_3D = 0x8DCB;
const GL_INT_SAMPLER_BUFFER = 0x8DD0;
const GL_INT_SAMPLER_CUBE = 0x8DCC;
const GL_INT_SAMPLER_CUBE_MAP_ARRAY = 0x900E;
const GL_INT_VEC2 = 0x8B53;
const GL_INT_VEC3 = 0x8B54;
const GL_INT_VEC4 = 0x8B55;
const GL_INVALID_ENUM = 0x0500;
const GL_INVALID_FRAMEBUFFER_OPERATION = 0x0506;
const GL_INVALID_INDEX = 0xFFFFFFFF;
const GL_INVALID_OPERATION = 0x0502;
const GL_INVALID_VALUE = 0x0501;
const GL_INVERT = 0x150A;
const GL_ISOLINES = 0x8E7A;
const GL_IS_PER_PATCH = 0x92E7;
const GL_IS_ROW_MAJOR = 0x9300;
const GL_KEEP = 0x1E00;
const GL_LAST_VERTEX_CONVENTION = 0x8E4E;
const GL_LAYER_PROVOKING_VERTEX = 0x825E;
const GL_LEFT = 0x0406;
const GL_LEQUAL = 0x0203;
const GL_LESS = 0x0201;
const GL_LIGHT0 = 0x4000;
const GL_LIGHT1 = 0x4001;
const GL_LIGHT2 = 0x4002;
const GL_LIGHT3 = 0x4003;
const GL_LIGHT4 = 0x4004;
const GL_LIGHT5 = 0x4005;
const GL_LIGHT6 = 0x4006;
const GL_LIGHT7 = 0x4007;
const GL_LIGHTING = 0x0B50;
const GL_LIGHTING_BIT = 0x00000040;
const GL_LIGHT_MODEL_AMBIENT = 0x0B53;
const GL_LIGHT_MODEL_COLOR_CONTROL = 0x81F8;
const GL_LIGHT_MODEL_LOCAL_VIEWER = 0x0B51;
const GL_LIGHT_MODEL_TWO_SIDE = 0x0B52;
const GL_LINE = 0x1B01;
const GL_LINEAR = 0x2601;
const GL_LINEAR_ATTENUATION = 0x1208;
const GL_LINEAR_MIPMAP_LINEAR = 0x2703;
const GL_LINEAR_MIPMAP_NEAREST = 0x2701;
const GL_LINES = 0x0001;
const GL_LINES_ADJACENCY = 0x000A;
const GL_LINE_BIT = 0x00000004;
const GL_LINE_LOOP = 0x0002;
const GL_LINE_RESET_TOKEN = 0x0707;
const GL_LINE_SMOOTH = 0x0B20;
const GL_LINE_SMOOTH_HINT = 0x0C52;
const GL_LINE_STIPPLE = 0x0B24;
const GL_LINE_STIPPLE_PATTERN = 0x0B25;
const GL_LINE_STIPPLE_REPEAT = 0x0B26;
const GL_LINE_STRIP = 0x0003;
const GL_LINE_STRIP_ADJACENCY = 0x000B;
const GL_LINE_TOKEN = 0x0702;
const GL_LINE_WIDTH = 0x0B21;
const GL_LINE_WIDTH_GRANULARITY = 0x0B23;
const GL_LINE_WIDTH_RANGE = 0x0B22;
const GL_LINK_STATUS = 0x8B82;
const GL_LIST_BASE = 0x0B32;
const GL_LIST_BIT = 0x00020000;
const GL_LIST_INDEX = 0x0B33;
const GL_LIST_MODE = 0x0B30;
const GL_LOAD = 0x0101;
const GL_LOCATION = 0x930E;
const GL_LOCATION_INDEX = 0x930F;
const GL_LOGIC_OP = 0x0BF1;
const GL_LOGIC_OP_MODE = 0x0BF0;
const GL_LOWER_LEFT = 0x8CA1;
const GL_LOW_FLOAT = 0x8DF0;
const GL_LOW_INT = 0x8DF3;
const GL_LUMINANCE = 0x1909;
const GL_LUMINANCE12 = 0x8041;
const GL_LUMINANCE12_ALPHA12 = 0x8047;
const GL_LUMINANCE12_ALPHA4 = 0x8046;
const GL_LUMINANCE16 = 0x8042;
const GL_LUMINANCE16_ALPHA16 = 0x8048;
const GL_LUMINANCE4 = 0x803F;
const GL_LUMINANCE4_ALPHA4 = 0x8043;
const GL_LUMINANCE6_ALPHA2 = 0x8044;
const GL_LUMINANCE8 = 0x8040;
const GL_LUMINANCE8_ALPHA8 = 0x8045;
const GL_LUMINANCE_ALPHA = 0x190A;
const GL_MAJOR_VERSION = 0x821B;
const GL_MANUAL_GENERATE_MIPMAP = 0x8294;
const GL_MAP1_COLOR_4 = 0x0D90;
const GL_MAP1_GRID_DOMAIN = 0x0DD0;
const GL_MAP1_GRID_SEGMENTS = 0x0DD1;
const GL_MAP1_INDEX = 0x0D91;
const GL_MAP1_NORMAL = 0x0D92;
const GL_MAP1_TEXTURE_COORD_1 = 0x0D93;
const GL_MAP1_TEXTURE_COORD_2 = 0x0D94;
const GL_MAP1_TEXTURE_COORD_3 = 0x0D95;
const GL_MAP1_TEXTURE_COORD_4 = 0x0D96;
const GL_MAP1_VERTEX_3 = 0x0D97;
const GL_MAP1_VERTEX_4 = 0x0D98;
const GL_MAP2_COLOR_4 = 0x0DB0;
const GL_MAP2_GRID_DOMAIN = 0x0DD2;
const GL_MAP2_GRID_SEGMENTS = 0x0DD3;
const GL_MAP2_INDEX = 0x0DB1;
const GL_MAP2_NORMAL = 0x0DB2;
const GL_MAP2_TEXTURE_COORD_1 = 0x0DB3;
const GL_MAP2_TEXTURE_COORD_2 = 0x0DB4;
const GL_MAP2_TEXTURE_COORD_3 = 0x0DB5;
const GL_MAP2_TEXTURE_COORD_4 = 0x0DB6;
const GL_MAP2_VERTEX_3 = 0x0DB7;
const GL_MAP2_VERTEX_4 = 0x0DB8;
const GL_MAP_COLOR = 0x0D10;
const GL_MAP_FLUSH_EXPLICIT_BIT = 0x0010;
const GL_MAP_INVALIDATE_BUFFER_BIT = 0x0008;
const GL_MAP_INVALIDATE_RANGE_BIT = 0x0004;
const GL_MAP_READ_BIT = 0x0001;
const GL_MAP_STENCIL = 0x0D11;
const GL_MAP_UNSYNCHRONIZED_BIT = 0x0020;
const GL_MAP_WRITE_BIT = 0x0002;
const GL_MATRIX_MODE = 0x0BA0;
const GL_MATRIX_STRIDE = 0x92FF;
const GL_MAX = 0x8008;
const GL_MAX_3D_TEXTURE_SIZE = 0x8073;
const GL_MAX_ARRAY_TEXTURE_LAYERS = 0x88FF;
const GL_MAX_ATOMIC_COUNTER_BUFFER_BINDINGS = 0x92DC;
const GL_MAX_ATOMIC_COUNTER_BUFFER_SIZE = 0x92D8;
const GL_MAX_ATTRIB_STACK_DEPTH = 0x0D35;
const GL_MAX_CLIENT_ATTRIB_STACK_DEPTH = 0x0D3B;
const GL_MAX_CLIP_DISTANCES = 0x0D32;
const GL_MAX_CLIP_PLANES = 0x0D32;
const GL_MAX_COLOR_ATTACHMENTS = 0x8CDF;
const GL_MAX_COLOR_TEXTURE_SAMPLES = 0x910E;
const GL_MAX_COMBINED_ATOMIC_COUNTERS = 0x92D7;
const GL_MAX_COMBINED_ATOMIC_COUNTER_BUFFERS = 0x92D1;
const GL_MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS = 0x8266;
const GL_MAX_COMBINED_DIMENSIONS = 0x8282;
const GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS = 0x8A33;
const GL_MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS = 0x8A32;
const GL_MAX_COMBINED_IMAGE_UNIFORMS = 0x90CF;
const GL_MAX_COMBINED_IMAGE_UNITS_AND_FRAGMENT_OUTPUTS = 0x8F39;
const GL_MAX_COMBINED_SHADER_OUTPUT_RESOURCES = 0x8F39;
const GL_MAX_COMBINED_SHADER_STORAGE_BLOCKS = 0x90DC;
const GL_MAX_COMBINED_TESS_CONTROL_UNIFORM_COMPONENTS = 0x8E1E;
const GL_MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS = 0x8E1F;
const GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS = 0x8B4D;
const GL_MAX_COMBINED_UNIFORM_BLOCKS = 0x8A2E;
const GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS = 0x8A31;
const GL_MAX_COMPUTE_ATOMIC_COUNTERS = 0x8265;
const GL_MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS = 0x8264;
const GL_MAX_COMPUTE_IMAGE_UNIFORMS = 0x91BD;
const GL_MAX_COMPUTE_SHADER_STORAGE_BLOCKS = 0x90DB;
const GL_MAX_COMPUTE_SHARED_MEMORY_SIZE = 0x8262;
const GL_MAX_COMPUTE_TEXTURE_IMAGE_UNITS = 0x91BC;
const GL_MAX_COMPUTE_UNIFORM_BLOCKS = 0x91BB;
const GL_MAX_COMPUTE_UNIFORM_COMPONENTS = 0x8263;
const GL_MAX_COMPUTE_WORK_GROUP_COUNT = 0x91BE;
const GL_MAX_COMPUTE_WORK_GROUP_INVOCATIONS = 0x90EB;
const GL_MAX_COMPUTE_WORK_GROUP_SIZE = 0x91BF;
const GL_MAX_CUBE_MAP_TEXTURE_SIZE = 0x851C;
const GL_MAX_DEBUG_GROUP_STACK_DEPTH = 0x826C;
const GL_MAX_DEBUG_LOGGED_MESSAGES = 0x9144;
const GL_MAX_DEBUG_MESSAGE_LENGTH = 0x9143;
const GL_MAX_DEPTH = 0x8280;
const GL_MAX_DEPTH_TEXTURE_SAMPLES = 0x910F;
const GL_MAX_DRAW_BUFFERS = 0x8824;
const GL_MAX_DUAL_SOURCE_DRAW_BUFFERS = 0x88FC;
const GL_MAX_ELEMENTS_INDICES = 0x80E9;
const GL_MAX_ELEMENTS_VERTICES = 0x80E8;
const GL_MAX_ELEMENT_INDEX = 0x8D6B;
const GL_MAX_EVAL_ORDER = 0x0D30;
const GL_MAX_FRAGMENT_ATOMIC_COUNTERS = 0x92D6;
const GL_MAX_FRAGMENT_ATOMIC_COUNTER_BUFFERS = 0x92D0;
const GL_MAX_FRAGMENT_IMAGE_UNIFORMS = 0x90CE;
const GL_MAX_FRAGMENT_INPUT_COMPONENTS = 0x9125;
const GL_MAX_FRAGMENT_INTERPOLATION_OFFSET = 0x8E5C;
const GL_MAX_FRAGMENT_SHADER_STORAGE_BLOCKS = 0x90DA;
const GL_MAX_FRAGMENT_UNIFORM_BLOCKS = 0x8A2D;
const GL_MAX_FRAGMENT_UNIFORM_COMPONENTS = 0x8B49;
const GL_MAX_FRAGMENT_UNIFORM_VECTORS = 0x8DFD;
const GL_MAX_FRAMEBUFFER_HEIGHT = 0x9316;
const GL_MAX_FRAMEBUFFER_LAYERS = 0x9317;
const GL_MAX_FRAMEBUFFER_SAMPLES = 0x9318;
const GL_MAX_FRAMEBUFFER_WIDTH = 0x9315;
const GL_MAX_GEOMETRY_ATOMIC_COUNTERS = 0x92D5;
const GL_MAX_GEOMETRY_ATOMIC_COUNTER_BUFFERS = 0x92CF;
const GL_MAX_GEOMETRY_IMAGE_UNIFORMS = 0x90CD;
const GL_MAX_GEOMETRY_INPUT_COMPONENTS = 0x9123;
const GL_MAX_GEOMETRY_OUTPUT_COMPONENTS = 0x9124;
const GL_MAX_GEOMETRY_OUTPUT_VERTICES = 0x8DE0;
const GL_MAX_GEOMETRY_SHADER_INVOCATIONS = 0x8E5A;
const GL_MAX_GEOMETRY_SHADER_STORAGE_BLOCKS = 0x90D7;
const GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS = 0x8C29;
const GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS = 0x8DE1;
const GL_MAX_GEOMETRY_UNIFORM_BLOCKS = 0x8A2C;
const GL_MAX_GEOMETRY_UNIFORM_COMPONENTS = 0x8DDF;
const GL_MAX_HEIGHT = 0x827F;
const GL_MAX_IMAGE_SAMPLES = 0x906D;
const GL_MAX_IMAGE_UNITS = 0x8F38;
const GL_MAX_INTEGER_SAMPLES = 0x9110;
const GL_MAX_LABEL_LENGTH = 0x82E8;
const GL_MAX_LAYERS = 0x8281;
const GL_MAX_LIGHTS = 0x0D31;
const GL_MAX_LIST_NESTING = 0x0B31;
const GL_MAX_MODELVIEW_STACK_DEPTH = 0x0D36;
const GL_MAX_NAME_LENGTH = 0x92F6;
const GL_MAX_NAME_STACK_DEPTH = 0x0D37;
const GL_MAX_NUM_ACTIVE_VARIABLES = 0x92F7;
const GL_MAX_NUM_COMPATIBLE_SUBROUTINES = 0x92F8;
const GL_MAX_PATCH_VERTICES = 0x8E7D;
const GL_MAX_PIXEL_MAP_TABLE = 0x0D34;
const GL_MAX_PROGRAM_TEXEL_OFFSET = 0x8905;
const GL_MAX_PROGRAM_TEXTURE_GATHER_OFFSET = 0x8E5F;
const GL_MAX_PROJECTION_STACK_DEPTH = 0x0D38;
const GL_MAX_RECTANGLE_TEXTURE_SIZE = 0x84F8;
const GL_MAX_RENDERBUFFER_SIZE = 0x84E8;
const GL_MAX_SAMPLES = 0x8D57;
const GL_MAX_SAMPLE_MASK_WORDS = 0x8E59;
const GL_MAX_SERVER_WAIT_TIMEOUT = 0x9111;
const GL_MAX_SHADER_STORAGE_BLOCK_SIZE = 0x90DE;
const GL_MAX_SHADER_STORAGE_BUFFER_BINDINGS = 0x90DD;
const GL_MAX_SUBROUTINES = 0x8DE7;
const GL_MAX_SUBROUTINE_UNIFORM_LOCATIONS = 0x8DE8;
const GL_MAX_TESS_CONTROL_ATOMIC_COUNTERS = 0x92D3;
const GL_MAX_TESS_CONTROL_ATOMIC_COUNTER_BUFFERS = 0x92CD;
const GL_MAX_TESS_CONTROL_IMAGE_UNIFORMS = 0x90CB;
const GL_MAX_TESS_CONTROL_INPUT_COMPONENTS = 0x886C;
const GL_MAX_TESS_CONTROL_OUTPUT_COMPONENTS = 0x8E83;
const GL_MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS = 0x90D8;
const GL_MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS = 0x8E81;
const GL_MAX_TESS_CONTROL_TOTAL_OUTPUT_COMPONENTS = 0x8E85;
const GL_MAX_TESS_CONTROL_UNIFORM_BLOCKS = 0x8E89;
const GL_MAX_TESS_CONTROL_UNIFORM_COMPONENTS = 0x8E7F;
const GL_MAX_TESS_EVALUATION_ATOMIC_COUNTERS = 0x92D4;
const GL_MAX_TESS_EVALUATION_ATOMIC_COUNTER_BUFFERS = 0x92CE;
const GL_MAX_TESS_EVALUATION_IMAGE_UNIFORMS = 0x90CC;
const GL_MAX_TESS_EVALUATION_INPUT_COMPONENTS = 0x886D;
const GL_MAX_TESS_EVALUATION_OUTPUT_COMPONENTS = 0x8E86;
const GL_MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS = 0x90D9;
const GL_MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS = 0x8E82;
const GL_MAX_TESS_EVALUATION_UNIFORM_BLOCKS = 0x8E8A;
const GL_MAX_TESS_EVALUATION_UNIFORM_COMPONENTS = 0x8E80;
const GL_MAX_TESS_GEN_LEVEL = 0x8E7E;
const GL_MAX_TESS_PATCH_COMPONENTS = 0x8E84;
const GL_MAX_TEXTURE_BUFFER_SIZE = 0x8C2B;
const GL_MAX_TEXTURE_COORDS = 0x8871;
const GL_MAX_TEXTURE_IMAGE_UNITS = 0x8872;
const GL_MAX_TEXTURE_LOD_BIAS = 0x84FD;
const GL_MAX_TEXTURE_SIZE = 0x0D33;
const GL_MAX_TEXTURE_STACK_DEPTH = 0x0D39;
const GL_MAX_TEXTURE_UNITS = 0x84E2;
const GL_MAX_TRANSFORM_FEEDBACK_BUFFERS = 0x8E70;
const GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS = 0x8C8A;
const GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS = 0x8C8B;
const GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS = 0x8C80;
const GL_MAX_UNIFORM_BLOCK_SIZE = 0x8A30;
const GL_MAX_UNIFORM_BUFFER_BINDINGS = 0x8A2F;
const GL_MAX_UNIFORM_LOCATIONS = 0x826E;
const GL_MAX_VARYING_COMPONENTS = 0x8B4B;
const GL_MAX_VARYING_FLOATS = 0x8B4B;
const GL_MAX_VARYING_VECTORS = 0x8DFC;
const GL_MAX_VERTEX_ATOMIC_COUNTERS = 0x92D2;
const GL_MAX_VERTEX_ATOMIC_COUNTER_BUFFERS = 0x92CC;
const GL_MAX_VERTEX_ATTRIBS = 0x8869;
const GL_MAX_VERTEX_ATTRIB_BINDINGS = 0x82DA;
const GL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET = 0x82D9;
const GL_MAX_VERTEX_IMAGE_UNIFORMS = 0x90CA;
const GL_MAX_VERTEX_OUTPUT_COMPONENTS = 0x9122;
const GL_MAX_VERTEX_SHADER_STORAGE_BLOCKS = 0x90D6;
const GL_MAX_VERTEX_STREAMS = 0x8E71;
const GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS = 0x8B4C;
const GL_MAX_VERTEX_UNIFORM_BLOCKS = 0x8A2B;
const GL_MAX_VERTEX_UNIFORM_COMPONENTS = 0x8B4A;
const GL_MAX_VERTEX_UNIFORM_VECTORS = 0x8DFB;
const GL_MAX_VIEWPORTS = 0x825B;
const GL_MAX_VIEWPORT_DIMS = 0x0D3A;
const GL_MAX_WIDTH = 0x827E;
const GL_MEDIUM_FLOAT = 0x8DF1;
const GL_MEDIUM_INT = 0x8DF4;
const GL_MIN = 0x8007;
const GL_MINOR_VERSION = 0x821C;
const GL_MIN_FRAGMENT_INTERPOLATION_OFFSET = 0x8E5B;
const GL_MIN_MAP_BUFFER_ALIGNMENT = 0x90BC;
const GL_MIN_PROGRAM_TEXEL_OFFSET = 0x8904;
const GL_MIN_PROGRAM_TEXTURE_GATHER_OFFSET = 0x8E5E;
const GL_MIN_SAMPLE_SHADING_VALUE = 0x8C37;
const GL_MIPMAP = 0x8293;
const GL_MIRRORED_REPEAT = 0x8370;
const GL_MODELVIEW = 0x1700;
const GL_MODELVIEW_MATRIX = 0x0BA6;
const GL_MODELVIEW_STACK_DEPTH = 0x0BA3;
const GL_MODULATE = 0x2100;
const GL_MULT = 0x0103;
const GL_MULTISAMPLE = 0x809D;
const GL_MULTISAMPLE_BIT = 0x20000000;
const GL_N3F_V3F = 0x2A25;
const GL_NAME_LENGTH = 0x92F9;
const GL_NAME_STACK_DEPTH = 0x0D70;
const GL_NAND = 0x150E;
const GL_NEAREST = 0x2600;
const GL_NEAREST_MIPMAP_LINEAR = 0x2702;
const GL_NEAREST_MIPMAP_NEAREST = 0x2700;
const GL_NEVER = 0x0200;
const GL_NICEST = 0x1102;
const GL_NONE = 0;
const GL_NOOP = 0x1505;
const GL_NOR = 0x1508;
const GL_NORMALIZE = 0x0BA1;
const GL_NORMAL_ARRAY = 0x8075;
const GL_NORMAL_ARRAY_BUFFER_BINDING = 0x8897;
const GL_NORMAL_ARRAY_POINTER = 0x808F;
const GL_NORMAL_ARRAY_STRIDE = 0x807F;
const GL_NORMAL_ARRAY_TYPE = 0x807E;
const GL_NORMAL_MAP = 0x8511;
const GL_NOTEQUAL = 0x0205;
const GL_NO_ERROR = 0;
const GL_NUM_ACTIVE_VARIABLES = 0x9304;
const GL_NUM_COMPATIBLE_SUBROUTINES = 0x8E4A;
const GL_NUM_COMPRESSED_TEXTURE_FORMATS = 0x86A2;
const GL_NUM_EXTENSIONS = 0x821D;
const GL_NUM_PROGRAM_BINARY_FORMATS = 0x87FE;
const GL_NUM_SAMPLE_COUNTS = 0x9380;
const GL_NUM_SHADER_BINARY_FORMATS = 0x8DF9;
const GL_NUM_SHADING_LANGUAGE_VERSIONS = 0x82E9;
const GL_OBJECT_LINEAR = 0x2401;
const GL_OBJECT_PLANE = 0x2501;
const GL_OBJECT_TYPE = 0x9112;
const GL_OFFSET = 0x92FC;
const GL_ONE = 1;
const GL_ONE_MINUS_CONSTANT_ALPHA = 0x8004;
const GL_ONE_MINUS_CONSTANT_COLOR = 0x8002;
const GL_ONE_MINUS_DST_ALPHA = 0x0305;
const GL_ONE_MINUS_DST_COLOR = 0x0307;
const GL_ONE_MINUS_SRC1_ALPHA = 0x88FB;
const GL_ONE_MINUS_SRC1_COLOR = 0x88FA;
const GL_ONE_MINUS_SRC_ALPHA = 0x0303;
const GL_ONE_MINUS_SRC_COLOR = 0x0301;
const GL_OPERAND0_ALPHA = 0x8598;
const GL_OPERAND0_RGB = 0x8590;
const GL_OPERAND1_ALPHA = 0x8599;
const GL_OPERAND1_RGB = 0x8591;
const GL_OPERAND2_ALPHA = 0x859A;
const GL_OPERAND2_RGB = 0x8592;
const GL_OR = 0x1507;
const GL_ORDER = 0x0A01;
const GL_OR_INVERTED = 0x150D;
const GL_OR_REVERSE = 0x150B;
const GL_OUT_OF_MEMORY = 0x0505;
const GL_PACK_ALIGNMENT = 0x0D05;
const GL_PACK_COMPRESSED_BLOCK_DEPTH = 0x912D;
const GL_PACK_COMPRESSED_BLOCK_HEIGHT = 0x912C;
const GL_PACK_COMPRESSED_BLOCK_SIZE = 0x912E;
const GL_PACK_COMPRESSED_BLOCK_WIDTH = 0x912B;
const GL_PACK_IMAGE_HEIGHT = 0x806C;
const GL_PACK_LSB_FIRST = 0x0D01;
const GL_PACK_ROW_LENGTH = 0x0D02;
const GL_PACK_SKIP_IMAGES = 0x806B;
const GL_PACK_SKIP_PIXELS = 0x0D04;
const GL_PACK_SKIP_ROWS = 0x0D03;
const GL_PACK_SWAP_BYTES = 0x0D00;
const GL_PASS_THROUGH_TOKEN = 0x0700;
const GL_PATCHES = 0x000E;
const GL_PATCH_DEFAULT_INNER_LEVEL = 0x8E73;
const GL_PATCH_DEFAULT_OUTER_LEVEL = 0x8E74;
const GL_PATCH_VERTICES = 0x8E72;
const GL_PERSPECTIVE_CORRECTION_HINT = 0x0C50;
const GL_PIXEL_BUFFER_BARRIER_BIT = 0x00000080;
const GL_PIXEL_MAP_A_TO_A = 0x0C79;
const GL_PIXEL_MAP_A_TO_A_SIZE = 0x0CB9;
const GL_PIXEL_MAP_B_TO_B = 0x0C78;
const GL_PIXEL_MAP_B_TO_B_SIZE = 0x0CB8;
const GL_PIXEL_MAP_G_TO_G = 0x0C77;
const GL_PIXEL_MAP_G_TO_G_SIZE = 0x0CB7;
const GL_PIXEL_MAP_I_TO_A = 0x0C75;
const GL_PIXEL_MAP_I_TO_A_SIZE = 0x0CB5;
const GL_PIXEL_MAP_I_TO_B = 0x0C74;
const GL_PIXEL_MAP_I_TO_B_SIZE = 0x0CB4;
const GL_PIXEL_MAP_I_TO_G = 0x0C73;
const GL_PIXEL_MAP_I_TO_G_SIZE = 0x0CB3;
const GL_PIXEL_MAP_I_TO_I = 0x0C70;
const GL_PIXEL_MAP_I_TO_I_SIZE = 0x0CB0;
const GL_PIXEL_MAP_I_TO_R = 0x0C72;
const GL_PIXEL_MAP_I_TO_R_SIZE = 0x0CB2;
const GL_PIXEL_MAP_R_TO_R = 0x0C76;
const GL_PIXEL_MAP_R_TO_R_SIZE = 0x0CB6;
const GL_PIXEL_MAP_S_TO_S = 0x0C71;
const GL_PIXEL_MAP_S_TO_S_SIZE = 0x0CB1;
const GL_PIXEL_MODE_BIT = 0x00000020;
const GL_PIXEL_PACK_BUFFER = 0x88EB;
const GL_PIXEL_PACK_BUFFER_BINDING = 0x88ED;
const GL_PIXEL_UNPACK_BUFFER = 0x88EC;
const GL_PIXEL_UNPACK_BUFFER_BINDING = 0x88EF;
const GL_POINT = 0x1B00;
const GL_POINTS = 0x0000;
const GL_POINT_BIT = 0x00000002;
const GL_POINT_DISTANCE_ATTENUATION = 0x8129;
const GL_POINT_FADE_THRESHOLD_SIZE = 0x8128;
const GL_POINT_SIZE = 0x0B11;
const GL_POINT_SIZE_GRANULARITY = 0x0B13;
const GL_POINT_SIZE_MAX = 0x8127;
const GL_POINT_SIZE_MIN = 0x8126;
const GL_POINT_SIZE_RANGE = 0x0B12;
const GL_POINT_SMOOTH = 0x0B10;
const GL_POINT_SMOOTH_HINT = 0x0C51;
const GL_POINT_SPRITE = 0x8861;
const GL_POINT_SPRITE_COORD_ORIGIN = 0x8CA0;
const GL_POINT_TOKEN = 0x0701;
const GL_POLYGON = 0x0009;
const GL_POLYGON_BIT = 0x00000008;
const GL_POLYGON_MODE = 0x0B40;
const GL_POLYGON_OFFSET_FACTOR = 0x8038;
const GL_POLYGON_OFFSET_FILL = 0x8037;
const GL_POLYGON_OFFSET_LINE = 0x2A02;
const GL_POLYGON_OFFSET_POINT = 0x2A01;
const GL_POLYGON_OFFSET_UNITS = 0x2A00;
const GL_POLYGON_SMOOTH = 0x0B41;
const GL_POLYGON_SMOOTH_HINT = 0x0C53;
const GL_POLYGON_STIPPLE = 0x0B42;
const GL_POLYGON_STIPPLE_BIT = 0x00000010;
const GL_POLYGON_TOKEN = 0x0703;
const GL_POSITION = 0x1203;
const GL_PREVIOUS = 0x8578;
const GL_PRIMARY_COLOR = 0x8577;
const GL_PRIMITIVES_GENERATED = 0x8C87;
const GL_PRIMITIVE_RESTART = 0x8F9D;
const GL_PRIMITIVE_RESTART_FIXED_INDEX = 0x8D69;
const GL_PRIMITIVE_RESTART_INDEX = 0x8F9E;
const GL_PROGRAM = 0x82E2;
const GL_PROGRAM_BINARY_FORMATS = 0x87FF;
const GL_PROGRAM_BINARY_LENGTH = 0x8741;
const GL_PROGRAM_BINARY_RETRIEVABLE_HINT = 0x8257;
const GL_PROGRAM_INPUT = 0x92E3;
const GL_PROGRAM_OUTPUT = 0x92E4;
const GL_PROGRAM_PIPELINE = 0x82E4;
const GL_PROGRAM_PIPELINE_BINDING = 0x825A;
const GL_PROGRAM_POINT_SIZE = 0x8642;
const GL_PROGRAM_SEPARABLE = 0x8258;
const GL_PROJECTION = 0x1701;
const GL_PROJECTION_MATRIX = 0x0BA7;
const GL_PROJECTION_STACK_DEPTH = 0x0BA4;
const GL_PROVOKING_VERTEX = 0x8E4F;
const GL_PROXY_TEXTURE_1D = 0x8063;
const GL_PROXY_TEXTURE_1D_ARRAY = 0x8C19;
const GL_PROXY_TEXTURE_2D = 0x8064;
const GL_PROXY_TEXTURE_2D_ARRAY = 0x8C1B;
const GL_PROXY_TEXTURE_2D_MULTISAMPLE = 0x9101;
const GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY = 0x9103;
const GL_PROXY_TEXTURE_3D = 0x8070;
const GL_PROXY_TEXTURE_CUBE_MAP = 0x851B;
const GL_PROXY_TEXTURE_CUBE_MAP_ARRAY = 0x900B;
const GL_PROXY_TEXTURE_RECTANGLE = 0x84F7;
const GL_Q = 0x2003;
const GL_QUADRATIC_ATTENUATION = 0x1209;
const GL_QUADS = 0x0007;
const GL_QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION = 0x8E4C;
const GL_QUAD_STRIP = 0x0008;
const GL_QUERY = 0x82E3;
const GL_QUERY_BY_REGION_NO_WAIT = 0x8E16;
const GL_QUERY_BY_REGION_WAIT = 0x8E15;
const GL_QUERY_COUNTER_BITS = 0x8864;
const GL_QUERY_NO_WAIT = 0x8E14;
const GL_QUERY_RESULT = 0x8866;
const GL_QUERY_RESULT_AVAILABLE = 0x8867;
const GL_QUERY_WAIT = 0x8E13;
const GL_R = 0x2002;
const GL_R11F_G11F_B10F = 0x8C3A;
const GL_R16 = 0x822A;
const GL_R16F = 0x822D;
const GL_R16I = 0x8233;
const GL_R16UI = 0x8234;
const GL_R16_SNORM = 0x8F98;
const GL_R32F = 0x822E;
const GL_R32I = 0x8235;
const GL_R32UI = 0x8236;
const GL_R3_G3_B2 = 0x2A10;
const GL_R8 = 0x8229;
const GL_R8I = 0x8231;
const GL_R8UI = 0x8232;
const GL_R8_SNORM = 0x8F94;
const GL_RASTERIZER_DISCARD = 0x8C89;
const GL_READ_BUFFER = 0x0C02;
const GL_READ_FRAMEBUFFER = 0x8CA8;
const GL_READ_FRAMEBUFFER_BINDING = 0x8CAA;
const GL_READ_ONLY = 0x88B8;
const GL_READ_PIXELS = 0x828C;
const GL_READ_PIXELS_FORMAT = 0x828D;
const GL_READ_PIXELS_TYPE = 0x828E;
const GL_READ_WRITE = 0x88BA;
const GL_RED = 0x1903;
const GL_RED_BIAS = 0x0D15;
const GL_RED_BITS = 0x0D52;
const GL_RED_INTEGER = 0x8D94;
const GL_RED_SCALE = 0x0D14;
const GL_REFERENCED_BY_COMPUTE_SHADER = 0x930B;
const GL_REFERENCED_BY_FRAGMENT_SHADER = 0x930A;
const GL_REFERENCED_BY_GEOMETRY_SHADER = 0x9309;
const GL_REFERENCED_BY_TESS_CONTROL_SHADER = 0x9307;
const GL_REFERENCED_BY_TESS_EVALUATION_SHADER = 0x9308;
const GL_REFERENCED_BY_VERTEX_SHADER = 0x9306;
const GL_REFLECTION_MAP = 0x8512;
const GL_RENDER = 0x1C00;
const GL_RENDERBUFFER = 0x8D41;
const GL_RENDERBUFFER_ALPHA_SIZE = 0x8D53;
const GL_RENDERBUFFER_BINDING = 0x8CA7;
const GL_RENDERBUFFER_BLUE_SIZE = 0x8D52;
const GL_RENDERBUFFER_DEPTH_SIZE = 0x8D54;
const GL_RENDERBUFFER_GREEN_SIZE = 0x8D51;
const GL_RENDERBUFFER_HEIGHT = 0x8D43;
const GL_RENDERBUFFER_INTERNAL_FORMAT = 0x8D44;
const GL_RENDERBUFFER_RED_SIZE = 0x8D50;
const GL_RENDERBUFFER_SAMPLES = 0x8CAB;
const GL_RENDERBUFFER_STENCIL_SIZE = 0x8D55;
const GL_RENDERBUFFER_WIDTH = 0x8D42;
const GL_RENDERER = 0x1F01;
const GL_RENDER_MODE = 0x0C40;
const GL_REPEAT = 0x2901;
const GL_REPLACE = 0x1E01;
const GL_RESCALE_NORMAL = 0x803A;
const GL_RETURN = 0x0102;
const GL_RG = 0x8227;
const GL_RG16 = 0x822C;
const GL_RG16F = 0x822F;
const GL_RG16I = 0x8239;
const GL_RG16UI = 0x823A;
const GL_RG16_SNORM = 0x8F99;
const GL_RG32F = 0x8230;
const GL_RG32I = 0x823B;
const GL_RG32UI = 0x823C;
const GL_RG8 = 0x822B;
const GL_RG8I = 0x8237;
const GL_RG8UI = 0x8238;
const GL_RG8_SNORM = 0x8F95;
const GL_RGB = 0x1907;
const GL_RGB10 = 0x8052;
const GL_RGB10_A2 = 0x8059;
const GL_RGB10_A2UI = 0x906F;
const GL_RGB12 = 0x8053;
const GL_RGB16 = 0x8054;
const GL_RGB16F = 0x881B;
const GL_RGB16I = 0x8D89;
const GL_RGB16UI = 0x8D77;
const GL_RGB16_SNORM = 0x8F9A;
const GL_RGB32F = 0x8815;
const GL_RGB32I = 0x8D83;
const GL_RGB32UI = 0x8D71;
const GL_RGB4 = 0x804F;
const GL_RGB5 = 0x8050;
const GL_RGB565 = 0x8D62;
const GL_RGB5_A1 = 0x8057;
const GL_RGB8 = 0x8051;
const GL_RGB8I = 0x8D8F;
const GL_RGB8UI = 0x8D7D;
const GL_RGB8_SNORM = 0x8F96;
const GL_RGB9_E5 = 0x8C3D;
const GL_RGBA = 0x1908;
const GL_RGBA12 = 0x805A;
const GL_RGBA16 = 0x805B;
const GL_RGBA16F = 0x881A;
const GL_RGBA16I = 0x8D88;
const GL_RGBA16UI = 0x8D76;
const GL_RGBA16_SNORM = 0x8F9B;
const GL_RGBA2 = 0x8055;
const GL_RGBA32F = 0x8814;
const GL_RGBA32I = 0x8D82;
const GL_RGBA32UI = 0x8D70;
const GL_RGBA4 = 0x8056;
const GL_RGBA8 = 0x8058;
const GL_RGBA8I = 0x8D8E;
const GL_RGBA8UI = 0x8D7C;
const GL_RGBA8_SNORM = 0x8F97;
const GL_RGBA_INTEGER = 0x8D99;
const GL_RGBA_MODE = 0x0C31;
const GL_RGB_INTEGER = 0x8D98;
const GL_RGB_SCALE = 0x8573;
const GL_RG_INTEGER = 0x8228;
const GL_RIGHT = 0x0407;
const GL_S = 0x2000;
const GL_SAMPLER = 0x82E6;
const GL_SAMPLER_1D = 0x8B5D;
const GL_SAMPLER_1D_ARRAY = 0x8DC0;
const GL_SAMPLER_1D_ARRAY_SHADOW = 0x8DC3;
const GL_SAMPLER_1D_SHADOW = 0x8B61;
const GL_SAMPLER_2D = 0x8B5E;
const GL_SAMPLER_2D_ARRAY = 0x8DC1;
const GL_SAMPLER_2D_ARRAY_SHADOW = 0x8DC4;
const GL_SAMPLER_2D_MULTISAMPLE = 0x9108;
const GL_SAMPLER_2D_MULTISAMPLE_ARRAY = 0x910B;
const GL_SAMPLER_2D_RECT = 0x8B63;
const GL_SAMPLER_2D_RECT_SHADOW = 0x8B64;
const GL_SAMPLER_2D_SHADOW = 0x8B62;
const GL_SAMPLER_3D = 0x8B5F;
const GL_SAMPLER_BINDING = 0x8919;
const GL_SAMPLER_BUFFER = 0x8DC2;
const GL_SAMPLER_CUBE = 0x8B60;
const GL_SAMPLER_CUBE_MAP_ARRAY = 0x900C;
const GL_SAMPLER_CUBE_MAP_ARRAY_SHADOW = 0x900D;
const GL_SAMPLER_CUBE_SHADOW = 0x8DC5;
const GL_SAMPLES = 0x80A9;
const GL_SAMPLES_PASSED = 0x8914;
const GL_SAMPLE_ALPHA_TO_COVERAGE = 0x809E;
const GL_SAMPLE_ALPHA_TO_ONE = 0x809F;
const GL_SAMPLE_BUFFERS = 0x80A8;
const GL_SAMPLE_COVERAGE = 0x80A0;
const GL_SAMPLE_COVERAGE_INVERT = 0x80AB;
const GL_SAMPLE_COVERAGE_VALUE = 0x80AA;
const GL_SAMPLE_MASK = 0x8E51;
const GL_SAMPLE_MASK_VALUE = 0x8E52;
const GL_SAMPLE_POSITION = 0x8E50;
const GL_SAMPLE_SHADING = 0x8C36;
const GL_SCISSOR_BIT = 0x00080000;
const GL_SCISSOR_BOX = 0x0C10;
const GL_SCISSOR_TEST = 0x0C11;
const GL_SECONDARY_COLOR_ARRAY = 0x845E;
const GL_SECONDARY_COLOR_ARRAY_BUFFER_BINDING = 0x889C;
const GL_SECONDARY_COLOR_ARRAY_POINTER = 0x845D;
const GL_SECONDARY_COLOR_ARRAY_SIZE = 0x845A;
const GL_SECONDARY_COLOR_ARRAY_STRIDE = 0x845C;
const GL_SECONDARY_COLOR_ARRAY_TYPE = 0x845B;
const GL_SELECT = 0x1C02;
const GL_SELECTION_BUFFER_POINTER = 0x0DF3;
const GL_SELECTION_BUFFER_SIZE = 0x0DF4;
const GL_SEPARATE_ATTRIBS = 0x8C8D;
const GL_SEPARATE_SPECULAR_COLOR = 0x81FA;
const GL_SET = 0x150F;
const GL_SHADER = 0x82E1;
const GL_SHADER_BINARY_FORMATS = 0x8DF8;
const GL_SHADER_COMPILER = 0x8DFA;
const GL_SHADER_IMAGE_ACCESS_BARRIER_BIT = 0x00000020;
const GL_SHADER_IMAGE_ATOMIC = 0x82A6;
const GL_SHADER_IMAGE_LOAD = 0x82A4;
const GL_SHADER_IMAGE_STORE = 0x82A5;
const GL_SHADER_SOURCE_LENGTH = 0x8B88;
const GL_SHADER_STORAGE_BARRIER_BIT = 0x00002000;
const GL_SHADER_STORAGE_BLOCK = 0x92E6;
const GL_SHADER_STORAGE_BUFFER = 0x90D2;
const GL_SHADER_STORAGE_BUFFER_BINDING = 0x90D3;
const GL_SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT = 0x90DF;
const GL_SHADER_STORAGE_BUFFER_SIZE = 0x90D5;
const GL_SHADER_STORAGE_BUFFER_START = 0x90D4;
const GL_SHADER_TYPE = 0x8B4F;
const GL_SHADE_MODEL = 0x0B54;
const GL_SHADING_LANGUAGE_VERSION = 0x8B8C;
const GL_SHININESS = 0x1601;
const GL_SHORT = 0x1402;
const GL_SIGNALED = 0x9119;
const GL_SIGNED_NORMALIZED = 0x8F9C;
const GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_TEST = 0x82AC;
const GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_WRITE = 0x82AE;
const GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_TEST = 0x82AD;
const GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_WRITE = 0x82AF;
const GL_SINGLE_COLOR = 0x81F9;
const GL_SLUMINANCE = 0x8C46;
const GL_SLUMINANCE8 = 0x8C47;
const GL_SLUMINANCE8_ALPHA8 = 0x8C45;
const GL_SLUMINANCE_ALPHA = 0x8C44;
const GL_SMOOTH = 0x1D01;
const GL_SMOOTH_LINE_WIDTH_GRANULARITY = 0x0B23;
const GL_SMOOTH_LINE_WIDTH_RANGE = 0x0B22;
const GL_SMOOTH_POINT_SIZE_GRANULARITY = 0x0B13;
const GL_SMOOTH_POINT_SIZE_RANGE = 0x0B12;
const GL_SOURCE0_ALPHA = 0x8588;
const GL_SOURCE0_RGB = 0x8580;
const GL_SOURCE1_ALPHA = 0x8589;
const GL_SOURCE1_RGB = 0x8581;
const GL_SOURCE2_ALPHA = 0x858A;
const GL_SOURCE2_RGB = 0x8582;
const GL_SPECULAR = 0x1202;
const GL_SPHERE_MAP = 0x2402;
const GL_SPOT_CUTOFF = 0x1206;
const GL_SPOT_DIRECTION = 0x1204;
const GL_SPOT_EXPONENT = 0x1205;
const GL_SRC0_ALPHA = 0x8588;
const GL_SRC0_RGB = 0x8580;
const GL_SRC1_ALPHA = 0x8589;
const GL_SRC1_COLOR = 0x88F9;
const GL_SRC1_RGB = 0x8581;
const GL_SRC2_ALPHA = 0x858A;
const GL_SRC2_RGB = 0x8582;
const GL_SRC_ALPHA = 0x0302;
const GL_SRC_ALPHA_SATURATE = 0x0308;
const GL_SRC_COLOR = 0x0300;
const GL_SRGB = 0x8C40;
const GL_SRGB8 = 0x8C41;
const GL_SRGB8_ALPHA8 = 0x8C43;
const GL_SRGB_ALPHA = 0x8C42;
const GL_SRGB_READ = 0x8297;
const GL_SRGB_WRITE = 0x8298;
const GL_STACK_OVERFLOW = 0x0503;
const GL_STACK_UNDERFLOW = 0x0504;
const GL_STATIC_COPY = 0x88E6;
const GL_STATIC_DRAW = 0x88E4;
const GL_STATIC_READ = 0x88E5;
const GL_STENCIL = 0x1802;
const GL_STENCIL_ATTACHMENT = 0x8D20;
const GL_STENCIL_BACK_FAIL = 0x8801;
const GL_STENCIL_BACK_FUNC = 0x8800;
const GL_STENCIL_BACK_PASS_DEPTH_FAIL = 0x8802;
const GL_STENCIL_BACK_PASS_DEPTH_PASS = 0x8803;
const GL_STENCIL_BACK_REF = 0x8CA3;
const GL_STENCIL_BACK_VALUE_MASK = 0x8CA4;
const GL_STENCIL_BACK_WRITEMASK = 0x8CA5;
const GL_STENCIL_BITS = 0x0D57;
const GL_STENCIL_BUFFER_BIT = 0x00000400;
const GL_STENCIL_CLEAR_VALUE = 0x0B91;
const GL_STENCIL_COMPONENTS = 0x8285;
const GL_STENCIL_FAIL = 0x0B94;
const GL_STENCIL_FUNC = 0x0B92;
const GL_STENCIL_INDEX = 0x1901;
const GL_STENCIL_INDEX1 = 0x8D46;
const GL_STENCIL_INDEX16 = 0x8D49;
const GL_STENCIL_INDEX4 = 0x8D47;
const GL_STENCIL_INDEX8 = 0x8D48;
const GL_STENCIL_PASS_DEPTH_FAIL = 0x0B95;
const GL_STENCIL_PASS_DEPTH_PASS = 0x0B96;
const GL_STENCIL_REF = 0x0B97;
const GL_STENCIL_RENDERABLE = 0x8288;
const GL_STENCIL_TEST = 0x0B90;
const GL_STENCIL_VALUE_MASK = 0x0B93;
const GL_STENCIL_WRITEMASK = 0x0B98;
const GL_STEREO = 0x0C33;
const GL_STREAM_COPY = 0x88E2;
const GL_STREAM_DRAW = 0x88E0;
const GL_STREAM_READ = 0x88E1;
const GL_SUBPIXEL_BITS = 0x0D50;
const GL_SUBTRACT = 0x84E7;
const GL_SYNC_CONDITION = 0x9113;
const GL_SYNC_FENCE = 0x9116;
const GL_SYNC_FLAGS = 0x9115;
const GL_SYNC_FLUSH_COMMANDS_BIT = 0x00000001;
const GL_SYNC_GPU_COMMANDS_COMPLETE = 0x9117;
const GL_SYNC_STATUS = 0x9114;
const GL_T = 0x2001;
const GL_T2F_C3F_V3F = 0x2A2A;
const GL_T2F_C4F_N3F_V3F = 0x2A2C;
const GL_T2F_C4UB_V3F = 0x2A29;
const GL_T2F_N3F_V3F = 0x2A2B;
const GL_T2F_V3F = 0x2A27;
const GL_T4F_C4F_N3F_V4F = 0x2A2D;
const GL_T4F_V4F = 0x2A28;
const GL_TESS_CONTROL_OUTPUT_VERTICES = 0x8E75;
const GL_TESS_CONTROL_SHADER = 0x8E88;
const GL_TESS_CONTROL_SHADER_BIT = 0x00000008;
const GL_TESS_CONTROL_SUBROUTINE = 0x92E9;
const GL_TESS_CONTROL_SUBROUTINE_UNIFORM = 0x92EF;
const GL_TESS_CONTROL_TEXTURE = 0x829C;
const GL_TESS_EVALUATION_SHADER = 0x8E87;
const GL_TESS_EVALUATION_SHADER_BIT = 0x00000010;
const GL_TESS_EVALUATION_SUBROUTINE = 0x92EA;
const GL_TESS_EVALUATION_SUBROUTINE_UNIFORM = 0x92F0;
const GL_TESS_EVALUATION_TEXTURE = 0x829D;
const GL_TESS_GEN_MODE = 0x8E76;
const GL_TESS_GEN_POINT_MODE = 0x8E79;
const GL_TESS_GEN_SPACING = 0x8E77;
const GL_TESS_GEN_VERTEX_ORDER = 0x8E78;
const GL_TEXTURE = 0x1702;
const GL_TEXTURE0 = 0x84C0;
const GL_TEXTURE1 = 0x84C1;
const GL_TEXTURE10 = 0x84CA;
const GL_TEXTURE11 = 0x84CB;
const GL_TEXTURE12 = 0x84CC;
const GL_TEXTURE13 = 0x84CD;
const GL_TEXTURE14 = 0x84CE;
const GL_TEXTURE15 = 0x84CF;
const GL_TEXTURE16 = 0x84D0;
const GL_TEXTURE17 = 0x84D1;
const GL_TEXTURE18 = 0x84D2;
const GL_TEXTURE19 = 0x84D3;
const GL_TEXTURE2 = 0x84C2;
const GL_TEXTURE20 = 0x84D4;
const GL_TEXTURE21 = 0x84D5;
const GL_TEXTURE22 = 0x84D6;
const GL_TEXTURE23 = 0x84D7;
const GL_TEXTURE24 = 0x84D8;
const GL_TEXTURE25 = 0x84D9;
const GL_TEXTURE26 = 0x84DA;
const GL_TEXTURE27 = 0x84DB;
const GL_TEXTURE28 = 0x84DC;
const GL_TEXTURE29 = 0x84DD;
const GL_TEXTURE3 = 0x84C3;
const GL_TEXTURE30 = 0x84DE;
const GL_TEXTURE31 = 0x84DF;
const GL_TEXTURE4 = 0x84C4;
const GL_TEXTURE5 = 0x84C5;
const GL_TEXTURE6 = 0x84C6;
const GL_TEXTURE7 = 0x84C7;
const GL_TEXTURE8 = 0x84C8;
const GL_TEXTURE9 = 0x84C9;
const GL_TEXTURE_1D = 0x0DE0;
const GL_TEXTURE_1D_ARRAY = 0x8C18;
const GL_TEXTURE_2D = 0x0DE1;
const GL_TEXTURE_2D_ARRAY = 0x8C1A;
const GL_TEXTURE_2D_MULTISAMPLE = 0x9100;
const GL_TEXTURE_2D_MULTISAMPLE_ARRAY = 0x9102;
const GL_TEXTURE_3D = 0x806F;
const GL_TEXTURE_ALPHA_SIZE = 0x805F;
const GL_TEXTURE_ALPHA_TYPE = 0x8C13;
const GL_TEXTURE_BASE_LEVEL = 0x813C;
const GL_TEXTURE_BINDING_1D = 0x8068;
const GL_TEXTURE_BINDING_1D_ARRAY = 0x8C1C;
const GL_TEXTURE_BINDING_2D = 0x8069;
const GL_TEXTURE_BINDING_2D_ARRAY = 0x8C1D;
const GL_TEXTURE_BINDING_2D_MULTISAMPLE = 0x9104;
const GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY = 0x9105;
const GL_TEXTURE_BINDING_3D = 0x806A;
const GL_TEXTURE_BINDING_BUFFER = 0x8C2C;
const GL_TEXTURE_BINDING_CUBE_MAP = 0x8514;
const GL_TEXTURE_BINDING_CUBE_MAP_ARRAY = 0x900A;
const GL_TEXTURE_BINDING_RECTANGLE = 0x84F6;
const GL_TEXTURE_BIT = 0x00040000;
const GL_TEXTURE_BLUE_SIZE = 0x805E;
const GL_TEXTURE_BLUE_TYPE = 0x8C12;
const GL_TEXTURE_BORDER = 0x1005;
const GL_TEXTURE_BORDER_COLOR = 0x1004;
const GL_TEXTURE_BUFFER = 0x8C2A;
const GL_TEXTURE_BUFFER_DATA_STORE_BINDING = 0x8C2D;
const GL_TEXTURE_BUFFER_OFFSET = 0x919D;
const GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT = 0x919F;
const GL_TEXTURE_BUFFER_SIZE = 0x919E;
const GL_TEXTURE_COMPARE_FUNC = 0x884D;
const GL_TEXTURE_COMPARE_MODE = 0x884C;
const GL_TEXTURE_COMPONENTS = 0x1003;
const GL_TEXTURE_COMPRESSED = 0x86A1;
const GL_TEXTURE_COMPRESSED_BLOCK_HEIGHT = 0x82B2;
const GL_TEXTURE_COMPRESSED_BLOCK_SIZE = 0x82B3;
const GL_TEXTURE_COMPRESSED_BLOCK_WIDTH = 0x82B1;
const GL_TEXTURE_COMPRESSED_IMAGE_SIZE = 0x86A0;
const GL_TEXTURE_COMPRESSION_HINT = 0x84EF;
const GL_TEXTURE_COORD_ARRAY = 0x8078;
const GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING = 0x889A;
const GL_TEXTURE_COORD_ARRAY_POINTER = 0x8092;
const GL_TEXTURE_COORD_ARRAY_SIZE = 0x8088;
const GL_TEXTURE_COORD_ARRAY_STRIDE = 0x808A;
const GL_TEXTURE_COORD_ARRAY_TYPE = 0x8089;
const GL_TEXTURE_CUBE_MAP = 0x8513;
const GL_TEXTURE_CUBE_MAP_ARRAY = 0x9009;
const GL_TEXTURE_CUBE_MAP_NEGATIVE_X = 0x8516;
const GL_TEXTURE_CUBE_MAP_NEGATIVE_Y = 0x8518;
const GL_TEXTURE_CUBE_MAP_NEGATIVE_Z = 0x851A;
const GL_TEXTURE_CUBE_MAP_POSITIVE_X = 0x8515;
const GL_TEXTURE_CUBE_MAP_POSITIVE_Y = 0x8517;
const GL_TEXTURE_CUBE_MAP_POSITIVE_Z = 0x8519;
const GL_TEXTURE_CUBE_MAP_SEAMLESS = 0x884F;
const GL_TEXTURE_DEPTH = 0x8071;
const GL_TEXTURE_DEPTH_SIZE = 0x884A;
const GL_TEXTURE_DEPTH_TYPE = 0x8C16;
const GL_TEXTURE_ENV = 0x2300;
const GL_TEXTURE_ENV_COLOR = 0x2201;
const GL_TEXTURE_ENV_MODE = 0x2200;
const GL_TEXTURE_FETCH_BARRIER_BIT = 0x00000008;
const GL_TEXTURE_FILTER_CONTROL = 0x8500;
const GL_TEXTURE_FIXED_SAMPLE_LOCATIONS = 0x9107;
const GL_TEXTURE_GATHER = 0x82A2;
const GL_TEXTURE_GATHER_SHADOW = 0x82A3;
const GL_TEXTURE_GEN_MODE = 0x2500;
const GL_TEXTURE_GEN_Q = 0x0C63;
const GL_TEXTURE_GEN_R = 0x0C62;
const GL_TEXTURE_GEN_S = 0x0C60;
const GL_TEXTURE_GEN_T = 0x0C61;
const GL_TEXTURE_GREEN_SIZE = 0x805D;
const GL_TEXTURE_GREEN_TYPE = 0x8C11;
const GL_TEXTURE_HEIGHT = 0x1001;
const GL_TEXTURE_IMAGE_FORMAT = 0x828F;
const GL_TEXTURE_IMAGE_TYPE = 0x8290;
const GL_TEXTURE_IMMUTABLE_FORMAT = 0x912F;
const GL_TEXTURE_IMMUTABLE_LEVELS = 0x82DF;
const GL_TEXTURE_INTENSITY_SIZE = 0x8061;
const GL_TEXTURE_INTENSITY_TYPE = 0x8C15;
const GL_TEXTURE_INTERNAL_FORMAT = 0x1003;
const GL_TEXTURE_LOD_BIAS = 0x8501;
const GL_TEXTURE_LUMINANCE_SIZE = 0x8060;
const GL_TEXTURE_LUMINANCE_TYPE = 0x8C14;
const GL_TEXTURE_MAG_FILTER = 0x2800;
const GL_TEXTURE_MATRIX = 0x0BA8;
const GL_TEXTURE_MAX_LEVEL = 0x813D;
const GL_TEXTURE_MAX_LOD = 0x813B;
const GL_TEXTURE_MIN_FILTER = 0x2801;
const GL_TEXTURE_MIN_LOD = 0x813A;
const GL_TEXTURE_PRIORITY = 0x8066;
const GL_TEXTURE_RECTANGLE = 0x84F5;
const GL_TEXTURE_RED_SIZE = 0x805C;
const GL_TEXTURE_RED_TYPE = 0x8C10;
const GL_TEXTURE_RESIDENT = 0x8067;
const GL_TEXTURE_SAMPLES = 0x9106;
const GL_TEXTURE_SHADOW = 0x82A1;
const GL_TEXTURE_SHARED_SIZE = 0x8C3F;
const GL_TEXTURE_STACK_DEPTH = 0x0BA5;
const GL_TEXTURE_STENCIL_SIZE = 0x88F1;
const GL_TEXTURE_SWIZZLE_A = 0x8E45;
const GL_TEXTURE_SWIZZLE_B = 0x8E44;
const GL_TEXTURE_SWIZZLE_G = 0x8E43;
const GL_TEXTURE_SWIZZLE_R = 0x8E42;
const GL_TEXTURE_SWIZZLE_RGBA = 0x8E46;
const GL_TEXTURE_UPDATE_BARRIER_BIT = 0x00000100;
const GL_TEXTURE_VIEW = 0x82B5;
const GL_TEXTURE_VIEW_MIN_LAYER = 0x82DD;
const GL_TEXTURE_VIEW_MIN_LEVEL = 0x82DB;
const GL_TEXTURE_VIEW_NUM_LAYERS = 0x82DE;
const GL_TEXTURE_VIEW_NUM_LEVELS = 0x82DC;
const GL_TEXTURE_WIDTH = 0x1000;
const GL_TEXTURE_WRAP_R = 0x8072;
const GL_TEXTURE_WRAP_S = 0x2802;
const GL_TEXTURE_WRAP_T = 0x2803;
const GL_TIMEOUT_EXPIRED = 0x911B;
const GL_TIMEOUT_IGNORED = 0xFFFFFFFFFFFFFFFF;
const GL_TIMESTAMP = 0x8E28;
const GL_TIME_ELAPSED = 0x88BF;
const GL_TOP_LEVEL_ARRAY_SIZE = 0x930C;
const GL_TOP_LEVEL_ARRAY_STRIDE = 0x930D;
const GL_TRANSFORM_BIT = 0x00001000;
const GL_TRANSFORM_FEEDBACK = 0x8E22;
const GL_TRANSFORM_FEEDBACK_ACTIVE = 0x8E24;
const GL_TRANSFORM_FEEDBACK_BARRIER_BIT = 0x00000800;
const GL_TRANSFORM_FEEDBACK_BINDING = 0x8E25;
const GL_TRANSFORM_FEEDBACK_BUFFER = 0x8C8E;
const GL_TRANSFORM_FEEDBACK_BUFFER_ACTIVE = 0x8E24;
const GL_TRANSFORM_FEEDBACK_BUFFER_BINDING = 0x8C8F;
const GL_TRANSFORM_FEEDBACK_BUFFER_MODE = 0x8C7F;
const GL_TRANSFORM_FEEDBACK_BUFFER_PAUSED = 0x8E23;
const GL_TRANSFORM_FEEDBACK_BUFFER_SIZE = 0x8C85;
const GL_TRANSFORM_FEEDBACK_BUFFER_START = 0x8C84;
const GL_TRANSFORM_FEEDBACK_PAUSED = 0x8E23;
const GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN = 0x8C88;
const GL_TRANSFORM_FEEDBACK_VARYING = 0x92F4;
const GL_TRANSFORM_FEEDBACK_VARYINGS = 0x8C83;
const GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH = 0x8C76;
const GL_TRANSPOSE_COLOR_MATRIX = 0x84E6;
const GL_TRANSPOSE_MODELVIEW_MATRIX = 0x84E3;
const GL_TRANSPOSE_PROJECTION_MATRIX = 0x84E4;
const GL_TRANSPOSE_TEXTURE_MATRIX = 0x84E5;
const GL_TRIANGLES = 0x0004;
const GL_TRIANGLES_ADJACENCY = 0x000C;
const GL_TRIANGLE_FAN = 0x0006;
const GL_TRIANGLE_STRIP = 0x0005;
const GL_TRIANGLE_STRIP_ADJACENCY = 0x000D;
const GL_TRUE = 1;
const GL_TYPE = 0x92FA;
const GL_UNDEFINED_VERTEX = 0x8260;
const GL_UNIFORM = 0x92E1;
const GL_UNIFORM_ARRAY_STRIDE = 0x8A3C;
const GL_UNIFORM_ATOMIC_COUNTER_BUFFER_INDEX = 0x92DA;
const GL_UNIFORM_BARRIER_BIT = 0x00000004;
const GL_UNIFORM_BLOCK = 0x92E2;
const GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS = 0x8A42;
const GL_UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES = 0x8A43;
const GL_UNIFORM_BLOCK_BINDING = 0x8A3F;
const GL_UNIFORM_BLOCK_DATA_SIZE = 0x8A40;
const GL_UNIFORM_BLOCK_INDEX = 0x8A3A;
const GL_UNIFORM_BLOCK_NAME_LENGTH = 0x8A41;
const GL_UNIFORM_BLOCK_REFERENCED_BY_COMPUTE_SHADER = 0x90EC;
const GL_UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER = 0x8A46;
const GL_UNIFORM_BLOCK_REFERENCED_BY_GEOMETRY_SHADER = 0x8A45;
const GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_CONTROL_SHADER = 0x84F0;
const GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_EVALUATION_SHADER = 0x84F1;
const GL_UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER = 0x8A44;
const GL_UNIFORM_BUFFER = 0x8A11;
const GL_UNIFORM_BUFFER_BINDING = 0x8A28;
const GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT = 0x8A34;
const GL_UNIFORM_BUFFER_SIZE = 0x8A2A;
const GL_UNIFORM_BUFFER_START = 0x8A29;
const GL_UNIFORM_IS_ROW_MAJOR = 0x8A3E;
const GL_UNIFORM_MATRIX_STRIDE = 0x8A3D;
const GL_UNIFORM_NAME_LENGTH = 0x8A39;
const GL_UNIFORM_OFFSET = 0x8A3B;
const GL_UNIFORM_SIZE = 0x8A38;
const GL_UNIFORM_TYPE = 0x8A37;
const GL_UNPACK_ALIGNMENT = 0x0CF5;
const GL_UNPACK_COMPRESSED_BLOCK_DEPTH = 0x9129;
const GL_UNPACK_COMPRESSED_BLOCK_HEIGHT = 0x9128;
const GL_UNPACK_COMPRESSED_BLOCK_SIZE = 0x912A;
const GL_UNPACK_COMPRESSED_BLOCK_WIDTH = 0x9127;
const GL_UNPACK_IMAGE_HEIGHT = 0x806E;
const GL_UNPACK_LSB_FIRST = 0x0CF1;
const GL_UNPACK_ROW_LENGTH = 0x0CF2;
const GL_UNPACK_SKIP_IMAGES = 0x806D;
const GL_UNPACK_SKIP_PIXELS = 0x0CF4;
const GL_UNPACK_SKIP_ROWS = 0x0CF3;
const GL_UNPACK_SWAP_BYTES = 0x0CF0;
const GL_UNSIGNALED = 0x9118;
const GL_UNSIGNED_BYTE = 0x1401;
const GL_UNSIGNED_BYTE_2_3_3_REV = 0x8362;
const GL_UNSIGNED_BYTE_3_3_2 = 0x8032;
const GL_UNSIGNED_INT = 0x1405;
const GL_UNSIGNED_INT_10F_11F_11F_REV = 0x8C3B;
const GL_UNSIGNED_INT_10_10_10_2 = 0x8036;
const GL_UNSIGNED_INT_24_8 = 0x84FA;
const GL_UNSIGNED_INT_2_10_10_10_REV = 0x8368;
const GL_UNSIGNED_INT_5_9_9_9_REV = 0x8C3E;
const GL_UNSIGNED_INT_8_8_8_8 = 0x8035;
const GL_UNSIGNED_INT_8_8_8_8_REV = 0x8367;
const GL_UNSIGNED_INT_ATOMIC_COUNTER = 0x92DB;
const GL_UNSIGNED_INT_IMAGE_1D = 0x9062;
const GL_UNSIGNED_INT_IMAGE_1D_ARRAY = 0x9068;
const GL_UNSIGNED_INT_IMAGE_2D = 0x9063;
const GL_UNSIGNED_INT_IMAGE_2D_ARRAY = 0x9069;
const GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE = 0x906B;
const GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY = 0x906C;
const GL_UNSIGNED_INT_IMAGE_2D_RECT = 0x9065;
const GL_UNSIGNED_INT_IMAGE_3D = 0x9064;
const GL_UNSIGNED_INT_IMAGE_BUFFER = 0x9067;
const GL_UNSIGNED_INT_IMAGE_CUBE = 0x9066;
const GL_UNSIGNED_INT_IMAGE_CUBE_MAP_ARRAY = 0x906A;
const GL_UNSIGNED_INT_SAMPLER_1D = 0x8DD1;
const GL_UNSIGNED_INT_SAMPLER_1D_ARRAY = 0x8DD6;
const GL_UNSIGNED_INT_SAMPLER_2D = 0x8DD2;
const GL_UNSIGNED_INT_SAMPLER_2D_ARRAY = 0x8DD7;
const GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE = 0x910A;
const GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY = 0x910D;
const GL_UNSIGNED_INT_SAMPLER_2D_RECT = 0x8DD5;
const GL_UNSIGNED_INT_SAMPLER_3D = 0x8DD3;
const GL_UNSIGNED_INT_SAMPLER_BUFFER = 0x8DD8;
const GL_UNSIGNED_INT_SAMPLER_CUBE = 0x8DD4;
const GL_UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY = 0x900F;
const GL_UNSIGNED_INT_VEC2 = 0x8DC6;
const GL_UNSIGNED_INT_VEC3 = 0x8DC7;
const GL_UNSIGNED_INT_VEC4 = 0x8DC8;
const GL_UNSIGNED_NORMALIZED = 0x8C17;
const GL_UNSIGNED_SHORT = 0x1403;
const GL_UNSIGNED_SHORT_1_5_5_5_REV = 0x8366;
const GL_UNSIGNED_SHORT_4_4_4_4 = 0x8033;
const GL_UNSIGNED_SHORT_4_4_4_4_REV = 0x8365;
const GL_UNSIGNED_SHORT_5_5_5_1 = 0x8034;
const GL_UNSIGNED_SHORT_5_6_5 = 0x8363;
const GL_UNSIGNED_SHORT_5_6_5_REV = 0x8364;
const GL_UPPER_LEFT = 0x8CA2;
const GL_V2F = 0x2A20;
const GL_V3F = 0x2A21;
const GL_VALIDATE_STATUS = 0x8B83;
const GL_VENDOR = 0x1F00;
const GL_VERSION = 0x1F02;
const GL_VERTEX_ARRAY = 0x8074;
const GL_VERTEX_ARRAY_BINDING = 0x85B5;
const GL_VERTEX_ARRAY_BUFFER_BINDING = 0x8896;
const GL_VERTEX_ARRAY_POINTER = 0x808E;
const GL_VERTEX_ARRAY_SIZE = 0x807A;
const GL_VERTEX_ARRAY_STRIDE = 0x807C;
const GL_VERTEX_ARRAY_TYPE = 0x807B;
const GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT = 0x00000001;
const GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = 0x889F;
const GL_VERTEX_ATTRIB_ARRAY_DIVISOR = 0x88FE;
const GL_VERTEX_ATTRIB_ARRAY_ENABLED = 0x8622;
const GL_VERTEX_ATTRIB_ARRAY_INTEGER = 0x88FD;
const GL_VERTEX_ATTRIB_ARRAY_LONG = 0x874E;
const GL_VERTEX_ATTRIB_ARRAY_NORMALIZED = 0x886A;
const GL_VERTEX_ATTRIB_ARRAY_POINTER = 0x8645;
const GL_VERTEX_ATTRIB_ARRAY_SIZE = 0x8623;
const GL_VERTEX_ATTRIB_ARRAY_STRIDE = 0x8624;
const GL_VERTEX_ATTRIB_ARRAY_TYPE = 0x8625;
const GL_VERTEX_ATTRIB_BINDING = 0x82D4;
const GL_VERTEX_ATTRIB_RELATIVE_OFFSET = 0x82D5;
const GL_VERTEX_BINDING_BUFFER = 0x8F4F;
const GL_VERTEX_BINDING_DIVISOR = 0x82D6;
const GL_VERTEX_BINDING_OFFSET = 0x82D7;
const GL_VERTEX_BINDING_STRIDE = 0x82D8;
const GL_VERTEX_PROGRAM_POINT_SIZE = 0x8642;
const GL_VERTEX_PROGRAM_TWO_SIDE = 0x8643;
const GL_VERTEX_SHADER = 0x8B31;
const GL_VERTEX_SHADER_BIT = 0x00000001;
const GL_VERTEX_SUBROUTINE = 0x92E8;
const GL_VERTEX_SUBROUTINE_UNIFORM = 0x92EE;
const GL_VERTEX_TEXTURE = 0x829B;
const GL_VIEWPORT = 0x0BA2;
const GL_VIEWPORT_BIT = 0x00000800;
const GL_VIEWPORT_BOUNDS_RANGE = 0x825D;
const GL_VIEWPORT_INDEX_PROVOKING_VERTEX = 0x825F;
const GL_VIEWPORT_SUBPIXEL_BITS = 0x825C;
const GL_VIEW_CLASS_128_BITS = 0x82C4;
const GL_VIEW_CLASS_16_BITS = 0x82CA;
const GL_VIEW_CLASS_24_BITS = 0x82C9;
const GL_VIEW_CLASS_32_BITS = 0x82C8;
const GL_VIEW_CLASS_48_BITS = 0x82C7;
const GL_VIEW_CLASS_64_BITS = 0x82C6;
const GL_VIEW_CLASS_8_BITS = 0x82CB;
const GL_VIEW_CLASS_96_BITS = 0x82C5;
const GL_VIEW_CLASS_BPTC_FLOAT = 0x82D3;
const GL_VIEW_CLASS_BPTC_UNORM = 0x82D2;
const GL_VIEW_CLASS_RGTC1_RED = 0x82D0;
const GL_VIEW_CLASS_RGTC2_RG = 0x82D1;
const GL_VIEW_CLASS_S3TC_DXT1_RGB = 0x82CC;
const GL_VIEW_CLASS_S3TC_DXT1_RGBA = 0x82CD;
const GL_VIEW_CLASS_S3TC_DXT3_RGBA = 0x82CE;
const GL_VIEW_CLASS_S3TC_DXT5_RGBA = 0x82CF;
const GL_VIEW_COMPATIBILITY_CLASS = 0x82B6;
const GL_WAIT_FAILED = 0x911D;
const GL_WEIGHT_ARRAY_BUFFER_BINDING = 0x889E;
const GL_WRITE_ONLY = 0x88B9;
const GL_XOR = 0x1506;
const GL_ZERO = 0;
const GL_ZOOM_X = 0x0D16;
const GL_ZOOM_Y = 0x0D17;

//Functions


fn void accum (GLenum op, float value) @extern("glAccum");
fn void activeShaderProgram (CUInt pipeline, CUInt program) @extern("glActiveShaderProgram");
fn void activeTexture (GLenum texture) @extern("glActiveTexture");
fn void alphaFunc (GLenum func, float ref) @extern("glAlphaFunc");
fn bool areTexturesResident (usz n, CUInt * textures, bool * residences) @extern("glAreTexturesResident");
fn void arrayElement (CInt i) @extern("glArrayElement");
fn void attachShader (CUInt program, CUInt shader) @extern("glAttachShader");
fn void begin (GLenum mode) @extern("glBegin");
fn void beginConditionalRender (CUInt id, GLenum mode) @extern("glBeginConditionalRender");
fn void beginQuery (GLenum target, CUInt id) @extern("glBeginQuery");
fn void beginQueryIndexed (GLenum target, CUInt index, CUInt id) @extern("glBeginQueryIndexed");
fn void beginTransformFeedback (GLenum primitiveMode) @extern("glBeginTransformFeedback");
fn void bindAttribLocation (CUInt program, CUInt index, char * name) @extern("glBindAttribLocation");
fn void bindBuffer (GLenum target, CUInt buffer) @extern("glBindBuffer");
fn void bindBufferBase (GLenum target, CUInt index, CUInt buffer) @extern("glBindBufferBase");
fn void bindBufferRange (GLenum target, CUInt index, CUInt buffer, iptr offset, uptr size) @extern("glBindBufferRange");
fn void bindFragDataLocation (CUInt program, CUInt color, char * name) @extern("glBindFragDataLocation");
fn void bindFragDataLocationIndexed (CUInt program, CUInt colorNumber, CUInt index, char * name) @extern("glBindFragDataLocationIndexed");
fn void bindFramebuffer (GLenum target, CUInt framebuffer) @extern("glBindFramebuffer");
fn void bindImageTexture (CUInt unit, CUInt texture, CInt level, bool layered, CInt layer, GLenum access, GLenum format) @extern("glBindImageTexture");
fn void bindProgramPipeline (CUInt pipeline) @extern("glBindProgramPipeline");
fn void bindRenderbuffer (GLenum target, CUInt renderbuffer) @extern("glBindRenderbuffer");
fn void bindSampler (CUInt unit, CUInt sampler) @extern("glBindSampler");
fn void bindTexture (GLenum target, CUInt texture) @extern("glBindTexture");
fn void bindTransformFeedback (GLenum target, CUInt id) @extern("glBindTransformFeedback");
fn void bindVertexArray (CUInt array) @extern("glBindVertexArray");
fn void bindVertexBuffer (CUInt bindingindex, CUInt buffer, iptr offset, usz stride) @extern("glBindVertexBuffer");
fn void bitmap (usz width, usz height, float xorig, float yorig, float xmove, float ymove, char * bitmap) @extern("glBitmap");
fn void blendColor (float red, float green, float blue, float alpha) @extern("glBlendColor");
fn void blendEquation (GLenum mode) @extern("glBlendEquation");
fn void blendEquationSeparate (GLenum modeRGB, GLenum modeAlpha) @extern("glBlendEquationSeparate");
fn void blendEquationSeparatei (CUInt buf, GLenum modeRGB, GLenum modeAlpha) @extern("glBlendEquationSeparatei");
fn void blendEquationi (CUInt buf, GLenum mode) @extern("glBlendEquationi");
fn void blendFunc (GLenum sfactor, GLenum dfactor) @extern("glBlendFunc");
fn void blendFuncSeparate (GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha) @extern("glBlendFuncSeparate");
fn void blendFuncSeparatei (CUInt buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha) @extern("glBlendFuncSeparatei");
fn void blendFunci (CUInt buf, GLenum src, GLenum dst) @extern("glBlendFunci");
fn void blitFramebuffer (CInt srcX0, CInt srcY0, CInt srcX1, CInt srcY1, CInt dstX0, CInt dstY0, CInt dstX1, CInt dstY1, GLbitfield mask, GLenum filter) @extern("glBlitFramebuffer");
fn void bufferData (GLenum target, uptr size, void * data, GLenum usage) @extern("glBufferData");
fn void bufferSubData (GLenum target, iptr offset, uptr size, void * data) @extern("glBufferSubData");
fn void callList (CUInt list) @extern("glCallList");
fn void callLists (usz n, GLenum type, void * lists) @extern("glCallLists");
fn GLenum checkFramebufferStatus (GLenum target) @extern("glCheckFramebufferStatus");
fn void clampColor (GLenum target, GLenum clamp) @extern("glClampColor");
fn void clear (GLbitfield mask) @extern("glClear");
fn void clearAccum (float red, float green, float blue, float alpha) @extern("glClearAccum");
fn void clearBufferData (GLenum target, GLenum internalformat, GLenum format, GLenum type, void * data) @extern("glClearBufferData");
fn void clearBufferSubData (GLenum target, GLenum internalformat, iptr offset, uptr size, GLenum format, GLenum type, void * data) @extern("glClearBufferSubData");
fn void clearBufferfi (GLenum buffer, CInt drawbuffer, float depth, CInt stencil) @extern("glClearBufferfi");
fn void clearBufferfv (GLenum buffer, CInt drawbuffer, float * value) @extern("glClearBufferfv");
fn void clearBufferiv (GLenum buffer, CInt drawbuffer, CInt * value) @extern("glClearBufferiv");
fn void clearBufferuiv (GLenum buffer, CInt drawbuffer, CUInt * value) @extern("glClearBufferuiv");
fn void clearColor (float red, float green, float blue, float alpha) @extern("glClearColor");
fn void clearDepth (double depth) @extern("glClearDepth");
fn void clearDepthf (float d) @extern("glClearDepthf");
fn void clearIndex (float c) @extern("glClearIndex");
fn void clearStencil (CInt s) @extern("glClearStencil");
fn void clientActiveTexture (GLenum texture) @extern("glClientActiveTexture");
fn GLenum clientWaitSync (GLsync sync, GLbitfield flags, ulong timeout) @extern("glClientWaitSync");
fn void clipPlane (GLenum plane, double * equation) @extern("glClipPlane");
fn void color3b (ichar red, ichar green, ichar blue) @extern("glColor3b");
fn void color3bv (ichar * v) @extern("glColor3bv");
fn void color3d (double red, double green, double blue) @extern("glColor3d");
fn void color3dv (double * v) @extern("glColor3dv");
fn void color3f (float red, float green, float blue) @extern("glColor3f");
fn void color3fv (float * v) @extern("glColor3fv");
fn void color3i (CInt red, CInt green, CInt blue) @extern("glColor3i");
fn void color3iv (CInt * v) @extern("glColor3iv");
fn void color3s (short red, short green, short blue) @extern("glColor3s");
fn void color3sv (short * v) @extern("glColor3sv");
fn void color3ub (char red, char green, char blue) @extern("glColor3ub");
fn void color3ubv (char * v) @extern("glColor3ubv");
fn void color3ui (CUInt red, CUInt green, CUInt blue) @extern("glColor3ui");
fn void color3uiv (CUInt * v) @extern("glColor3uiv");
fn void color3us (ushort red, ushort green, ushort blue) @extern("glColor3us");
fn void color3usv (ushort * v) @extern("glColor3usv");
fn void color4b (ichar red, ichar green, ichar blue, ichar alpha) @extern("glColor4b");
fn void color4bv (ichar * v) @extern("glColor4bv");
fn void color4d (double red, double green, double blue, double alpha) @extern("glColor4d");
fn void color4dv (double * v) @extern("glColor4dv");
fn void color4f (float red, float green, float blue, float alpha) @extern("glColor4f");
fn void color4fv (float * v) @extern("glColor4fv");
fn void color4i (CInt red, CInt green, CInt blue, CInt alpha) @extern("glColor4i");
fn void color4iv (CInt * v) @extern("glColor4iv");
fn void color4s (short red, short green, short blue, short alpha) @extern("glColor4s");
fn void color4sv (short * v) @extern("glColor4sv");
fn void color4ub (char red, char green, char blue, char alpha) @extern("glColor4ub");
fn void color4ubv (char * v) @extern("glColor4ubv");
fn void color4ui (CUInt red, CUInt green, CUInt blue, CUInt alpha) @extern("glColor4ui");
fn void color4uiv (CUInt * v) @extern("glColor4uiv");
fn void color4us (ushort red, ushort green, ushort blue, ushort alpha) @extern("glColor4us");
fn void color4usv (ushort * v) @extern("glColor4usv");
fn void colorMask (bool red, bool green, bool blue, bool alpha) @extern("glColorMask");
fn void colorMaski (CUInt index, bool r, bool g, bool b, bool a) @extern("glColorMaski");
fn void colorMaterial (GLenum face, GLenum mode) @extern("glColorMaterial");
fn void colorP3ui (GLenum type, CUInt color) @extern("glColorP3ui");
fn void colorP3uiv (GLenum type, CUInt * color) @extern("glColorP3uiv");
fn void colorP4ui (GLenum type, CUInt color) @extern("glColorP4ui");
fn void colorP4uiv (GLenum type, CUInt * color) @extern("glColorP4uiv");
fn void colorPointer (CInt size, GLenum type, usz stride, void * pointer) @extern("glColorPointer");
fn void compileShader (CUInt shader) @extern("glCompileShader");
fn void compressedTexImage1D (GLenum target, CInt level, GLenum internalformat, usz width, CInt border, usz imageSize, void * data) @extern("glCompressedTexImage1D");
fn void compressedTexImage2D (GLenum target, CInt level, GLenum internalformat, usz width, usz height, CInt border, usz imageSize, void * data) @extern("glCompressedTexImage2D");
fn void compressedTexImage3D (GLenum target, CInt level, GLenum internalformat, usz width, usz height, usz depth, CInt border, usz imageSize, void * data) @extern("glCompressedTexImage3D");
fn void compressedTexSubImage1D (GLenum target, CInt level, CInt xoffset, usz width, GLenum format, usz imageSize, void * data) @extern("glCompressedTexSubImage1D");
fn void compressedTexSubImage2D (GLenum target, CInt level, CInt xoffset, CInt yoffset, usz width, usz height, GLenum format, usz imageSize, void * data) @extern("glCompressedTexSubImage2D");
fn void compressedTexSubImage3D (GLenum target, CInt level, CInt xoffset, CInt yoffset, CInt zoffset, usz width, usz height, usz depth, GLenum format, usz imageSize, void * data) @extern("glCompressedTexSubImage3D");
fn void copyBufferSubData (GLenum readTarget, GLenum writeTarget, iptr readOffset, iptr writeOffset, uptr size) @extern("glCopyBufferSubData");
fn void copyImageSubData (CUInt srcName, GLenum srcTarget, CInt srcLevel, CInt srcX, CInt srcY, CInt srcZ, CUInt dstName, GLenum dstTarget, CInt dstLevel, CInt dstX, CInt dstY, CInt dstZ, usz srcWidth, usz srcHeight, usz srcDepth) @extern("glCopyImageSubData");
fn void copyPixels (CInt x, CInt y, usz width, usz height, GLenum type) @extern("glCopyPixels");
fn void copyTexImage1D (GLenum target, CInt level, GLenum internalformat, CInt x, CInt y, usz width, CInt border) @extern("glCopyTexImage1D");
fn void copyTexImage2D (GLenum target, CInt level, GLenum internalformat, CInt x, CInt y, usz width, usz height, CInt border) @extern("glCopyTexImage2D");
fn void copyTexSubImage1D (GLenum target, CInt level, CInt xoffset, CInt x, CInt y, usz width) @extern("glCopyTexSubImage1D");
fn void copyTexSubImage2D (GLenum target, CInt level, CInt xoffset, CInt yoffset, CInt x, CInt y, usz width, usz height) @extern("glCopyTexSubImage2D");
fn void copyTexSubImage3D (GLenum target, CInt level, CInt xoffset, CInt yoffset, CInt zoffset, CInt x, CInt y, usz width, usz height) @extern("glCopyTexSubImage3D");
fn CUInt createProgram () @extern("glCreateProgram");
fn CUInt createShader (GLenum type) @extern("glCreateShader");
fn CUInt createShaderProgramv (GLenum type, usz count, char ** strings) @extern("glCreateShaderProgramv");
fn void cullFace (GLenum mode) @extern("glCullFace");
fn void debugMessageCallback (GLDebugProc callback, void * userParam) @extern("glDebugMessageCallback");
fn void debugMessageControl (GLenum source, GLenum type, GLenum severity, usz count, CUInt * ids, bool enabled) @extern("glDebugMessageControl");
fn void debugMessageInsert (GLenum source, GLenum type, CUInt id, GLenum severity, usz length, char * buf) @extern("glDebugMessageInsert");
fn void deleteBuffers (usz n, CUInt * buffers) @extern("glDeleteBuffers");
fn void deleteFramebuffers (usz n, CUInt * framebuffers) @extern("glDeleteFramebuffers");
fn void deleteLists (CUInt list, usz range) @extern("glDeleteLists");
fn void deleteProgram (CUInt program) @extern("glDeleteProgram");
fn void deleteProgramPipelines (usz n, CUInt * pipelines) @extern("glDeleteProgramPipelines");
fn void deleteQueries (usz n, CUInt * ids) @extern("glDeleteQueries");
fn void deleteRenderbuffers (usz n, CUInt * renderbuffers) @extern("glDeleteRenderbuffers");
fn void deleteSamplers (usz count, CUInt * samplers) @extern("glDeleteSamplers");
fn void deleteShader (CUInt shader) @extern("glDeleteShader");
fn void deleteSync (GLsync sync) @extern("glDeleteSync");
fn void deleteTextures (usz n, CUInt * textures) @extern("glDeleteTextures");
fn void deleteTransformFeedbacks (usz n, CUInt * ids) @extern("glDeleteTransformFeedbacks");
fn void deleteVertexArrays (usz n, CUInt * arrays) @extern("glDeleteVertexArrays");
fn void depthFunc (GLenum func) @extern("glDepthFunc");
fn void depthMask (bool flag) @extern("glDepthMask");
fn void depthRange (double n, double f) @extern("glDepthRange");
fn void depthRangeArrayv (CUInt first, usz count, double * v) @extern("glDepthRangeArrayv");
fn void depthRangeIndexed (CUInt index, double n, double f) @extern("glDepthRangeIndexed");
fn void depthRangef (float n, float f) @extern("glDepthRangef");
fn void detachShader (CUInt program, CUInt shader) @extern("glDetachShader");
fn void disable (GLenum cap) @extern("glDisable");
fn void disableClientState (GLenum array) @extern("glDisableClientState");
fn void disableVertexAttribArray (CUInt index) @extern("glDisableVertexAttribArray");
fn void disablei (GLenum target, CUInt index) @extern("glDisablei");
fn void dispatchCompute (CUInt num_groups_x, CUInt num_groups_y, CUInt num_groups_z) @extern("glDispatchCompute");
fn void dispatchComputeIndirect (iptr indirect) @extern("glDispatchComputeIndirect");
fn void drawArrays (GLenum mode, CInt first, usz count) @extern("glDrawArrays");
fn void drawArraysIndirect (GLenum mode, void * indirect) @extern("glDrawArraysIndirect");
fn void drawArraysInstanced (GLenum mode, CInt first, usz count, usz instancecount) @extern("glDrawArraysInstanced");
fn void drawArraysInstancedBaseInstance (GLenum mode, CInt first, usz count, usz instancecount, CUInt baseinstance) @extern("glDrawArraysInstancedBaseInstance");
fn void drawBuffer (GLenum buf) @extern("glDrawBuffer");
fn void drawBuffers (usz n, GLenum * bufs) @extern("glDrawBuffers");
fn void drawElements (GLenum mode, usz count, GLenum type, void * indices) @extern("glDrawElements");
fn void drawElementsBaseVertex (GLenum mode, usz count, GLenum type, void * indices, CInt basevertex) @extern("glDrawElementsBaseVertex");
fn void drawElementsIndirect (GLenum mode, GLenum type, void * indirect) @extern("glDrawElementsIndirect");
fn void drawElementsInstanced (GLenum mode, usz count, GLenum type, void * indices, usz instancecount) @extern("glDrawElementsInstanced");
fn void drawElementsInstancedBaseInstance (GLenum mode, usz count, GLenum type, void * indices, usz instancecount, CUInt baseinstance) @extern("glDrawElementsInstancedBaseInstance");
fn void drawElementsInstancedBaseVertex (GLenum mode, usz count, GLenum type, void * indices, usz instancecount, CInt basevertex) @extern("glDrawElementsInstancedBaseVertex");
fn void drawElementsInstancedBaseVertexBaseInstance (GLenum mode, usz count, GLenum type, void * indices, usz instancecount, CInt basevertex, CUInt baseinstance) @extern("glDrawElementsInstancedBaseVertexBaseInstance");
fn void drawPixels (usz width, usz height, GLenum format, GLenum type, void * pixels) @extern("glDrawPixels");
fn void drawRangeElements (GLenum mode, CUInt start, CUInt end, usz count, GLenum type, void * indices) @extern("glDrawRangeElements");
fn void drawRangeElementsBaseVertex (GLenum mode, CUInt start, CUInt end, usz count, GLenum type, void * indices, CInt basevertex) @extern("glDrawRangeElementsBaseVertex");
fn void drawTransformFeedback (GLenum mode, CUInt id) @extern("glDrawTransformFeedback");
fn void drawTransformFeedbackInstanced (GLenum mode, CUInt id, usz instancecount) @extern("glDrawTransformFeedbackInstanced");
fn void drawTransformFeedbackStream (GLenum mode, CUInt id, CUInt stream) @extern("glDrawTransformFeedbackStream");
fn void drawTransformFeedbackStreamInstanced (GLenum mode, CUInt id, CUInt stream, usz instancecount) @extern("glDrawTransformFeedbackStreamInstanced");
fn void edgeFlag (bool flag) @extern("glEdgeFlag");
fn void edgeFlagPointer (usz stride, void * pointer) @extern("glEdgeFlagPointer");
fn void edgeFlagv (bool * flag) @extern("glEdgeFlagv");
fn void enable (GLenum cap) @extern("glEnable");
fn void enableClientState (GLenum array) @extern("glEnableClientState");
fn void enableVertexAttribArray (CUInt index) @extern("glEnableVertexAttribArray");
fn void enablei (GLenum target, CUInt index) @extern("glEnablei");
fn void end () @extern("glEnd");
fn void endConditionalRender () @extern("glEndConditionalRender");
fn void endList () @extern("glEndList");
fn void endQuery (GLenum target) @extern("glEndQuery");
fn void endQueryIndexed (GLenum target, CUInt index) @extern("glEndQueryIndexed");
fn void endTransformFeedback () @extern("glEndTransformFeedback");
fn void evalCoord1d (double u) @extern("glEvalCoord1d");
fn void evalCoord1dv (double * u) @extern("glEvalCoord1dv");
fn void evalCoord1f (float u) @extern("glEvalCoord1f");
fn void evalCoord1fv (float * u) @extern("glEvalCoord1fv");
fn void evalCoord2d (double u, double v) @extern("glEvalCoord2d");
fn void evalCoord2dv (double * u) @extern("glEvalCoord2dv");
fn void evalCoord2f (float u, float v) @extern("glEvalCoord2f");
fn void evalCoord2fv (float * u) @extern("glEvalCoord2fv");
fn void evalMesh1 (GLenum mode, CInt i1, CInt i2) @extern("glEvalMesh1");
fn void evalMesh2 (GLenum mode, CInt i1, CInt i2, CInt j1, CInt j2) @extern("glEvalMesh2");
fn void evalPoint1 (CInt i) @extern("glEvalPoint1");
fn void evalPoint2 (CInt i, CInt j) @extern("glEvalPoint2");
fn void feedbackBuffer (usz size, GLenum type, float * buffer) @extern("glFeedbackBuffer");
fn GLsync fenceSync (GLenum condition, GLbitfield flags) @extern("glFenceSync");
fn void finish () @extern("glFinish");
fn void flush () @extern("glFlush");
fn void flushMappedBufferRange (GLenum target, iptr offset, uptr length) @extern("glFlushMappedBufferRange");
fn void fogCoordPointer (GLenum type, usz stride, void * pointer) @extern("glFogCoordPointer");
fn void fogCoordd (double coord) @extern("glFogCoordd");
fn void fogCoorddv (double * coord) @extern("glFogCoorddv");
fn void fogCoordf (float coord) @extern("glFogCoordf");
fn void fogCoordfv (float * coord) @extern("glFogCoordfv");
fn void fogf (GLenum pname, float param) @extern("glFogf");
fn void fogfv (GLenum pname, float * params) @extern("glFogfv");
fn void fogi (GLenum pname, CInt param) @extern("glFogi");
fn void fogiv (GLenum pname, CInt * params) @extern("glFogiv");
fn void framebufferParameteri (GLenum target, GLenum pname, CInt param) @extern("glFramebufferParameteri");
fn void framebufferRenderbuffer (GLenum target, GLenum attachment, GLenum renderbuffertarget, CUInt renderbuffer) @extern("glFramebufferRenderbuffer");
fn void framebufferTexture (GLenum target, GLenum attachment, CUInt texture, CInt level) @extern("glFramebufferTexture");
fn void framebufferTexture1D (GLenum target, GLenum attachment, GLenum textarget, CUInt texture, CInt level) @extern("glFramebufferTexture1D");
fn void framebufferTexture2D (GLenum target, GLenum attachment, GLenum textarget, CUInt texture, CInt level) @extern("glFramebufferTexture2D");
fn void framebufferTexture3D (GLenum target, GLenum attachment, GLenum textarget, CUInt texture, CInt level, CInt zoffset) @extern("glFramebufferTexture3D");
fn void framebufferTextureLayer (GLenum target, GLenum attachment, CUInt texture, CInt level, CInt layer) @extern("glFramebufferTextureLayer");
fn void frontFace (GLenum mode) @extern("glFrontFace");
fn void frustum (double left, double right, double bottom, double top, double zNear, double zFar) @extern("glFrustum");
fn void genBuffers (usz n, CUInt * buffers) @extern("glGenBuffers");
fn void genFramebuffers (usz n, CUInt * framebuffers) @extern("glGenFramebuffers");
fn CUInt genLists (usz range) @extern("glGenLists");
fn void genProgramPipelines (usz n, CUInt * pipelines) @extern("glGenProgramPipelines");
fn void genQueries (usz n, CUInt * ids) @extern("glGenQueries");
fn void genRenderbuffers (usz n, CUInt * renderbuffers) @extern("glGenRenderbuffers");
fn void genSamplers (usz count, CUInt * samplers) @extern("glGenSamplers");
fn void genTextures (usz n, CUInt * textures) @extern("glGenTextures");
fn void genTransformFeedbacks (usz n, CUInt * ids) @extern("glGenTransformFeedbacks");
fn void genVertexArrays (usz n, CUInt * arrays) @extern("glGenVertexArrays");
fn void generateMipmap (GLenum target) @extern("glGenerateMipmap");
fn void getActiveAtomicCounterBufferiv (CUInt program, CUInt bufferIndex, GLenum pname, CInt * params) @extern("glGetActiveAtomicCounterBufferiv");
fn void getActiveAttrib (CUInt program, CUInt index, usz bufSize, usz * length, CInt * size, GLenum * type, char * name) @extern("glGetActiveAttrib");
fn void getActiveSubroutineName (CUInt program, GLenum shadertype, CUInt index, usz bufSize, usz * length, char * name) @extern("glGetActiveSubroutineName");
fn void getActiveSubroutineUniformName (CUInt program, GLenum shadertype, CUInt index, usz bufSize, usz * length, char * name) @extern("glGetActiveSubroutineUniformName");
fn void getActiveSubroutineUniformiv (CUInt program, GLenum shadertype, CUInt index, GLenum pname, CInt * values) @extern("glGetActiveSubroutineUniformiv");
fn void getActiveUniform (CUInt program, CUInt index, usz bufSize, usz * length, CInt * size, GLenum * type, char * name) @extern("glGetActiveUniform");
fn void getActiveUniformBlockName (CUInt program, CUInt uniformBlockIndex, usz bufSize, usz * length, char * uniformBlockName) @extern("glGetActiveUniformBlockName");
fn void getActiveUniformBlockiv (CUInt program, CUInt uniformBlockIndex, GLenum pname, CInt * params) @extern("glGetActiveUniformBlockiv");
fn void getActiveUniformName (CUInt program, CUInt uniformIndex, usz bufSize, usz * length, char * uniformName) @extern("glGetActiveUniformName");
fn void getActiveUniformsiv (CUInt program, usz uniformCount, CUInt * uniformIndices, GLenum pname, CInt * params) @extern("glGetActiveUniformsiv");
fn void getAttachedShaders (CUInt program, usz maxCount, usz * count, CUInt * shaders) @extern("glGetAttachedShaders");
fn CInt getAttribLocation (CUInt program, char * name) @extern("glGetAttribLocation");
fn void getBooleani_v (GLenum target, CUInt index, bool * data) @extern("glGetBooleani_v");
fn void getBooleanv (GLenum pname, bool * data) @extern("glGetBooleanv");
fn void getBufferParameteri64v (GLenum target, GLenum pname, long * params) @extern("glGetBufferParameteri64v");
fn void getBufferParameteriv (GLenum target, GLenum pname, CInt * params) @extern("glGetBufferParameteriv");
fn void getBufferPointerv (GLenum target, GLenum pname, void ** params) @extern("glGetBufferPointerv");
fn void getBufferSubData (GLenum target, iptr offset, uptr size, void * data) @extern("glGetBufferSubData");
fn void getClipPlane (GLenum plane, double * equation) @extern("glGetClipPlane");
fn void getCompressedTexImage (GLenum target, CInt level, void * img) @extern("glGetCompressedTexImage");
fn CUInt getDebugMessageLog (CUInt count, usz bufSize, GLenum * sources, GLenum * types, CUInt * ids, GLenum * severities, usz * lengths, char * messageLog) @extern("glGetDebugMessageLog");
fn void getDoublei_v (GLenum target, CUInt index, double * data) @extern("glGetDoublei_v");
fn void getDoublev (GLenum pname, double * data) @extern("glGetDoublev");
fn GLenum getError () @extern("glGetError");
fn void getFloati_v (GLenum target, CUInt index, float * data) @extern("glGetFloati_v");
fn void getFloatv (GLenum pname, float * data) @extern("glGetFloatv");
fn CInt getFragDataIndex (CUInt program, char * name) @extern("glGetFragDataIndex");
fn CInt getFragDataLocation (CUInt program, char * name) @extern("glGetFragDataLocation");
fn void getFramebufferAttachmentParameteriv (GLenum target, GLenum attachment, GLenum pname, CInt * params) @extern("glGetFramebufferAttachmentParameteriv");
fn void getFramebufferParameteriv (GLenum target, GLenum pname, CInt * params) @extern("glGetFramebufferParameteriv");
fn void getInteger64i_v (GLenum target, CUInt index, long * data) @extern("glGetInteger64i_v");
fn void getInteger64v (GLenum pname, long * data) @extern("glGetInteger64v");
fn void getIntegeri_v (GLenum target, CUInt index, CInt * data) @extern("glGetIntegeri_v");
fn void getIntegerv (GLenum pname, CInt * data) @extern("glGetIntegerv");
fn void getInternalformati64v (GLenum target, GLenum internalformat, GLenum pname, usz count, long * params) @extern("glGetInternalformati64v");
fn void getInternalformativ (GLenum target, GLenum internalformat, GLenum pname, usz count, CInt * params) @extern("glGetInternalformativ");
fn void getLightfv (GLenum light, GLenum pname, float * params) @extern("glGetLightfv");
fn void getLightiv (GLenum light, GLenum pname, CInt * params) @extern("glGetLightiv");
fn void getMapdv (GLenum target, GLenum query, double * v) @extern("glGetMapdv");
fn void getMapfv (GLenum target, GLenum query, float * v) @extern("glGetMapfv");
fn void getMapiv (GLenum target, GLenum query, CInt * v) @extern("glGetMapiv");
fn void getMaterialfv (GLenum face, GLenum pname, float * params) @extern("glGetMaterialfv");
fn void getMaterialiv (GLenum face, GLenum pname, CInt * params) @extern("glGetMaterialiv");
fn void getMultisamplefv (GLenum pname, CUInt index, float * val) @extern("glGetMultisamplefv");
fn void getObjectLabel (GLenum identifier, CUInt name, usz bufSize, usz * length, char * label) @extern("glGetObjectLabel");
fn void getObjectPtrLabel (void * ptr, usz bufSize, usz * length, char * label) @extern("glGetObjectPtrLabel");
fn void getPixelMapfv (GLenum map, float * values) @extern("glGetPixelMapfv");
fn void getPixelMapuiv (GLenum map, CUInt * values) @extern("glGetPixelMapuiv");
fn void getPixelMapusv (GLenum map, ushort * values) @extern("glGetPixelMapusv");
fn void getPointerv (GLenum pname, void ** params) @extern("glGetPointerv");
fn void getPolygonStipple (char * mask) @extern("glGetPolygonStipple");
fn void getProgramBinary (CUInt program, usz bufSize, usz * length, GLenum * binaryFormat, void * binary) @extern("glGetProgramBinary");
fn void getProgramInfoLog (CUInt program, usz bufSize, usz * length, char * infoLog) @extern("glGetProgramInfoLog");
fn void getProgramInterfaceiv (CUInt program, GLenum programInterface, GLenum pname, CInt * params) @extern("glGetProgramInterfaceiv");
fn void getProgramPipelineInfoLog (CUInt pipeline, usz bufSize, usz * length, char * infoLog) @extern("glGetProgramPipelineInfoLog");
fn void getProgramPipelineiv (CUInt pipeline, GLenum pname, CInt * params) @extern("glGetProgramPipelineiv");
fn CUInt getProgramResourceIndex (CUInt program, GLenum programInterface, char * name) @extern("glGetProgramResourceIndex");
fn CInt getProgramResourceLocation (CUInt program, GLenum programInterface, char * name) @extern("glGetProgramResourceLocation");
fn CInt getProgramResourceLocationIndex (CUInt program, GLenum programInterface, char * name) @extern("glGetProgramResourceLocationIndex");
fn void getProgramResourceName (CUInt program, GLenum programInterface, CUInt index, usz bufSize, usz * length, char * name) @extern("glGetProgramResourceName");
fn void getProgramResourceiv (CUInt program, GLenum programInterface, CUInt index, usz propCount, GLenum * props, usz count, usz * length, CInt * params) @extern("glGetProgramResourceiv");
fn void getProgramStageiv (CUInt program, GLenum shadertype, GLenum pname, CInt * values) @extern("glGetProgramStageiv");
fn void getProgramiv (CUInt program, GLenum pname, CInt * params) @extern("glGetProgramiv");
fn void getQueryIndexediv (GLenum target, CUInt index, GLenum pname, CInt * params) @extern("glGetQueryIndexediv");
fn void getQueryObjecti64v (CUInt id, GLenum pname, long * params) @extern("glGetQueryObjecti64v");
fn void getQueryObjectiv (CUInt id, GLenum pname, CInt * params) @extern("glGetQueryObjectiv");
fn void getQueryObjectui64v (CUInt id, GLenum pname, ulong * params) @extern("glGetQueryObjectui64v");
fn void getQueryObjectuiv (CUInt id, GLenum pname, CUInt * params) @extern("glGetQueryObjectuiv");
fn void getQueryiv (GLenum target, GLenum pname, CInt * params) @extern("glGetQueryiv");
fn void getRenderbufferParameteriv (GLenum target, GLenum pname, CInt * params) @extern("glGetRenderbufferParameteriv");
fn void getSamplerParameterIiv (CUInt sampler, GLenum pname, CInt * params) @extern("glGetSamplerParameterIiv");
fn void getSamplerParameterIuiv (CUInt sampler, GLenum pname, CUInt * params) @extern("glGetSamplerParameterIuiv");
fn void getSamplerParameterfv (CUInt sampler, GLenum pname, float * params) @extern("glGetSamplerParameterfv");
fn void getSamplerParameteriv (CUInt sampler, GLenum pname, CInt * params) @extern("glGetSamplerParameteriv");
fn void getShaderInfoLog (CUInt shader, usz bufSize, usz * length, char * infoLog) @extern("glGetShaderInfoLog");
fn void getShaderPrecisionFormat (GLenum shadertype, GLenum precisiontype, CInt * range, CInt * precision) @extern("glGetShaderPrecisionFormat");
fn void getShaderSource (CUInt shader, usz bufSize, usz * length, char * source) @extern("glGetShaderSource");
fn void getShaderiv (CUInt shader, GLenum pname, CInt * params) @extern("glGetShaderiv");
fn char * getString (GLenum name) @extern("glGetString");
fn char * getStringi (GLenum name, CUInt index) @extern("glGetStringi");
fn CUInt getSubroutineIndex (CUInt program, GLenum shadertype, char * name) @extern("glGetSubroutineIndex");
fn CInt getSubroutineUniformLocation (CUInt program, GLenum shadertype, char * name) @extern("glGetSubroutineUniformLocation");
fn void getSynciv (GLsync sync, GLenum pname, usz count, usz * length, CInt * values) @extern("glGetSynciv");
fn void getTexEnvfv (GLenum target, GLenum pname, float * params) @extern("glGetTexEnvfv");
fn void getTexEnviv (GLenum target, GLenum pname, CInt * params) @extern("glGetTexEnviv");
fn void getTexGendv (GLenum coord, GLenum pname, double * params) @extern("glGetTexGendv");
fn void getTexGenfv (GLenum coord, GLenum pname, float * params) @extern("glGetTexGenfv");
fn void getTexGeniv (GLenum coord, GLenum pname, CInt * params) @extern("glGetTexGeniv");
fn void getTexImage (GLenum target, CInt level, GLenum format, GLenum type, void * pixels) @extern("glGetTexImage");
fn void getTexLevelParameterfv (GLenum target, CInt level, GLenum pname, float * params) @extern("glGetTexLevelParameterfv");
fn void getTexLevelParameteriv (GLenum target, CInt level, GLenum pname, CInt * params) @extern("glGetTexLevelParameteriv");
fn void getTexParameterIiv (GLenum target, GLenum pname, CInt * params) @extern("glGetTexParameterIiv");
fn void getTexParameterIuiv (GLenum target, GLenum pname, CUInt * params) @extern("glGetTexParameterIuiv");
fn void getTexParameterfv (GLenum target, GLenum pname, float * params) @extern("glGetTexParameterfv");
fn void getTexParameteriv (GLenum target, GLenum pname, CInt * params) @extern("glGetTexParameteriv");
fn void getTransformFeedbackVarying (CUInt program, CUInt index, usz bufSize, usz * length, usz * size, GLenum * type, char * name) @extern("glGetTransformFeedbackVarying");
fn CUInt getUniformBlockIndex (CUInt program, char * uniformBlockName) @extern("glGetUniformBlockIndex");
fn void getUniformIndices (CUInt program, usz uniformCount, char ** uniformNames, CUInt * uniformIndices) @extern("glGetUniformIndices");
fn CInt getUniformLocation (CUInt program, char * name) @extern("glGetUniformLocation");
fn void getUniformSubroutineuiv (GLenum shadertype, CInt location, CUInt * params) @extern("glGetUniformSubroutineuiv");
fn void getUniformdv (CUInt program, CInt location, double * params) @extern("glGetUniformdv");
fn void getUniformfv (CUInt program, CInt location, float * params) @extern("glGetUniformfv");
fn void getUniformiv (CUInt program, CInt location, CInt * params) @extern("glGetUniformiv");
fn void getUniformuiv (CUInt program, CInt location, CUInt * params) @extern("glGetUniformuiv");
fn void getVertexAttribIiv (CUInt index, GLenum pname, CInt * params) @extern("glGetVertexAttribIiv");
fn void getVertexAttribIuiv (CUInt index, GLenum pname, CUInt * params) @extern("glGetVertexAttribIuiv");
fn void getVertexAttribLdv (CUInt index, GLenum pname, double * params) @extern("glGetVertexAttribLdv");
fn void getVertexAttribPointerv (CUInt index, GLenum pname, void ** pointer) @extern("glGetVertexAttribPointerv");
fn void getVertexAttribdv (CUInt index, GLenum pname, double * params) @extern("glGetVertexAttribdv");
fn void getVertexAttribfv (CUInt index, GLenum pname, float * params) @extern("glGetVertexAttribfv");
fn void getVertexAttribiv (CUInt index, GLenum pname, CInt * params) @extern("glGetVertexAttribiv");
fn void hint (GLenum target, GLenum mode) @extern("glHint");
fn void indexMask (CUInt mask) @extern("glIndexMask");
fn void indexPointer (GLenum type, usz stride, void * pointer) @extern("glIndexPointer");
fn void indexd (double c) @extern("glIndexd");
fn void indexdv (double * c) @extern("glIndexdv");
fn void indexf (float c) @extern("glIndexf");
fn void indexfv (float * c) @extern("glIndexfv");
fn void indexi (CInt c) @extern("glIndexi");
fn void indexiv (CInt * c) @extern("glIndexiv");
fn void indexs (short c) @extern("glIndexs");
fn void indexsv (short * c) @extern("glIndexsv");
fn void indexub (char c) @extern("glIndexub");
fn void indexubv (char * c) @extern("glIndexubv");
fn void initNames () @extern("glInitNames");
fn void interleavedArrays (GLenum format, usz stride, void * pointer) @extern("glInterleavedArrays");
fn void invalidateBufferData (CUInt buffer) @extern("glInvalidateBufferData");
fn void invalidateBufferSubData (CUInt buffer, iptr offset, uptr length) @extern("glInvalidateBufferSubData");
fn void invalidateFramebuffer (GLenum target, usz numAttachments, GLenum * attachments) @extern("glInvalidateFramebuffer");
fn void invalidateSubFramebuffer (GLenum target, usz numAttachments, GLenum * attachments, CInt x, CInt y, usz width, usz height) @extern("glInvalidateSubFramebuffer");
fn void invalidateTexImage (CUInt texture, CInt level) @extern("glInvalidateTexImage");
fn void invalidateTexSubImage (CUInt texture, CInt level, CInt xoffset, CInt yoffset, CInt zoffset, usz width, usz height, usz depth) @extern("glInvalidateTexSubImage");
fn bool isBuffer (CUInt buffer) @extern("glIsBuffer");
fn bool isEnabled (GLenum cap) @extern("glIsEnabled");
fn bool isEnabledi (GLenum target, CUInt index) @extern("glIsEnabledi");
fn bool isFramebuffer (CUInt framebuffer) @extern("glIsFramebuffer");
fn bool isList (CUInt list) @extern("glIsList");
fn bool isProgram (CUInt program) @extern("glIsProgram");
fn bool isProgramPipeline (CUInt pipeline) @extern("glIsProgramPipeline");
fn bool isQuery (CUInt id) @extern("glIsQuery");
fn bool isRenderbuffer (CUInt renderbuffer) @extern("glIsRenderbuffer");
fn bool isSampler (CUInt sampler) @extern("glIsSampler");
fn bool isShader (CUInt shader) @extern("glIsShader");
fn bool isSync (GLsync sync) @extern("glIsSync");
fn bool isTexture (CUInt texture) @extern("glIsTexture");
fn bool isTransformFeedback (CUInt id) @extern("glIsTransformFeedback");
fn bool isVertexArray (CUInt array) @extern("glIsVertexArray");
fn void lightModelf (GLenum pname, float param) @extern("glLightModelf");
fn void lightModelfv (GLenum pname, float * params) @extern("glLightModelfv");
fn void lightModeli (GLenum pname, CInt param) @extern("glLightModeli");
fn void lightModeliv (GLenum pname, CInt * params) @extern("glLightModeliv");
fn void lightf (GLenum light, GLenum pname, float param) @extern("glLightf");
fn void lightfv (GLenum light, GLenum pname, float * params) @extern("glLightfv");
fn void lighti (GLenum light, GLenum pname, CInt param) @extern("glLighti");
fn void lightiv (GLenum light, GLenum pname, CInt * params) @extern("glLightiv");
fn void lineStipple (CInt factor, ushort pattern) @extern("glLineStipple");
fn void lineWidth (float width) @extern("glLineWidth");
fn void linkProgram (CUInt program) @extern("glLinkProgram");
fn void listBase (CUInt base) @extern("glListBase");
fn void loadIdentity () @extern("glLoadIdentity");
fn void loadMatrixd (double * m) @extern("glLoadMatrixd");
fn void loadMatrixf (float * m) @extern("glLoadMatrixf");
fn void loadName (CUInt name) @extern("glLoadName");
fn void loadTransposeMatrixd (double * m) @extern("glLoadTransposeMatrixd");
fn void loadTransposeMatrixf (float * m) @extern("glLoadTransposeMatrixf");
fn void logicOp (GLenum opcode) @extern("glLogicOp");
fn void map1d (GLenum target, double u1, double u2, CInt stride, CInt order, double * points) @extern("glMap1d");
fn void map1f (GLenum target, float u1, float u2, CInt stride, CInt order, float * points) @extern("glMap1f");
fn void map2d (GLenum target, double u1, double u2, CInt ustride, CInt uorder, double v1, double v2, CInt vstride, CInt vorder, double * points) @extern("glMap2d");
fn void map2f (GLenum target, float u1, float u2, CInt ustride, CInt uorder, float v1, float v2, CInt vstride, CInt vorder, float * points) @extern("glMap2f");
fn void * mapBuffer (GLenum target, GLenum access) @extern("glMapBuffer");
fn void * mapBufferRange (GLenum target, iptr offset, uptr length, GLbitfield access) @extern("glMapBufferRange");
fn void mapGrid1d (CInt un, double u1, double u2) @extern("glMapGrid1d");
fn void mapGrid1f (CInt un, float u1, float u2) @extern("glMapGrid1f");
fn void mapGrid2d (CInt un, double u1, double u2, CInt vn, double v1, double v2) @extern("glMapGrid2d");
fn void mapGrid2f (CInt un, float u1, float u2, CInt vn, float v1, float v2) @extern("glMapGrid2f");
fn void materialf (GLenum face, GLenum pname, float param) @extern("glMaterialf");
fn void materialfv (GLenum face, GLenum pname, float * params) @extern("glMaterialfv");
fn void materiali (GLenum face, GLenum pname, CInt param) @extern("glMateriali");
fn void materialiv (GLenum face, GLenum pname, CInt * params) @extern("glMaterialiv");
fn void matrixMode (GLenum mode) @extern("glMatrixMode");
fn void memoryBarrier (GLbitfield barriers) @extern("glMemoryBarrier");
fn void minSampleShading (float value) @extern("glMinSampleShading");
fn void multMatrixd (double * m) @extern("glMultMatrixd");
fn void multMatrixf (float * m) @extern("glMultMatrixf");
fn void multTransposeMatrixd (double * m) @extern("glMultTransposeMatrixd");
fn void multTransposeMatrixf (float * m) @extern("glMultTransposeMatrixf");
fn void multiDrawArrays (GLenum mode, CInt * first, usz * count, usz drawcount) @extern("glMultiDrawArrays");
fn void multiDrawArraysIndirect (GLenum mode, void * indirect, usz drawcount, usz stride) @extern("glMultiDrawArraysIndirect");
fn void multiDrawElements (GLenum mode, usz * count, GLenum type, void ** indices, usz drawcount) @extern("glMultiDrawElements");
fn void multiDrawElementsBaseVertex (GLenum mode, usz * count, GLenum type, void ** indices, usz drawcount, CInt * basevertex) @extern("glMultiDrawElementsBaseVertex");
fn void multiDrawElementsIndirect (GLenum mode, GLenum type, void * indirect, usz drawcount, usz stride) @extern("glMultiDrawElementsIndirect");
fn void multiTexCoord1d (GLenum target, double s) @extern("glMultiTexCoord1d");
fn void multiTexCoord1dv (GLenum target, double * v) @extern("glMultiTexCoord1dv");
fn void multiTexCoord1f (GLenum target, float s) @extern("glMultiTexCoord1f");
fn void multiTexCoord1fv (GLenum target, float * v) @extern("glMultiTexCoord1fv");
fn void multiTexCoord1i (GLenum target, CInt s) @extern("glMultiTexCoord1i");
fn void multiTexCoord1iv (GLenum target, CInt * v) @extern("glMultiTexCoord1iv");
fn void multiTexCoord1s (GLenum target, short s) @extern("glMultiTexCoord1s");
fn void multiTexCoord1sv (GLenum target, short * v) @extern("glMultiTexCoord1sv");
fn void multiTexCoord2d (GLenum target, double s, double t) @extern("glMultiTexCoord2d");
fn void multiTexCoord2dv (GLenum target, double * v) @extern("glMultiTexCoord2dv");
fn void multiTexCoord2f (GLenum target, float s, float t) @extern("glMultiTexCoord2f");
fn void multiTexCoord2fv (GLenum target, float * v) @extern("glMultiTexCoord2fv");
fn void multiTexCoord2i (GLenum target, CInt s, CInt t) @extern("glMultiTexCoord2i");
fn void multiTexCoord2iv (GLenum target, CInt * v) @extern("glMultiTexCoord2iv");
fn void multiTexCoord2s (GLenum target, short s, short t) @extern("glMultiTexCoord2s");
fn void multiTexCoord2sv (GLenum target, short * v) @extern("glMultiTexCoord2sv");
fn void multiTexCoord3d (GLenum target, double s, double t, double r) @extern("glMultiTexCoord3d");
fn void multiTexCoord3dv (GLenum target, double * v) @extern("glMultiTexCoord3dv");
fn void multiTexCoord3f (GLenum target, float s, float t, float r) @extern("glMultiTexCoord3f");
fn void multiTexCoord3fv (GLenum target, float * v) @extern("glMultiTexCoord3fv");
fn void multiTexCoord3i (GLenum target, CInt s, CInt t, CInt r) @extern("glMultiTexCoord3i");
fn void multiTexCoord3iv (GLenum target, CInt * v) @extern("glMultiTexCoord3iv");
fn void multiTexCoord3s (GLenum target, short s, short t, short r) @extern("glMultiTexCoord3s");
fn void multiTexCoord3sv (GLenum target, short * v) @extern("glMultiTexCoord3sv");
fn void multiTexCoord4d (GLenum target, double s, double t, double r, double q) @extern("glMultiTexCoord4d");
fn void multiTexCoord4dv (GLenum target, double * v) @extern("glMultiTexCoord4dv");
fn void multiTexCoord4f (GLenum target, float s, float t, float r, float q) @extern("glMultiTexCoord4f");
fn void multiTexCoord4fv (GLenum target, float * v) @extern("glMultiTexCoord4fv");
fn void multiTexCoord4i (GLenum target, CInt s, CInt t, CInt r, CInt q) @extern("glMultiTexCoord4i");
fn void multiTexCoord4iv (GLenum target, CInt * v) @extern("glMultiTexCoord4iv");
fn void multiTexCoord4s (GLenum target, short s, short t, short r, short q) @extern("glMultiTexCoord4s");
fn void multiTexCoord4sv (GLenum target, short * v) @extern("glMultiTexCoord4sv");
fn void multiTexCoordP1ui (GLenum texture, GLenum type, CUInt coords) @extern("glMultiTexCoordP1ui");
fn void multiTexCoordP1uiv (GLenum texture, GLenum type, CUInt * coords) @extern("glMultiTexCoordP1uiv");
fn void multiTexCoordP2ui (GLenum texture, GLenum type, CUInt coords) @extern("glMultiTexCoordP2ui");
fn void multiTexCoordP2uiv (GLenum texture, GLenum type, CUInt * coords) @extern("glMultiTexCoordP2uiv");
fn void multiTexCoordP3ui (GLenum texture, GLenum type, CUInt coords) @extern("glMultiTexCoordP3ui");
fn void multiTexCoordP3uiv (GLenum texture, GLenum type, CUInt * coords) @extern("glMultiTexCoordP3uiv");
fn void multiTexCoordP4ui (GLenum texture, GLenum type, CUInt coords) @extern("glMultiTexCoordP4ui");
fn void multiTexCoordP4uiv (GLenum texture, GLenum type, CUInt * coords) @extern("glMultiTexCoordP4uiv");
fn void newList (CUInt list, GLenum mode) @extern("glNewList");
fn void normal3b (ichar nx, ichar ny, ichar nz) @extern("glNormal3b");
fn void normal3bv (ichar * v) @extern("glNormal3bv");
fn void normal3d (double nx, double ny, double nz) @extern("glNormal3d");
fn void normal3dv (double * v) @extern("glNormal3dv");
fn void normal3f (float nx, float ny, float nz) @extern("glNormal3f");
fn void normal3fv (float * v) @extern("glNormal3fv");
fn void normal3i (CInt nx, CInt ny, CInt nz) @extern("glNormal3i");
fn void normal3iv (CInt * v) @extern("glNormal3iv");
fn void normal3s (short nx, short ny, short nz) @extern("glNormal3s");
fn void normal3sv (short * v) @extern("glNormal3sv");
fn void normalP3ui (GLenum type, CUInt coords) @extern("glNormalP3ui");
fn void normalP3uiv (GLenum type, CUInt * coords) @extern("glNormalP3uiv");
fn void normalPointer (GLenum type, usz stride, void * pointer) @extern("glNormalPointer");
fn void objectLabel (GLenum identifier, CUInt name, usz length, char * label) @extern("glObjectLabel");
fn void objectPtrLabel (void * ptr, usz length, char * label) @extern("glObjectPtrLabel");
fn void ortho (double left, double right, double bottom, double top, double zNear, double zFar) @extern("glOrtho");
fn void passThrough (float token) @extern("glPassThrough");
fn void patchParameterfv (GLenum pname, float * values) @extern("glPatchParameterfv");
fn void patchParameteri (GLenum pname, CInt value) @extern("glPatchParameteri");
fn void pauseTransformFeedback () @extern("glPauseTransformFeedback");
fn void pixelMapfv (GLenum map, usz mapsize, float * values) @extern("glPixelMapfv");
fn void pixelMapuiv (GLenum map, usz mapsize, CUInt * values) @extern("glPixelMapuiv");
fn void pixelMapusv (GLenum map, usz mapsize, ushort * values) @extern("glPixelMapusv");
fn void pixelStoref (GLenum pname, float param) @extern("glPixelStoref");
fn void pixelStorei (GLenum pname, CInt param) @extern("glPixelStorei");
fn void pixelTransferf (GLenum pname, float param) @extern("glPixelTransferf");
fn void pixelTransferi (GLenum pname, CInt param) @extern("glPixelTransferi");
fn void pixelZoom (float xfactor, float yfactor) @extern("glPixelZoom");
fn void pointParameterf (GLenum pname, float param) @extern("glPointParameterf");
fn void pointParameterfv (GLenum pname, float * params) @extern("glPointParameterfv");
fn void pointParameteri (GLenum pname, CInt param) @extern("glPointParameteri");
fn void pointParameteriv (GLenum pname, CInt * params) @extern("glPointParameteriv");
fn void pointSize (float size) @extern("glPointSize");
fn void polygonMode (GLenum face, GLenum mode) @extern("glPolygonMode");
fn void polygonOffset (float factor, float units) @extern("glPolygonOffset");
fn void polygonStipple (char * mask) @extern("glPolygonStipple");
fn void popAttrib () @extern("glPopAttrib");
fn void popClientAttrib () @extern("glPopClientAttrib");
fn void popDebugGroup () @extern("glPopDebugGroup");
fn void popMatrix () @extern("glPopMatrix");
fn void popName () @extern("glPopName");
fn void primitiveRestartIndex (CUInt index) @extern("glPrimitiveRestartIndex");
fn void prioritizeTextures (usz n, CUInt * textures, float * priorities) @extern("glPrioritizeTextures");
fn void programBinary (CUInt program, GLenum binaryFormat, void * binary, usz length) @extern("glProgramBinary");
fn void programParameteri (CUInt program, GLenum pname, CInt value) @extern("glProgramParameteri");
fn void programUniform1d (CUInt program, CInt location, double v0) @extern("glProgramUniform1d");
fn void programUniform1dv (CUInt program, CInt location, usz count, double * value) @extern("glProgramUniform1dv");
fn void programUniform1f (CUInt program, CInt location, float v0) @extern("glProgramUniform1f");
fn void programUniform1fv (CUInt program, CInt location, usz count, float * value) @extern("glProgramUniform1fv");
fn void programUniform1i (CUInt program, CInt location, CInt v0) @extern("glProgramUniform1i");
fn void programUniform1iv (CUInt program, CInt location, usz count, CInt * value) @extern("glProgramUniform1iv");
fn void programUniform1ui (CUInt program, CInt location, CUInt v0) @extern("glProgramUniform1ui");
fn void programUniform1uiv (CUInt program, CInt location, usz count, CUInt * value) @extern("glProgramUniform1uiv");
fn void programUniform2d (CUInt program, CInt location, double v0, double v1) @extern("glProgramUniform2d");
fn void programUniform2dv (CUInt program, CInt location, usz count, double * value) @extern("glProgramUniform2dv");
fn void programUniform2f (CUInt program, CInt location, float v0, float v1) @extern("glProgramUniform2f");
fn void programUniform2fv (CUInt program, CInt location, usz count, float * value) @extern("glProgramUniform2fv");
fn void programUniform2i (CUInt program, CInt location, CInt v0, CInt v1) @extern("glProgramUniform2i");
fn void programUniform2iv (CUInt program, CInt location, usz count, CInt * value) @extern("glProgramUniform2iv");
fn void programUniform2ui (CUInt program, CInt location, CUInt v0, CUInt v1) @extern("glProgramUniform2ui");
fn void programUniform2uiv (CUInt program, CInt location, usz count, CUInt * value) @extern("glProgramUniform2uiv");
fn void programUniform3d (CUInt program, CInt location, double v0, double v1, double v2) @extern("glProgramUniform3d");
fn void programUniform3dv (CUInt program, CInt location, usz count, double * value) @extern("glProgramUniform3dv");
fn void programUniform3f (CUInt program, CInt location, float v0, float v1, float v2) @extern("glProgramUniform3f");
fn void programUniform3fv (CUInt program, CInt location, usz count, float * value) @extern("glProgramUniform3fv");
fn void programUniform3i (CUInt program, CInt location, CInt v0, CInt v1, CInt v2) @extern("glProgramUniform3i");
fn void programUniform3iv (CUInt program, CInt location, usz count, CInt * value) @extern("glProgramUniform3iv");
fn void programUniform3ui (CUInt program, CInt location, CUInt v0, CUInt v1, CUInt v2) @extern("glProgramUniform3ui");
fn void programUniform3uiv (CUInt program, CInt location, usz count, CUInt * value) @extern("glProgramUniform3uiv");
fn void programUniform4d (CUInt program, CInt location, double v0, double v1, double v2, double v3) @extern("glProgramUniform4d");
fn void programUniform4dv (CUInt program, CInt location, usz count, double * value) @extern("glProgramUniform4dv");
fn void programUniform4f (CUInt program, CInt location, float v0, float v1, float v2, float v3) @extern("glProgramUniform4f");
fn void programUniform4fv (CUInt program, CInt location, usz count, float * value) @extern("glProgramUniform4fv");
fn void programUniform4i (CUInt program, CInt location, CInt v0, CInt v1, CInt v2, CInt v3) @extern("glProgramUniform4i");
fn void programUniform4iv (CUInt program, CInt location, usz count, CInt * value) @extern("glProgramUniform4iv");
fn void programUniform4ui (CUInt program, CInt location, CUInt v0, CUInt v1, CUInt v2, CUInt v3) @extern("glProgramUniform4ui");
fn void programUniform4uiv (CUInt program, CInt location, usz count, CUInt * value) @extern("glProgramUniform4uiv");
fn void programUniformMatrix2dv (CUInt program, CInt location, usz count, bool transpose, double * value) @extern("glProgramUniformMatrix2dv");
fn void programUniformMatrix2fv (CUInt program, CInt location, usz count, bool transpose, float * value) @extern("glProgramUniformMatrix2fv");
fn void programUniformMatrix2x3dv (CUInt program, CInt location, usz count, bool transpose, double * value) @extern("glProgramUniformMatrix2x3dv");
fn void programUniformMatrix2x3fv (CUInt program, CInt location, usz count, bool transpose, float * value) @extern("glProgramUniformMatrix2x3fv");
fn void programUniformMatrix2x4dv (CUInt program, CInt location, usz count, bool transpose, double * value) @extern("glProgramUniformMatrix2x4dv");
fn void programUniformMatrix2x4fv (CUInt program, CInt location, usz count, bool transpose, float * value) @extern("glProgramUniformMatrix2x4fv");
fn void programUniformMatrix3dv (CUInt program, CInt location, usz count, bool transpose, double * value) @extern("glProgramUniformMatrix3dv");
fn void programUniformMatrix3fv (CUInt program, CInt location, usz count, bool transpose, float * value) @extern("glProgramUniformMatrix3fv");
fn void programUniformMatrix3x2dv (CUInt program, CInt location, usz count, bool transpose, double * value) @extern("glProgramUniformMatrix3x2dv");
fn void programUniformMatrix3x2fv (CUInt program, CInt location, usz count, bool transpose, float * value) @extern("glProgramUniformMatrix3x2fv");
fn void programUniformMatrix3x4dv (CUInt program, CInt location, usz count, bool transpose, double * value) @extern("glProgramUniformMatrix3x4dv");
fn void programUniformMatrix3x4fv (CUInt program, CInt location, usz count, bool transpose, float * value) @extern("glProgramUniformMatrix3x4fv");
fn void programUniformMatrix4dv (CUInt program, CInt location, usz count, bool transpose, double * value) @extern("glProgramUniformMatrix4dv");
fn void programUniformMatrix4fv (CUInt program, CInt location, usz count, bool transpose, float * value) @extern("glProgramUniformMatrix4fv");
fn void programUniformMatrix4x2dv (CUInt program, CInt location, usz count, bool transpose, double * value) @extern("glProgramUniformMatrix4x2dv");
fn void programUniformMatrix4x2fv (CUInt program, CInt location, usz count, bool transpose, float * value) @extern("glProgramUniformMatrix4x2fv");
fn void programUniformMatrix4x3dv (CUInt program, CInt location, usz count, bool transpose, double * value) @extern("glProgramUniformMatrix4x3dv");
fn void programUniformMatrix4x3fv (CUInt program, CInt location, usz count, bool transpose, float * value) @extern("glProgramUniformMatrix4x3fv");
fn void provokingVertex (GLenum mode) @extern("glProvokingVertex");
fn void pushAttrib (GLbitfield mask) @extern("glPushAttrib");
fn void pushClientAttrib (GLbitfield mask) @extern("glPushClientAttrib");
fn void pushDebugGroup (GLenum source, CUInt id, usz length, char * message) @extern("glPushDebugGroup");
fn void pushMatrix () @extern("glPushMatrix");
fn void pushName (CUInt name) @extern("glPushName");
fn void queryCounter (CUInt id, GLenum target) @extern("glQueryCounter");
fn void rasterPos2d (double x, double y) @extern("glRasterPos2d");
fn void rasterPos2dv (double * v) @extern("glRasterPos2dv");
fn void rasterPos2f (float x, float y) @extern("glRasterPos2f");
fn void rasterPos2fv (float * v) @extern("glRasterPos2fv");
fn void rasterPos2i (CInt x, CInt y) @extern("glRasterPos2i");
fn void rasterPos2iv (CInt * v) @extern("glRasterPos2iv");
fn void rasterPos2s (short x, short y) @extern("glRasterPos2s");
fn void rasterPos2sv (short * v) @extern("glRasterPos2sv");
fn void rasterPos3d (double x, double y, double z) @extern("glRasterPos3d");
fn void rasterPos3dv (double * v) @extern("glRasterPos3dv");
fn void rasterPos3f (float x, float y, float z) @extern("glRasterPos3f");
fn void rasterPos3fv (float * v) @extern("glRasterPos3fv");
fn void rasterPos3i (CInt x, CInt y, CInt z) @extern("glRasterPos3i");
fn void rasterPos3iv (CInt * v) @extern("glRasterPos3iv");
fn void rasterPos3s (short x, short y, short z) @extern("glRasterPos3s");
fn void rasterPos3sv (short * v) @extern("glRasterPos3sv");
fn void rasterPos4d (double x, double y, double z, double w) @extern("glRasterPos4d");
fn void rasterPos4dv (double * v) @extern("glRasterPos4dv");
fn void rasterPos4f (float x, float y, float z, float w) @extern("glRasterPos4f");
fn void rasterPos4fv (float * v) @extern("glRasterPos4fv");
fn void rasterPos4i (CInt x, CInt y, CInt z, CInt w) @extern("glRasterPos4i");
fn void rasterPos4iv (CInt * v) @extern("glRasterPos4iv");
fn void rasterPos4s (short x, short y, short z, short w) @extern("glRasterPos4s");
fn void rasterPos4sv (short * v) @extern("glRasterPos4sv");
fn void readBuffer (GLenum src) @extern("glReadBuffer");
fn void readPixels (CInt x, CInt y, usz width, usz height, GLenum format, GLenum type, void * pixels) @extern("glReadPixels");
fn void rectd (double x1, double y1, double x2, double y2) @extern("glRectd");
fn void rectdv (double * v1, double * v2) @extern("glRectdv");
fn void rectf (float x1, float y1, float x2, float y2) @extern("glRectf");
fn void rectfv (float * v1, float * v2) @extern("glRectfv");
fn void recti (CInt x1, CInt y1, CInt x2, CInt y2) @extern("glRecti");
fn void rectiv (CInt * v1, CInt * v2) @extern("glRectiv");
fn void rects (short x1, short y1, short x2, short y2) @extern("glRects");
fn void rectsv (short * v1, short * v2) @extern("glRectsv");
fn void releaseShaderCompiler () @extern("glReleaseShaderCompiler");
fn CInt renderMode (GLenum mode) @extern("glRenderMode");
fn void renderbufferStorage (GLenum target, GLenum internalformat, usz width, usz height) @extern("glRenderbufferStorage");
fn void renderbufferStorageMultisample (GLenum target, usz samples, GLenum internalformat, usz width, usz height) @extern("glRenderbufferStorageMultisample");
fn void resumeTransformFeedback () @extern("glResumeTransformFeedback");
fn void rotated (double angle, double x, double y, double z) @extern("glRotated");
fn void rotatef (float angle, float x, float y, float z) @extern("glRotatef");
fn void sampleCoverage (float value, bool invert) @extern("glSampleCoverage");
fn void sampleMaski (CUInt maskNumber, GLbitfield mask) @extern("glSampleMaski");
fn void samplerParameterIiv (CUInt sampler, GLenum pname, CInt * param) @extern("glSamplerParameterIiv");
fn void samplerParameterIuiv (CUInt sampler, GLenum pname, CUInt * param) @extern("glSamplerParameterIuiv");
fn void samplerParameterf (CUInt sampler, GLenum pname, float param) @extern("glSamplerParameterf");
fn void samplerParameterfv (CUInt sampler, GLenum pname, float * param) @extern("glSamplerParameterfv");
fn void samplerParameteri (CUInt sampler, GLenum pname, CInt param) @extern("glSamplerParameteri");
fn void samplerParameteriv (CUInt sampler, GLenum pname, CInt * param) @extern("glSamplerParameteriv");
fn void scaled (double x, double y, double z) @extern("glScaled");
fn void scalef (float x, float y, float z) @extern("glScalef");
fn void scissor (CInt x, CInt y, usz width, usz height) @extern("glScissor");
fn void scissorArrayv (CUInt first, usz count, CInt * v) @extern("glScissorArrayv");
fn void scissorIndexed (CUInt index, CInt left, CInt bottom, usz width, usz height) @extern("glScissorIndexed");
fn void scissorIndexedv (CUInt index, CInt * v) @extern("glScissorIndexedv");
fn void secondaryColor3b (ichar red, ichar green, ichar blue) @extern("glSecondaryColor3b");
fn void secondaryColor3bv (ichar * v) @extern("glSecondaryColor3bv");
fn void secondaryColor3d (double red, double green, double blue) @extern("glSecondaryColor3d");
fn void secondaryColor3dv (double * v) @extern("glSecondaryColor3dv");
fn void secondaryColor3f (float red, float green, float blue) @extern("glSecondaryColor3f");
fn void secondaryColor3fv (float * v) @extern("glSecondaryColor3fv");
fn void secondaryColor3i (CInt red, CInt green, CInt blue) @extern("glSecondaryColor3i");
fn void secondaryColor3iv (CInt * v) @extern("glSecondaryColor3iv");
fn void secondaryColor3s (short red, short green, short blue) @extern("glSecondaryColor3s");
fn void secondaryColor3sv (short * v) @extern("glSecondaryColor3sv");
fn void secondaryColor3ub (char red, char green, char blue) @extern("glSecondaryColor3ub");
fn void secondaryColor3ubv (char * v) @extern("glSecondaryColor3ubv");
fn void secondaryColor3ui (CUInt red, CUInt green, CUInt blue) @extern("glSecondaryColor3ui");
fn void secondaryColor3uiv (CUInt * v) @extern("glSecondaryColor3uiv");
fn void secondaryColor3us (ushort red, ushort green, ushort blue) @extern("glSecondaryColor3us");
fn void secondaryColor3usv (ushort * v) @extern("glSecondaryColor3usv");
fn void secondaryColorP3ui (GLenum type, CUInt color) @extern("glSecondaryColorP3ui");
fn void secondaryColorP3uiv (GLenum type, CUInt * color) @extern("glSecondaryColorP3uiv");
fn void secondaryColorPointer (CInt size, GLenum type, usz stride, void * pointer) @extern("glSecondaryColorPointer");
fn void selectBuffer (usz size, CUInt * buffer) @extern("glSelectBuffer");
fn void shadeModel (GLenum mode) @extern("glShadeModel");
fn void shaderBinary (usz count, CUInt * shaders, GLenum binaryFormat, void * binary, usz length) @extern("glShaderBinary");
fn void shaderSource (CUInt shader, usz count, char ** string, CInt * length) @extern("glShaderSource");
fn void shaderStorageBlockBinding (CUInt program, CUInt storageBlockIndex, CUInt storageBlockBinding) @extern("glShaderStorageBlockBinding");
fn void stencilFunc (GLenum func, CInt ref, CUInt mask) @extern("glStencilFunc");
fn void stencilFuncSeparate (GLenum face, GLenum func, CInt ref, CUInt mask) @extern("glStencilFuncSeparate");
fn void stencilMask (CUInt mask) @extern("glStencilMask");
fn void stencilMaskSeparate (GLenum face, CUInt mask) @extern("glStencilMaskSeparate");
fn void stencilOp (GLenum fail, GLenum zfail, GLenum zpass) @extern("glStencilOp");
fn void stencilOpSeparate (GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass) @extern("glStencilOpSeparate");
fn void texBuffer (GLenum target, GLenum internalformat, CUInt buffer) @extern("glTexBuffer");
fn void texBufferRange (GLenum target, GLenum internalformat, CUInt buffer, iptr offset, uptr size) @extern("glTexBufferRange");
fn void texCoord1d (double s) @extern("glTexCoord1d");
fn void texCoord1dv (double * v) @extern("glTexCoord1dv");
fn void texCoord1f (float s) @extern("glTexCoord1f");
fn void texCoord1fv (float * v) @extern("glTexCoord1fv");
fn void texCoord1i (CInt s) @extern("glTexCoord1i");
fn void texCoord1iv (CInt * v) @extern("glTexCoord1iv");
fn void texCoord1s (short s) @extern("glTexCoord1s");
fn void texCoord1sv (short * v) @extern("glTexCoord1sv");
fn void texCoord2d (double s, double t) @extern("glTexCoord2d");
fn void texCoord2dv (double * v) @extern("glTexCoord2dv");
fn void texCoord2f (float s, float t) @extern("glTexCoord2f");
fn void texCoord2fv (float * v) @extern("glTexCoord2fv");
fn void texCoord2i (CInt s, CInt t) @extern("glTexCoord2i");
fn void texCoord2iv (CInt * v) @extern("glTexCoord2iv");
fn void texCoord2s (short s, short t) @extern("glTexCoord2s");
fn void texCoord2sv (short * v) @extern("glTexCoord2sv");
fn void texCoord3d (double s, double t, double r) @extern("glTexCoord3d");
fn void texCoord3dv (double * v) @extern("glTexCoord3dv");
fn void texCoord3f (float s, float t, float r) @extern("glTexCoord3f");
fn void texCoord3fv (float * v) @extern("glTexCoord3fv");
fn void texCoord3i (CInt s, CInt t, CInt r) @extern("glTexCoord3i");
fn void texCoord3iv (CInt * v) @extern("glTexCoord3iv");
fn void texCoord3s (short s, short t, short r) @extern("glTexCoord3s");
fn void texCoord3sv (short * v) @extern("glTexCoord3sv");
fn void texCoord4d (double s, double t, double r, double q) @extern("glTexCoord4d");
fn void texCoord4dv (double * v) @extern("glTexCoord4dv");
fn void texCoord4f (float s, float t, float r, float q) @extern("glTexCoord4f");
fn void texCoord4fv (float * v) @extern("glTexCoord4fv");
fn void texCoord4i (CInt s, CInt t, CInt r, CInt q) @extern("glTexCoord4i");
fn void texCoord4iv (CInt * v) @extern("glTexCoord4iv");
fn void texCoord4s (short s, short t, short r, short q) @extern("glTexCoord4s");
fn void texCoord4sv (short * v) @extern("glTexCoord4sv");
fn void texCoordP1ui (GLenum type, CUInt coords) @extern("glTexCoordP1ui");
fn void texCoordP1uiv (GLenum type, CUInt * coords) @extern("glTexCoordP1uiv");
fn void texCoordP2ui (GLenum type, CUInt coords) @extern("glTexCoordP2ui");
fn void texCoordP2uiv (GLenum type, CUInt * coords) @extern("glTexCoordP2uiv");
fn void texCoordP3ui (GLenum type, CUInt coords) @extern("glTexCoordP3ui");
fn void texCoordP3uiv (GLenum type, CUInt * coords) @extern("glTexCoordP3uiv");
fn void texCoordP4ui (GLenum type, CUInt coords) @extern("glTexCoordP4ui");
fn void texCoordP4uiv (GLenum type, CUInt * coords) @extern("glTexCoordP4uiv");
fn void texCoordPointer (CInt size, GLenum type, usz stride, void * pointer) @extern("glTexCoordPointer");
fn void texEnvf (GLenum target, GLenum pname, float param) @extern("glTexEnvf");
fn void texEnvfv (GLenum target, GLenum pname, float * params) @extern("glTexEnvfv");
fn void texEnvi (GLenum target, GLenum pname, CInt param) @extern("glTexEnvi");
fn void texEnviv (GLenum target, GLenum pname, CInt * params) @extern("glTexEnviv");
fn void texGend (GLenum coord, GLenum pname, double param) @extern("glTexGend");
fn void texGendv (GLenum coord, GLenum pname, double * params) @extern("glTexGendv");
fn void texGenf (GLenum coord, GLenum pname, float param) @extern("glTexGenf");
fn void texGenfv (GLenum coord, GLenum pname, float * params) @extern("glTexGenfv");
fn void texGeni (GLenum coord, GLenum pname, CInt param) @extern("glTexGeni");
fn void texGeniv (GLenum coord, GLenum pname, CInt * params) @extern("glTexGeniv");
fn void texImage1D (GLenum target, CInt level, CInt internalformat, usz width, CInt border, GLenum format, GLenum type, void * pixels) @extern("glTexImage1D");
fn void texImage2D (GLenum target, CInt level, CInt internalformat, usz width, usz height, CInt border, GLenum format, GLenum type, void * pixels) @extern("glTexImage2D");
fn void texImage2DMultisample (GLenum target, usz samples, GLenum internalformat, usz width, usz height, bool fixedsamplelocations) @extern("glTexImage2DMultisample");
fn void texImage3D (GLenum target, CInt level, CInt internalformat, usz width, usz height, usz depth, CInt border, GLenum format, GLenum type, void * pixels) @extern("glTexImage3D");
fn void texImage3DMultisample (GLenum target, usz samples, GLenum internalformat, usz width, usz height, usz depth, bool fixedsamplelocations) @extern("glTexImage3DMultisample");
fn void texParameterIiv (GLenum target, GLenum pname, CInt * params) @extern("glTexParameterIiv");
fn void texParameterIuiv (GLenum target, GLenum pname, CUInt * params) @extern("glTexParameterIuiv");
fn void texParameterf (GLenum target, GLenum pname, float param) @extern("glTexParameterf");
fn void texParameterfv (GLenum target, GLenum pname, float * params) @extern("glTexParameterfv");
fn void texParameteri (GLenum target, GLenum pname, CInt param) @extern("glTexParameteri");
fn void texParameteriv (GLenum target, GLenum pname, CInt * params) @extern("glTexParameteriv");
fn void texStorage1D (GLenum target, usz levels, GLenum internalformat, usz width) @extern("glTexStorage1D");
fn void texStorage2D (GLenum target, usz levels, GLenum internalformat, usz width, usz height) @extern("glTexStorage2D");
fn void texStorage2DMultisample (GLenum target, usz samples, GLenum internalformat, usz width, usz height, bool fixedsamplelocations) @extern("glTexStorage2DMultisample");
fn void texStorage3D (GLenum target, usz levels, GLenum internalformat, usz width, usz height, usz depth) @extern("glTexStorage3D");
fn void texStorage3DMultisample (GLenum target, usz samples, GLenum internalformat, usz width, usz height, usz depth, bool fixedsamplelocations) @extern("glTexStorage3DMultisample");
fn void texSubImage1D (GLenum target, CInt level, CInt xoffset, usz width, GLenum format, GLenum type, void * pixels) @extern("glTexSubImage1D");
fn void texSubImage2D (GLenum target, CInt level, CInt xoffset, CInt yoffset, usz width, usz height, GLenum format, GLenum type, void * pixels) @extern("glTexSubImage2D");
fn void texSubImage3D (GLenum target, CInt level, CInt xoffset, CInt yoffset, CInt zoffset, usz width, usz height, usz depth, GLenum format, GLenum type, void * pixels) @extern("glTexSubImage3D");
fn void textureView (CUInt texture, GLenum target, CUInt origtexture, GLenum internalformat, CUInt minlevel, CUInt numlevels, CUInt minlayer, CUInt numlayers) @extern("glTextureView");
fn void transformFeedbackVaryings (CUInt program, usz count, char ** varyings, GLenum bufferMode) @extern("glTransformFeedbackVaryings");
fn void translated (double x, double y, double z) @extern("glTranslated");
fn void translatef (float x, float y, float z) @extern("glTranslatef");
fn void uniform1d (CInt location, double x) @extern("glUniform1d");
fn void uniform1dv (CInt location, usz count, double * value) @extern("glUniform1dv");
fn void uniform1f (CInt location, float v0) @extern("glUniform1f");
fn void uniform1fv (CInt location, usz count, float * value) @extern("glUniform1fv");
fn void uniform1i (CInt location, CInt v0) @extern("glUniform1i");
fn void uniform1iv (CInt location, usz count, CInt * value) @extern("glUniform1iv");
fn void uniform1ui (CInt location, CUInt v0) @extern("glUniform1ui");
fn void uniform1uiv (CInt location, usz count, CUInt * value) @extern("glUniform1uiv");
fn void uniform2d (CInt location, double x, double y) @extern("glUniform2d");
fn void uniform2dv (CInt location, usz count, double * value) @extern("glUniform2dv");
fn void uniform2f (CInt location, float v0, float v1) @extern("glUniform2f");
fn void uniform2fv (CInt location, usz count, float * value) @extern("glUniform2fv");
fn void uniform2i (CInt location, CInt v0, CInt v1) @extern("glUniform2i");
fn void uniform2iv (CInt location, usz count, CInt * value) @extern("glUniform2iv");
fn void uniform2ui (CInt location, CUInt v0, CUInt v1) @extern("glUniform2ui");
fn void uniform2uiv (CInt location, usz count, CUInt * value) @extern("glUniform2uiv");
fn void uniform3d (CInt location, double x, double y, double z) @extern("glUniform3d");
fn void uniform3dv (CInt location, usz count, double * value) @extern("glUniform3dv");
fn void uniform3f (CInt location, float v0, float v1, float v2) @extern("glUniform3f");
fn void uniform3fv (CInt location, usz count, float * value) @extern("glUniform3fv");
fn void uniform3i (CInt location, CInt v0, CInt v1, CInt v2) @extern("glUniform3i");
fn void uniform3iv (CInt location, usz count, CInt * value) @extern("glUniform3iv");
fn void uniform3ui (CInt location, CUInt v0, CUInt v1, CUInt v2) @extern("glUniform3ui");
fn void uniform3uiv (CInt location, usz count, CUInt * value) @extern("glUniform3uiv");
fn void uniform4d (CInt location, double x, double y, double z, double w) @extern("glUniform4d");
fn void uniform4dv (CInt location, usz count, double * value) @extern("glUniform4dv");
fn void uniform4f (CInt location, float v0, float v1, float v2, float v3) @extern("glUniform4f");
fn void uniform4fv (CInt location, usz count, float * value) @extern("glUniform4fv");
fn void uniform4i (CInt location, CInt v0, CInt v1, CInt v2, CInt v3) @extern("glUniform4i");
fn void uniform4iv (CInt location, usz count, CInt * value) @extern("glUniform4iv");
fn void uniform4ui (CInt location, CUInt v0, CUInt v1, CUInt v2, CUInt v3) @extern("glUniform4ui");
fn void uniform4uiv (CInt location, usz count, CUInt * value) @extern("glUniform4uiv");
fn void uniformBlockBinding (CUInt program, CUInt uniformBlockIndex, CUInt uniformBlockBinding) @extern("glUniformBlockBinding");
fn void uniformMatrix2dv (CInt location, usz count, bool transpose, double * value) @extern("glUniformMatrix2dv");
fn void uniformMatrix2fv (CInt location, usz count, bool transpose, float * value) @extern("glUniformMatrix2fv");
fn void uniformMatrix2x3dv (CInt location, usz count, bool transpose, double * value) @extern("glUniformMatrix2x3dv");
fn void uniformMatrix2x3fv (CInt location, usz count, bool transpose, float * value) @extern("glUniformMatrix2x3fv");
fn void uniformMatrix2x4dv (CInt location, usz count, bool transpose, double * value) @extern("glUniformMatrix2x4dv");
fn void uniformMatrix2x4fv (CInt location, usz count, bool transpose, float * value) @extern("glUniformMatrix2x4fv");
fn void uniformMatrix3dv (CInt location, usz count, bool transpose, double * value) @extern("glUniformMatrix3dv");
fn void uniformMatrix3fv (CInt location, usz count, bool transpose, float * value) @extern("glUniformMatrix3fv");
fn void uniformMatrix3x2dv (CInt location, usz count, bool transpose, double * value) @extern("glUniformMatrix3x2dv");
fn void uniformMatrix3x2fv (CInt location, usz count, bool transpose, float * value) @extern("glUniformMatrix3x2fv");
fn void uniformMatrix3x4dv (CInt location, usz count, bool transpose, double * value) @extern("glUniformMatrix3x4dv");
fn void uniformMatrix3x4fv (CInt location, usz count, bool transpose, float * value) @extern("glUniformMatrix3x4fv");
fn void uniformMatrix4dv (CInt location, usz count, bool transpose, double * value) @extern("glUniformMatrix4dv");
fn void uniformMatrix4fv (CInt location, usz count, bool transpose, float * value) @extern("glUniformMatrix4fv");
fn void uniformMatrix4x2dv (CInt location, usz count, bool transpose, double * value) @extern("glUniformMatrix4x2dv");
fn void uniformMatrix4x2fv (CInt location, usz count, bool transpose, float * value) @extern("glUniformMatrix4x2fv");
fn void uniformMatrix4x3dv (CInt location, usz count, bool transpose, double * value) @extern("glUniformMatrix4x3dv");
fn void uniformMatrix4x3fv (CInt location, usz count, bool transpose, float * value) @extern("glUniformMatrix4x3fv");
fn void uniformSubroutinesuiv (GLenum shadertype, usz count, CUInt * indices) @extern("glUniformSubroutinesuiv");
fn bool unmapBuffer (GLenum target) @extern("glUnmapBuffer");
fn void useProgram (CUInt program) @extern("glUseProgram");
fn void useProgramStages (CUInt pipeline, GLbitfield stages, CUInt program) @extern("glUseProgramStages");
fn void validateProgram (CUInt program) @extern("glValidateProgram");
fn void validateProgramPipeline (CUInt pipeline) @extern("glValidateProgramPipeline");
fn void vertex2d (double x, double y) @extern("glVertex2d");
fn void vertex2dv (double * v) @extern("glVertex2dv");
fn void vertex2f (float x, float y) @extern("glVertex2f");
fn void vertex2fv (float * v) @extern("glVertex2fv");
fn void vertex2i (CInt x, CInt y) @extern("glVertex2i");
fn void vertex2iv (CInt * v) @extern("glVertex2iv");
fn void vertex2s (short x, short y) @extern("glVertex2s");
fn void vertex2sv (short * v) @extern("glVertex2sv");
fn void vertex3d (double x, double y, double z) @extern("glVertex3d");
fn void vertex3dv (double * v) @extern("glVertex3dv");
fn void vertex3f (float x, float y, float z) @extern("glVertex3f");
fn void vertex3fv (float * v) @extern("glVertex3fv");
fn void vertex3i (CInt x, CInt y, CInt z) @extern("glVertex3i");
fn void vertex3iv (CInt * v) @extern("glVertex3iv");
fn void vertex3s (short x, short y, short z) @extern("glVertex3s");
fn void vertex3sv (short * v) @extern("glVertex3sv");
fn void vertex4d (double x, double y, double z, double w) @extern("glVertex4d");
fn void vertex4dv (double * v) @extern("glVertex4dv");
fn void vertex4f (float x, float y, float z, float w) @extern("glVertex4f");
fn void vertex4fv (float * v) @extern("glVertex4fv");
fn void vertex4i (CInt x, CInt y, CInt z, CInt w) @extern("glVertex4i");
fn void vertex4iv (CInt * v) @extern("glVertex4iv");
fn void vertex4s (short x, short y, short z, short w) @extern("glVertex4s");
fn void vertex4sv (short * v) @extern("glVertex4sv");
fn void vertexAttrib1d (CUInt index, double x) @extern("glVertexAttrib1d");
fn void vertexAttrib1dv (CUInt index, double * v) @extern("glVertexAttrib1dv");
fn void vertexAttrib1f (CUInt index, float x) @extern("glVertexAttrib1f");
fn void vertexAttrib1fv (CUInt index, float * v) @extern("glVertexAttrib1fv");
fn void vertexAttrib1s (CUInt index, short x) @extern("glVertexAttrib1s");
fn void vertexAttrib1sv (CUInt index, short * v) @extern("glVertexAttrib1sv");
fn void vertexAttrib2d (CUInt index, double x, double y) @extern("glVertexAttrib2d");
fn void vertexAttrib2dv (CUInt index, double * v) @extern("glVertexAttrib2dv");
fn void vertexAttrib2f (CUInt index, float x, float y) @extern("glVertexAttrib2f");
fn void vertexAttrib2fv (CUInt index, float * v) @extern("glVertexAttrib2fv");
fn void vertexAttrib2s (CUInt index, short x, short y) @extern("glVertexAttrib2s");
fn void vertexAttrib2sv (CUInt index, short * v) @extern("glVertexAttrib2sv");
fn void vertexAttrib3d (CUInt index, double x, double y, double z) @extern("glVertexAttrib3d");
fn void vertexAttrib3dv (CUInt index, double * v) @extern("glVertexAttrib3dv");
fn void vertexAttrib3f (CUInt index, float x, float y, float z) @extern("glVertexAttrib3f");
fn void vertexAttrib3fv (CUInt index, float * v) @extern("glVertexAttrib3fv");
fn void vertexAttrib3s (CUInt index, short x, short y, short z) @extern("glVertexAttrib3s");
fn void vertexAttrib3sv (CUInt index, short * v) @extern("glVertexAttrib3sv");
fn void vertexAttrib4Nbv (CUInt index, ichar * v) @extern("glVertexAttrib4Nbv");
fn void vertexAttrib4Niv (CUInt index, CInt * v) @extern("glVertexAttrib4Niv");
fn void vertexAttrib4Nsv (CUInt index, short * v) @extern("glVertexAttrib4Nsv");
fn void vertexAttrib4Nub (CUInt index, char x, char y, char z, char w) @extern("glVertexAttrib4Nub");
fn void vertexAttrib4Nubv (CUInt index, char * v) @extern("glVertexAttrib4Nubv");
fn void vertexAttrib4Nuiv (CUInt index, CUInt * v) @extern("glVertexAttrib4Nuiv");
fn void vertexAttrib4Nusv (CUInt index, ushort * v) @extern("glVertexAttrib4Nusv");
fn void vertexAttrib4bv (CUInt index, ichar * v) @extern("glVertexAttrib4bv");
fn void vertexAttrib4d (CUInt index, double x, double y, double z, double w) @extern("glVertexAttrib4d");
fn void vertexAttrib4dv (CUInt index, double * v) @extern("glVertexAttrib4dv");
fn void vertexAttrib4f (CUInt index, float x, float y, float z, float w) @extern("glVertexAttrib4f");
fn void vertexAttrib4fv (CUInt index, float * v) @extern("glVertexAttrib4fv");
fn void vertexAttrib4iv (CUInt index, CInt * v) @extern("glVertexAttrib4iv");
fn void vertexAttrib4s (CUInt index, short x, short y, short z, short w) @extern("glVertexAttrib4s");
fn void vertexAttrib4sv (CUInt index, short * v) @extern("glVertexAttrib4sv");
fn void vertexAttrib4ubv (CUInt index, char * v) @extern("glVertexAttrib4ubv");
fn void vertexAttrib4uiv (CUInt index, CUInt * v) @extern("glVertexAttrib4uiv");
fn void vertexAttrib4usv (CUInt index, ushort * v) @extern("glVertexAttrib4usv");
fn void vertexAttribBinding (CUInt attribindex, CUInt bindingindex) @extern("glVertexAttribBinding");
fn void vertexAttribDivisor (CUInt index, CUInt divisor) @extern("glVertexAttribDivisor");
fn void vertexAttribFormat (CUInt attribindex, CInt size, GLenum type, bool normalized, CUInt relativeoffset) @extern("glVertexAttribFormat");
fn void vertexAttribI1i (CUInt index, CInt x) @extern("glVertexAttribI1i");
fn void vertexAttribI1iv (CUInt index, CInt * v) @extern("glVertexAttribI1iv");
fn void vertexAttribI1ui (CUInt index, CUInt x) @extern("glVertexAttribI1ui");
fn void vertexAttribI1uiv (CUInt index, CUInt * v) @extern("glVertexAttribI1uiv");
fn void vertexAttribI2i (CUInt index, CInt x, CInt y) @extern("glVertexAttribI2i");
fn void vertexAttribI2iv (CUInt index, CInt * v) @extern("glVertexAttribI2iv");
fn void vertexAttribI2ui (CUInt index, CUInt x, CUInt y) @extern("glVertexAttribI2ui");
fn void vertexAttribI2uiv (CUInt index, CUInt * v) @extern("glVertexAttribI2uiv");
fn void vertexAttribI3i (CUInt index, CInt x, CInt y, CInt z) @extern("glVertexAttribI3i");
fn void vertexAttribI3iv (CUInt index, CInt * v) @extern("glVertexAttribI3iv");
fn void vertexAttribI3ui (CUInt index, CUInt x, CUInt y, CUInt z) @extern("glVertexAttribI3ui");
fn void vertexAttribI3uiv (CUInt index, CUInt * v) @extern("glVertexAttribI3uiv");
fn void vertexAttribI4bv (CUInt index, ichar * v) @extern("glVertexAttribI4bv");
fn void vertexAttribI4i (CUInt index, CInt x, CInt y, CInt z, CInt w) @extern("glVertexAttribI4i");
fn void vertexAttribI4iv (CUInt index, CInt * v) @extern("glVertexAttribI4iv");
fn void vertexAttribI4sv (CUInt index, short * v) @extern("glVertexAttribI4sv");
fn void vertexAttribI4ubv (CUInt index, char * v) @extern("glVertexAttribI4ubv");
fn void vertexAttribI4ui (CUInt index, CUInt x, CUInt y, CUInt z, CUInt w) @extern("glVertexAttribI4ui");
fn void vertexAttribI4uiv (CUInt index, CUInt * v) @extern("glVertexAttribI4uiv");
fn void vertexAttribI4usv (CUInt index, ushort * v) @extern("glVertexAttribI4usv");
fn void vertexAttribIFormat (CUInt attribindex, CInt size, GLenum type, CUInt relativeoffset) @extern("glVertexAttribIFormat");
fn void vertexAttribIPointer (CUInt index, CInt size, GLenum type, usz stride, void * pointer) @extern("glVertexAttribIPointer");
fn void vertexAttribL1d (CUInt index, double x) @extern("glVertexAttribL1d");
fn void vertexAttribL1dv (CUInt index, double * v) @extern("glVertexAttribL1dv");
fn void vertexAttribL2d (CUInt index, double x, double y) @extern("glVertexAttribL2d");
fn void vertexAttribL2dv (CUInt index, double * v) @extern("glVertexAttribL2dv");
fn void vertexAttribL3d (CUInt index, double x, double y, double z) @extern("glVertexAttribL3d");
fn void vertexAttribL3dv (CUInt index, double * v) @extern("glVertexAttribL3dv");
fn void vertexAttribL4d (CUInt index, double x, double y, double z, double w) @extern("glVertexAttribL4d");
fn void vertexAttribL4dv (CUInt index, double * v) @extern("glVertexAttribL4dv");
fn void vertexAttribLFormat (CUInt attribindex, CInt size, GLenum type, CUInt relativeoffset) @extern("glVertexAttribLFormat");
fn void vertexAttribLPointer (CUInt index, CInt size, GLenum type, usz stride, void * pointer) @extern("glVertexAttribLPointer");
fn void vertexAttribP1ui (CUInt index, GLenum type, bool normalized, CUInt value) @extern("glVertexAttribP1ui");
fn void vertexAttribP1uiv (CUInt index, GLenum type, bool normalized, CUInt * value) @extern("glVertexAttribP1uiv");
fn void vertexAttribP2ui (CUInt index, GLenum type, bool normalized, CUInt value) @extern("glVertexAttribP2ui");
fn void vertexAttribP2uiv (CUInt index, GLenum type, bool normalized, CUInt * value) @extern("glVertexAttribP2uiv");
fn void vertexAttribP3ui (CUInt index, GLenum type, bool normalized, CUInt value) @extern("glVertexAttribP3ui");
fn void vertexAttribP3uiv (CUInt index, GLenum type, bool normalized, CUInt * value) @extern("glVertexAttribP3uiv");
fn void vertexAttribP4ui (CUInt index, GLenum type, bool normalized, CUInt value) @extern("glVertexAttribP4ui");
fn void vertexAttribP4uiv (CUInt index, GLenum type, bool normalized, CUInt * value) @extern("glVertexAttribP4uiv");
fn void vertexAttribPointer (CUInt index, CInt size, GLenum type, bool normalized, usz stride, void * pointer) @extern("glVertexAttribPointer");
fn void vertexBindingDivisor (CUInt bindingindex, CUInt divisor) @extern("glVertexBindingDivisor");
fn void vertexP2ui (GLenum type, CUInt value) @extern("glVertexP2ui");
fn void vertexP2uiv (GLenum type, CUInt * value) @extern("glVertexP2uiv");
fn void vertexP3ui (GLenum type, CUInt value) @extern("glVertexP3ui");
fn void vertexP3uiv (GLenum type, CUInt * value) @extern("glVertexP3uiv");
fn void vertexP4ui (GLenum type, CUInt value) @extern("glVertexP4ui");
fn void vertexP4uiv (GLenum type, CUInt * value) @extern("glVertexP4uiv");
fn void vertexPointer (CInt size, GLenum type, usz stride, void * pointer) @extern("glVertexPointer");
fn void viewport (CInt x, CInt y, usz width, usz height) @extern("glViewport");
fn void viewportArrayv (CUInt first, usz count, float * v) @extern("glViewportArrayv");
fn void viewportIndexedf (CUInt index, float x, float y, float w, float h) @extern("glViewportIndexedf");
fn void viewportIndexedfv (CUInt index, float * v) @extern("glViewportIndexedfv");
fn void waitSync (GLsync sync, GLbitfield flags, ulong timeout) @extern("glWaitSync");
fn void windowPos2d (double x, double y) @extern("glWindowPos2d");
fn void windowPos2dv (double * v) @extern("glWindowPos2dv");
fn void windowPos2f (float x, float y) @extern("glWindowPos2f");
fn void windowPos2fv (float * v) @extern("glWindowPos2fv");
fn void windowPos2i (CInt x, CInt y) @extern("glWindowPos2i");
fn void windowPos2iv (CInt * v) @extern("glWindowPos2iv");
fn void windowPos2s (short x, short y) @extern("glWindowPos2s");
fn void windowPos2sv (short * v) @extern("glWindowPos2sv");
fn void windowPos3d (double x, double y, double z) @extern("glWindowPos3d");
fn void windowPos3dv (double * v) @extern("glWindowPos3dv");
fn void windowPos3f (float x, float y, float z) @extern("glWindowPos3f");
fn void windowPos3fv (float * v) @extern("glWindowPos3fv");
fn void windowPos3i (CInt x, CInt y, CInt z) @extern("glWindowPos3i");
fn void windowPos3iv (CInt * v) @extern("glWindowPos3iv");
fn void windowPos3s (short x, short y, short z) @extern("glWindowPos3s");
fn void windowPos3sv (short * v) @extern("glWindowPos3sv");


