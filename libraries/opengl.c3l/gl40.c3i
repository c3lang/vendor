module opengl::gl40;
import opengl;

/*=====Constants=====*/

const GL_SAMPLE_SHADING                 = 0x8C36;
const GL_MIN_SAMPLE_SHADING_VALUE       = 0x8C37;
const GL_MIN_PROGRAM_TEXTURE_GATHER_OFFSET = 0x8E5E;
const GL_MAX_PROGRAM_TEXTURE_GATHER_OFFSET = 0x8E5F;
const GL_TEXTURE_CUBE_MAP_ARRAY         = 0x9009;
const GL_TEXTURE_BINDING_CUBE_MAP_ARRAY = 0x900A;
const GL_PROXY_TEXTURE_CUBE_MAP_ARRAY   = 0x900B;
const GL_SAMPLER_CUBE_MAP_ARRAY         = 0x900C;
const GL_SAMPLER_CUBE_MAP_ARRAY_SHADOW  = 0x900D;
const GL_INT_SAMPLER_CUBE_MAP_ARRAY     = 0x900E;
const GL_UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY = 0x900F;
const GL_DRAW_INDIRECT_BUFFER           = 0x8F3F;
const GL_DRAW_INDIRECT_BUFFER_BINDING   = 0x8F43;
const GL_GEOMETRY_SHADER_INVOCATIONS    = 0x887F;
const GL_MAX_GEOMETRY_SHADER_INVOCATIONS = 0x8E5A;
const GL_MIN_FRAGMENT_INTERPOLATION_OFFSET = 0x8E5B;
const GL_MAX_FRAGMENT_INTERPOLATION_OFFSET = 0x8E5C;
const GL_FRAGMENT_INTERPOLATION_OFFSET_BITS = 0x8E5D;
const GL_MAX_VERTEX_STREAMS             = 0x8E71;
const GL_DOUBLE_VEC2                    = 0x8FFC;
const GL_DOUBLE_VEC3                    = 0x8FFD;
const GL_DOUBLE_VEC4                    = 0x8FFE;
const GL_DOUBLE_MAT2                    = 0x8F46;
const GL_DOUBLE_MAT3                    = 0x8F47;
const GL_DOUBLE_MAT4                    = 0x8F48;
const GL_DOUBLE_MAT2X3                  = 0x8F49;
const GL_DOUBLE_MAT2X4                  = 0x8F4A;
const GL_DOUBLE_MAT3X2                  = 0x8F4B;
const GL_DOUBLE_MAT3X4                  = 0x8F4C;
const GL_DOUBLE_MAT4X2                  = 0x8F4D;
const GL_DOUBLE_MAT4X3                  = 0x8F4E;
const GL_ACTIVE_SUBROUTINES             = 0x8DE5;
const GL_ACTIVE_SUBROUTINE_UNIFORMS     = 0x8DE6;
const GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS = 0x8E47;
const GL_ACTIVE_SUBROUTINE_MAX_LENGTH   = 0x8E48;
const GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH = 0x8E49;
const GL_MAX_SUBROUTINES                = 0x8DE7;
const GL_MAX_SUBROUTINE_UNIFORM_LOCATIONS = 0x8DE8;
const GL_NUM_COMPATIBLE_SUBROUTINES     = 0x8E4A;
const GL_COMPATIBLE_SUBROUTINES         = 0x8E4B;
const GL_PATCHES                        = 0x000E;
const GL_PATCH_VERTICES                 = 0x8E72;
const GL_PATCH_DEFAULT_INNER_LEVEL      = 0x8E73;
const GL_PATCH_DEFAULT_OUTER_LEVEL      = 0x8E74;
const GL_TESS_CONTROL_OUTPUT_VERTICES   = 0x8E75;
const GL_TESS_GEN_MODE                  = 0x8E76;
const GL_TESS_GEN_SPACING               = 0x8E77;
const GL_TESS_GEN_VERTEX_ORDER          = 0x8E78;
const GL_TESS_GEN_POINT_MODE            = 0x8E79;
const GL_ISOLINES                       = 0x8E7A;
const GL_FRACTIONAL_ODD                 = 0x8E7B;
const GL_FRACTIONAL_EVEN                = 0x8E7C;
const GL_MAX_PATCH_VERTICES             = 0x8E7D;
const GL_MAX_TESS_GEN_LEVEL             = 0x8E7E;
const GL_MAX_TESS_CONTROL_UNIFORM_COMPONENTS = 0x8E7F;
const GL_MAX_TESS_EVALUATION_UNIFORM_COMPONENTS = 0x8E80;
const GL_MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS = 0x8E81;
const GL_MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS = 0x8E82;
const GL_MAX_TESS_CONTROL_OUTPUT_COMPONENTS = 0x8E83;
const GL_MAX_TESS_PATCH_COMPONENTS      = 0x8E84;
const GL_MAX_TESS_CONTROL_TOTAL_OUTPUT_COMPONENTS = 0x8E85;
const GL_MAX_TESS_EVALUATION_OUTPUT_COMPONENTS = 0x8E86;
const GL_MAX_TESS_CONTROL_UNIFORM_BLOCKS = 0x8E89;
const GL_MAX_TESS_EVALUATION_UNIFORM_BLOCKS = 0x8E8A;
const GL_MAX_TESS_CONTROL_INPUT_COMPONENTS = 0x886C;
const GL_MAX_TESS_EVALUATION_INPUT_COMPONENTS = 0x886D;
const GL_MAX_COMBINED_TESS_CONTROL_UNIFORM_COMPONENTS = 0x8E1E;
const GL_MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS = 0x8E1F;
const GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_CONTROL_SHADER = 0x84F0;
const GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_EVALUATION_SHADER = 0x84F1;
const GL_TESS_EVALUATION_SHADER         = 0x8E87;
const GL_TESS_CONTROL_SHADER            = 0x8E88;
const GL_TRANSFORM_FEEDBACK             = 0x8E22;
const GL_TRANSFORM_FEEDBACK_BUFFER_PAUSED = 0x8E23;
const GL_TRANSFORM_FEEDBACK_BUFFER_ACTIVE = 0x8E24;
const GL_TRANSFORM_FEEDBACK_BINDING     = 0x8E25;
const GL_MAX_TRANSFORM_FEEDBACK_BUFFERS = 0x8E70;

/*=====END=====*/

/*=====Functions=====*/

fn void minSampleShading (float value) @extern("glMinSampleShading");
fn void blendEquationi (CUInt buf, GLenum mode) @extern("glBlendEquationi");
fn void blendEquationSeparatei (CUInt buf, GLenum modeRGB, GLenum modeAlpha) @extern("glBlendEquationSeparatei");
fn void blendFunci (CUInt buf, GLenum src, GLenum dst) @extern("glBlendFunci");
fn void blendFuncSeparatei (CUInt buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha) @extern("glBlendFuncSeparatei");
fn void drawArraysIndirect (GLenum mode, void *indirect) @extern("glDrawArraysIndirect");
fn void drawElementsIndirect (GLenum mode, GLenum type, void *indirect) @extern("glDrawElementsIndirect");
fn void uniform1d (CInt location, double x) @extern("glUniform1d");
fn void uniform2d (CInt location, double x, double y) @extern("glUniform2d");
fn void uniform3d (CInt location, double x, double y, double z) @extern("glUniform3d");
fn void uniform4d (CInt location, double x, double y, double z, double w) @extern("glUniform4d");
fn void uniform1dv (CInt location, usz count, double *value) @extern("glUniform1dv");
fn void uniform2dv (CInt location, usz count, double *value) @extern("glUniform2dv");
fn void uniform3dv (CInt location, usz count, double *value) @extern("glUniform3dv");
fn void uniform4dv (CInt location, usz count, double *value) @extern("glUniform4dv");
fn void uniformMatrix2dv (CInt location, usz count, bool transpose, double *value) @extern("glUniformMatrix2dv");
fn void uniformMatrix3dv (CInt location, usz count, bool transpose, double *value) @extern("glUniformMatrix3dv");
fn void uniformMatrix4dv (CInt location, usz count, bool transpose, double *value) @extern("glUniformMatrix4dv");
fn void uniformMatrix2x3dv (CInt location, usz count, bool transpose, double *value) @extern("glUniformMatrix2x3dv");
fn void uniformMatrix2x4dv (CInt location, usz count, bool transpose, double *value) @extern("glUniformMatrix2x4dv");
fn void uniformMatrix3x2dv (CInt location, usz count, bool transpose, double *value) @extern("glUniformMatrix3x2dv");
fn void uniformMatrix3x4dv (CInt location, usz count, bool transpose, double *value) @extern("glUniformMatrix3x4dv");
fn void uniformMatrix4x2dv (CInt location, usz count, bool transpose, double *value) @extern("glUniformMatrix4x2dv");
fn void uniformMatrix4x3dv (CInt location, usz count, bool transpose, double *value) @extern("glUniformMatrix4x3dv");
fn void getUniformdv (CUInt program, CInt location, double *params) @extern("glGetUniformdv");
fn CInt getSubroutineUniformLocation (CUInt program, GLenum shadertype, char *name) @extern("glGetSubroutineUniformLocation");
fn CUInt getSubroutineIndex (CUInt program, GLenum shadertype, char *name) @extern("glGetSubroutineIndex");
fn void getActiveSubroutineUniformiv (CUInt program, GLenum shadertype, CUInt index, GLenum pname, CInt *values) @extern("glGetActiveSubroutineUniformiv");
fn void getActiveSubroutineUniformName (CUInt program, GLenum shadertype, CUInt index, usz bufSize, usz *length, char *name) @extern("glGetActiveSubroutineUniformName");
fn void getActiveSubroutineName (CUInt program, GLenum shadertype, CUInt index, usz bufSize, usz *length, char *name) @extern("glGetActiveSubroutineName");
fn void uniformSubroutinesuiv (GLenum shadertype, usz count, CUInt *indices) @extern("glUniformSubroutinesuiv");
fn void getUniformSubroutineuiv (GLenum shadertype, CInt location, CUInt *params) @extern("glGetUniformSubroutineuiv");
fn void getProgramStageiv (CUInt program, GLenum shadertype, GLenum pname, CInt *values) @extern("glGetProgramStageiv");
fn void patchParameteri (GLenum pname, CInt value) @extern("glPatchParameteri");
fn void patchParameterfv (GLenum pname, float *values) @extern("glPatchParameterfv");
fn void bindTransformFeedback (GLenum target, CUInt id) @extern("glBindTransformFeedback");
fn void deleteTransformFeedbacks (usz n, CUInt *ids) @extern("glDeleteTransformFeedbacks");
fn void genTransformFeedbacks (usz n, CUInt *ids) @extern("glGenTransformFeedbacks");
fn bool isTransformFeedback (CUInt id) @extern("glIsTransformFeedback");
fn void pauseTransformFeedback () @extern("glPauseTransformFeedback");
fn void resumeTransformFeedback () @extern("glResumeTransformFeedback");
fn void drawTransformFeedback (GLenum mode, CUInt id) @extern("glDrawTransformFeedback");
fn void drawTransformFeedbackStream (GLenum mode, CUInt id, CUInt stream) @extern("glDrawTransformFeedbackStream");
fn void beginQueryIndexed (GLenum target, CUInt index, CUInt id) @extern("glBeginQueryIndexed");
fn void endQueryIndexed (GLenum target, CUInt index) @extern("glEndQueryIndexed");
fn void getQueryIndexediv (GLenum target, CUInt index, GLenum pname, CInt *params) @extern("glGetQueryIndexediv");

/*=====END=====*/
